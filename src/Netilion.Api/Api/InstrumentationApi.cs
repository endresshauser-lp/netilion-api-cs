/* 
 * Netilion API Documentation
 *
 * Welcome to the Netilion API Documentation, which provides interactive access and documentation to our REST API. Please visit our developer portal for further instructions and information: https://developer.netilion.endress.com/ 
 *
 * OpenAPI spec version: 01.00.00
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using Netilion.Api.Client;
using Netilion.Api.Model;

namespace Netilion.Api.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
        public interface IInstrumentationApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Add assets to an instrumentation
        /// </summary>
        /// <remarks>
        /// Add one or more assets to an instrumentation. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the asset.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="instrumentationId">Id of the instrumentation to which the assets will be added</param>
        /// <returns></returns>
        void AddAssetsToInstrumentation (AssetIDs body, long? instrumentationId);

        /// <summary>
        /// Add assets to an instrumentation
        /// </summary>
        /// <remarks>
        /// Add one or more assets to an instrumentation. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the asset.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="instrumentationId">Id of the instrumentation to which the assets will be added</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> AddAssetsToInstrumentationWithHttpInfo (AssetIDs body, long? instrumentationId);
        /// <summary>
        /// Add bill of materials to an instrumentation
        /// </summary>
        /// <remarks>
        /// Add one or more bill of materials to an instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="instrumentationId">Id of the instrumentation to which the bill of materials will be added</param>
        /// <returns></returns>
        void AddBillOfMaterialsToInstrumentation (BillOfMaterialIDs body, long? instrumentationId);

        /// <summary>
        /// Add bill of materials to an instrumentation
        /// </summary>
        /// <remarks>
        /// Add one or more bill of materials to an instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="instrumentationId">Id of the instrumentation to which the bill of materials will be added</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> AddBillOfMaterialsToInstrumentationWithHttpInfo (BillOfMaterialIDs body, long? instrumentationId);
        /// <summary>
        /// Add documents to an instrumentation
        /// </summary>
        /// <remarks>
        /// Add one or more documents to an instrumentation. This action requires &#x60;can_update&#x60; permission on the instrumentation and &#x60;can_read&#x60; permission on the document.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="instrumentationId">Id of the instrumentation to which the documents will be added</param>
        /// <returns></returns>
        void AddDocumentsToInstrumentation (DocumentIDs body, long? instrumentationId);

        /// <summary>
        /// Add documents to an instrumentation
        /// </summary>
        /// <remarks>
        /// Add one or more documents to an instrumentation. This action requires &#x60;can_update&#x60; permission on the instrumentation and &#x60;can_read&#x60; permission on the document.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="instrumentationId">Id of the instrumentation to which the documents will be added</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> AddDocumentsToInstrumentationWithHttpInfo (DocumentIDs body, long? instrumentationId);
        /// <summary>
        /// Add a link as instrumentation picture
        /// </summary>
        /// <remarks>
        /// Add an external resource as instrumentation picture.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Picture link object to be created</param>
        /// <param name="id">Id of the instrumentation</param>
        /// <returns>PictureResponse</returns>
        PictureResponse AddInstrumentationPictureLink (PictureLinkRequest body, long? id);

        /// <summary>
        /// Add a link as instrumentation picture
        /// </summary>
        /// <remarks>
        /// Add an external resource as instrumentation picture.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Picture link object to be created</param>
        /// <param name="id">Id of the instrumentation</param>
        /// <returns>ApiResponse of PictureResponse</returns>
        ApiResponse<PictureResponse> AddInstrumentationPictureLinkWithHttpInfo (PictureLinkRequest body, long? id);
        /// <summary>
        /// Add nodes to an instrumentation
        /// </summary>
        /// <remarks>
        /// Add one or more nodes to an instrumentation in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the node.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="instrumentationId">Id of the instrumentation to which the nodes will be added</param>
        /// <returns></returns>
        void AddNodesToInstrumentation (NodeIDs body, long? instrumentationId);

        /// <summary>
        /// Add nodes to an instrumentation
        /// </summary>
        /// <remarks>
        /// Add one or more nodes to an instrumentation in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the node.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="instrumentationId">Id of the instrumentation to which the nodes will be added</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> AddNodesToInstrumentationWithHttpInfo (NodeIDs body, long? instrumentationId);
        /// <summary>
        /// Create a new event for an instrumentation
        /// </summary>
        /// <remarks>
        /// Events must have a name, and can have a start_datetime (if not provided, the date of creation will be used as default value), end_datetime, event_type, event_status, description and responsible
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object to be created.</param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <returns>EventResponse</returns>
        EventResponse CreateEventForInstrumentation (EventRequestNoInstrumentations body, long? instrumentationId);

        /// <summary>
        /// Create a new event for an instrumentation
        /// </summary>
        /// <remarks>
        /// Events must have a name, and can have a start_datetime (if not provided, the date of creation will be used as default value), end_datetime, event_type, event_status, description and responsible
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object to be created.</param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <returns>ApiResponse of EventResponse</returns>
        ApiResponse<EventResponse> CreateEventForInstrumentationWithHttpInfo (EventRequestNoInstrumentations body, long? instrumentationId);
        /// <summary>
        /// Create a new instrumentation
        /// </summary>
        /// <remarks>
        /// Create a new instrumentation. The tag of the given instrumentation needs to be unique within its parent. The instrumentation will not be created when this constraint is violated.  To assign a parent instrumentation the user needs &#x60;can_permit&#x60; permission on the parent.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Instrumentation object that needs to be created. tag, instrumentation status and instrumentation type are required</param>
        /// <returns>InstrumentationResponse</returns>
        InstrumentationResponse CreateInstrumentation (InstrumentationRequest body);

        /// <summary>
        /// Create a new instrumentation
        /// </summary>
        /// <remarks>
        /// Create a new instrumentation. The tag of the given instrumentation needs to be unique within its parent. The instrumentation will not be created when this constraint is violated.  To assign a parent instrumentation the user needs &#x60;can_permit&#x60; permission on the parent.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Instrumentation object that needs to be created. tag, instrumentation status and instrumentation type are required</param>
        /// <returns>ApiResponse of InstrumentationResponse</returns>
        ApiResponse<InstrumentationResponse> CreateInstrumentationWithHttpInfo (InstrumentationRequest body);
        /// <summary>
        /// Create an instrumentation threshold
        /// </summary>
        /// <remarks>
        /// Create a new instrumentation threshold. This action requires &#x60;&#x60;&#x60;can_udpate&#x60;&#x60;&#x60; permission on the instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object body that will be created.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>ThresholdResponse</returns>
        ThresholdResponse CreateInstrumentationThreshold (ThresholdRequest body, long? instrumentationId);

        /// <summary>
        /// Create an instrumentation threshold
        /// </summary>
        /// <remarks>
        /// Create a new instrumentation threshold. This action requires &#x60;&#x60;&#x60;can_udpate&#x60;&#x60;&#x60; permission on the instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object body that will be created.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>ApiResponse of ThresholdResponse</returns>
        ApiResponse<ThresholdResponse> CreateInstrumentationThresholdWithHttpInfo (ThresholdRequest body, long? instrumentationId);
        /// <summary>
        /// Delete an instrumentation
        /// </summary>
        /// <remarks>
        /// Delete a specific resource in your accessible scope, identified by the id in the URL.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the instrumentation to delete</param>
        /// <returns></returns>
        void DeleteInstrumentation (long? id);

        /// <summary>
        /// Delete an instrumentation
        /// </summary>
        /// <remarks>
        /// Delete a specific resource in your accessible scope, identified by the id in the URL.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the instrumentation to delete</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteInstrumentationWithHttpInfo (long? id);
        /// <summary>
        /// Delete an instrumentation picture
        /// </summary>
        /// <remarks>
        /// Delete an instrumentation picture.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns></returns>
        void DeleteInstrumentationPicture (long? instrumentationId, long? id);

        /// <summary>
        /// Delete an instrumentation picture
        /// </summary>
        /// <remarks>
        /// Delete an instrumentation picture.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteInstrumentationPictureWithHttpInfo (long? instrumentationId, long? id);
        /// <summary>
        /// Delete an instrumentation threshold.
        /// </summary>
        /// <remarks>
        /// Delete an instrumentation threshold.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation threshold</param>
        /// <returns></returns>
        void DeleteInstrumentationThreshold (long? instrumentationId, long? id);

        /// <summary>
        /// Delete an instrumentation threshold.
        /// </summary>
        /// <remarks>
        /// Delete an instrumentation threshold.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation threshold</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteInstrumentationThresholdWithHttpInfo (long? instrumentationId, long? id);
        /// <summary>
        /// Download an instrumentation picture
        /// </summary>
        /// <remarks>
        /// Download an instrumentation picture.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns></returns>
        void DownloadInstrumentationPicture (long? instrumentationId, long? id);

        /// <summary>
        /// Download an instrumentation picture
        /// </summary>
        /// <remarks>
        /// Download an instrumentation picture.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DownloadInstrumentationPictureWithHttpInfo (long? instrumentationId, long? id);
        /// <summary>
        /// Get all assets of one instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of all assets that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;status, tenant, parent, pictures, product, product.manufacturer, product.pictures, product.status, product.categories, product.categories.parent, specifications, specifications[key1,key2], product.tenant,                             product.manufacturer.tenant, status.tenant, instrumentations &#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="serialNumber">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productCategoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="manufacturerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusCode">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productionDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="nodeId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all objects with no nodes assigned or \&quot;!null\&quot; for any assigned node (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="ownershipClaimed">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;serial_number&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, &#x60;last_seen_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>AssetsResponse</returns>
        AssetsResponse GetAssetsOfInstrumentation (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string serialNumber = null, string productId = null, string productCategoryId = null, string parentId = null, string manufacturerId = null, string statusId = null, string statusCode = null, string tenantId = null, DateTime? productionDate = null, DateTime? productionDateFrom = null, DateTime? productionDateTo = null, string specificationsKey = null, string specificationsValue = null, string nodeId = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, bool? ownershipClaimed = null, string permission = null, string orderBy = null);

        /// <summary>
        /// Get all assets of one instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of all assets that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;status, tenant, parent, pictures, product, product.manufacturer, product.pictures, product.status, product.categories, product.categories.parent, specifications, specifications[key1,key2], product.tenant,                             product.manufacturer.tenant, status.tenant, instrumentations &#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="serialNumber">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productCategoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="manufacturerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusCode">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productionDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="nodeId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all objects with no nodes assigned or \&quot;!null\&quot; for any assigned node (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="ownershipClaimed">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;serial_number&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, &#x60;last_seen_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of AssetsResponse</returns>
        ApiResponse<AssetsResponse> GetAssetsOfInstrumentationWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string serialNumber = null, string productId = null, string productCategoryId = null, string parentId = null, string manufacturerId = null, string statusId = null, string statusCode = null, string tenantId = null, DateTime? productionDate = null, DateTime? productionDateFrom = null, DateTime? productionDateTo = null, string specificationsKey = null, string specificationsValue = null, string nodeId = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, bool? ownershipClaimed = null, string permission = null, string orderBy = null);
        /// <summary>
        /// Get all assets an instrumentation was assigned to
        /// </summary>
        /// <remarks>
        /// Returns a list of all assets history available in your scope which have been assigned to the specified instrumentation. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="assetId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="_event">Filter accepts &#x60;create&#x60; or &#x60;destroy&#x60; (optional)</param>
        /// <param name="eventDatetimeFrom">Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="eventDatetimeTo">Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;event&#x60; or &#x60;event_datetime&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>InstrumentationAssetsHistoryResponse</returns>
        InstrumentationAssetsHistoryResponse GetAssetsOfInstrumentationHistory (long? instrumentationId, int? page = null, int? perPage = null, string assetId = null, string _event = null, DateTime? eventDatetimeFrom = null, DateTime? eventDatetimeTo = null, string orderBy = null);

        /// <summary>
        /// Get all assets an instrumentation was assigned to
        /// </summary>
        /// <remarks>
        /// Returns a list of all assets history available in your scope which have been assigned to the specified instrumentation. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="assetId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="_event">Filter accepts &#x60;create&#x60; or &#x60;destroy&#x60; (optional)</param>
        /// <param name="eventDatetimeFrom">Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="eventDatetimeTo">Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;event&#x60; or &#x60;event_datetime&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>ApiResponse of InstrumentationAssetsHistoryResponse</returns>
        ApiResponse<InstrumentationAssetsHistoryResponse> GetAssetsOfInstrumentationHistoryWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string assetId = null, string _event = null, DateTime? eventDatetimeFrom = null, DateTime? eventDatetimeTo = null, string orderBy = null);
        /// <summary>
        /// Get all bill of materials of an instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of all bill of materials that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="author">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="date">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="dateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="dateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <returns>BillOfMaterialsResponse</returns>
        BillOfMaterialsResponse GetBillOfMaterialsOfInstrumentation (long? instrumentationId, int? page = null, int? perPage = null, string name = null, string author = null, string date = null, string dateFrom = null, string dateTo = null);

        /// <summary>
        /// Get all bill of materials of an instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of all bill of materials that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="author">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="date">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="dateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="dateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <returns>ApiResponse of BillOfMaterialsResponse</returns>
        ApiResponse<BillOfMaterialsResponse> GetBillOfMaterialsOfInstrumentationWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string name = null, string author = null, string date = null, string dateFrom = null, string dateTo = null);
        /// <summary>
        /// Get all documents of an instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of documents. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;status, tenant, classification, categories, categories.parent, categories.standards, attachments&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="documentVersion">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="number">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="classificationId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="categoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="validFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validUntil">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validAt">Expected date format is YYYY-MM-DD or YYYY-MM or YYYY (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>DocumentsResponse</returns>
        DocumentsResponse GetDocumentsOfInstrumentation (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string documentVersion = null, string number = null, string statusId = null, string classificationId = null, string tenantId = null, string categoryId = null, DateTime? validFrom = null, DateTime? validUntil = null, DateTime? validAt = null, string acceptLanguage = null);

        /// <summary>
        /// Get all documents of an instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of documents. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;status, tenant, classification, categories, categories.parent, categories.standards, attachments&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="documentVersion">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="number">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="classificationId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="categoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="validFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validUntil">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validAt">Expected date format is YYYY-MM-DD or YYYY-MM or YYYY (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>ApiResponse of DocumentsResponse</returns>
        ApiResponse<DocumentsResponse> GetDocumentsOfInstrumentationWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string documentVersion = null, string number = null, string statusId = null, string classificationId = null, string tenantId = null, string categoryId = null, DateTime? validFrom = null, DateTime? validUntil = null, DateTime? validAt = null, string acceptLanguage = null);
        /// <summary>
        /// Get all events of one instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of all events belonging to an instrumentation in your accessible scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="startDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;start_datetime&#x60;, &#x60;end_datetime&#x60;, &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>EventsResponse</returns>
        EventsResponse GetEventsOfInstrumentation (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string statusId = null, string startDatetime = null, string startDatetimeFrom = null, string startDatetimeTo = null, string endDatetime = null, DateTime? endDatetimeFrom = null, string endDatetimeTo = null, string tenantId = null, string orderBy = null);

        /// <summary>
        /// Get all events of one instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of all events belonging to an instrumentation in your accessible scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="startDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;start_datetime&#x60;, &#x60;end_datetime&#x60;, &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of EventsResponse</returns>
        ApiResponse<EventsResponse> GetEventsOfInstrumentationWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string statusId = null, string startDatetime = null, string startDatetimeFrom = null, string startDatetimeTo = null, string endDatetime = null, DateTime? endDatetimeFrom = null, string endDatetimeTo = null, string tenantId = null, string orderBy = null);
        /// <summary>
        /// Get a single instrumentation
        /// </summary>
        /// <remarks>
        /// Get a specific instrumentation in your accessible scope, identified by the id in the URL.  Possible include values: &#x60;&#x60;&#x60;specifications, specifications[key1,key2], pictures, tenant, parent, status, worst_asset_status, type, type.parent, type.tenant, values, values.unit, values.asset, values_in_preferred_units, values_in_preferred_units.unit, values_in_preferred_units.asset &#x60;&#x60;&#x60; 
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the instrumentation to fetch</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <returns>InstrumentationResponse</returns>
        InstrumentationResponse GetInstrumentationById (long? id, string include = null);

        /// <summary>
        /// Get a single instrumentation
        /// </summary>
        /// <remarks>
        /// Get a specific instrumentation in your accessible scope, identified by the id in the URL.  Possible include values: &#x60;&#x60;&#x60;specifications, specifications[key1,key2], pictures, tenant, parent, status, worst_asset_status, type, type.parent, type.tenant, values, values.unit, values.asset, values_in_preferred_units, values_in_preferred_units.unit, values_in_preferred_units.asset &#x60;&#x60;&#x60; 
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the instrumentation to fetch</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <returns>ApiResponse of InstrumentationResponse</returns>
        ApiResponse<InstrumentationResponse> GetInstrumentationByIdWithHttpInfo (long? id, string include = null);
        /// <summary>
        /// Get the status of the specific instrumentation
        /// </summary>
        /// <remarks>
        /// Returns the status of the instrumentation. Needed if only permission on instrumentation but not on tenant. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>InstrumentationStatusResponse</returns>
        InstrumentationStatusResponse GetInstrumentationIdStatus (long? instrumentationId, string acceptLanguage = null);

        /// <summary>
        /// Get the status of the specific instrumentation
        /// </summary>
        /// <remarks>
        /// Returns the status of the instrumentation. Needed if only permission on instrumentation but not on tenant. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>ApiResponse of InstrumentationStatusResponse</returns>
        ApiResponse<InstrumentationStatusResponse> GetInstrumentationIdStatusWithHttpInfo (long? instrumentationId, string acceptLanguage = null);
        /// <summary>
        /// Get the type of the specific instrumentation
        /// </summary>
        /// <remarks>
        /// Returns the type of the instrumentation. Needed if only permission on instrumentation but not on tenant. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language. Possible include values: &#x60;&#x60;&#x60;parent&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>InstrumentationTypeResponse</returns>
        InstrumentationTypeResponse GetInstrumentationIdType (long? instrumentationId, string acceptLanguage = null);

        /// <summary>
        /// Get the type of the specific instrumentation
        /// </summary>
        /// <remarks>
        /// Returns the type of the instrumentation. Needed if only permission on instrumentation but not on tenant. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language. Possible include values: &#x60;&#x60;&#x60;parent&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>ApiResponse of InstrumentationTypeResponse</returns>
        ApiResponse<InstrumentationTypeResponse> GetInstrumentationIdTypeWithHttpInfo (long? instrumentationId, string acceptLanguage = null);
        /// <summary>
        /// Get an instrumentation picture
        /// </summary>
        /// <remarks>
        /// Get a single picture of an instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>PictureResponse</returns>
        PictureResponse GetInstrumentationPicture (long? instrumentationId, long? id);

        /// <summary>
        /// Get an instrumentation picture
        /// </summary>
        /// <remarks>
        /// Get a single picture of an instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>ApiResponse of PictureResponse</returns>
        ApiResponse<PictureResponse> GetInstrumentationPictureWithHttpInfo (long? instrumentationId, long? id);
        /// <summary>
        /// Get instrumentation pictures
        /// </summary>
        /// <remarks>
        /// Get all pictures of an instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the instrumentation</param>
        /// <param name="width">filter by width (optional)</param>
        /// <param name="widthFrom">filter by width_from (optional)</param>
        /// <param name="widthTo">filter by width_to (optional)</param>
        /// <param name="height">filter by height (optional)</param>
        /// <param name="heightFrom">filter by height_from (optional)</param>
        /// <param name="heightTo">filter by height_to (optional)</param>
        /// <returns>PicturesResponse</returns>
        PicturesResponse GetInstrumentationPictures (long? id, int? width = null, int? widthFrom = null, int? widthTo = null, int? height = null, int? heightFrom = null, int? heightTo = null);

        /// <summary>
        /// Get instrumentation pictures
        /// </summary>
        /// <remarks>
        /// Get all pictures of an instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the instrumentation</param>
        /// <param name="width">filter by width (optional)</param>
        /// <param name="widthFrom">filter by width_from (optional)</param>
        /// <param name="widthTo">filter by width_to (optional)</param>
        /// <param name="height">filter by height (optional)</param>
        /// <param name="heightFrom">filter by height_from (optional)</param>
        /// <param name="heightTo">filter by height_to (optional)</param>
        /// <returns>ApiResponse of PicturesResponse</returns>
        ApiResponse<PicturesResponse> GetInstrumentationPicturesWithHttpInfo (long? id, int? width = null, int? widthFrom = null, int? widthTo = null, int? height = null, int? heightFrom = null, int? heightTo = null);
        /// <summary>
        /// Get all possible statuses of the specified instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of all possible instrumentation statuses for the specified instrument. You can apply the query parameters listed below to get a filtered list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>InstrumentationStatuses</returns>
        InstrumentationStatuses GetInstrumentationStatusesOptions (long? instrumentationId, int? page = null, int? perPage = null, string tenantId = null, string name = null, string code = null, string acceptLanguage = null);

        /// <summary>
        /// Get all possible statuses of the specified instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of all possible instrumentation statuses for the specified instrument. You can apply the query parameters listed below to get a filtered list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>ApiResponse of InstrumentationStatuses</returns>
        ApiResponse<InstrumentationStatuses> GetInstrumentationStatusesOptionsWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string tenantId = null, string name = null, string code = null, string acceptLanguage = null);
        /// <summary>
        /// Get an instrumentation threshold
        /// </summary>
        /// <remarks>
        /// Get a single threshold of an instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation threshold</param>
        /// <returns>ThresholdResponse</returns>
        ThresholdResponse GetInstrumentationThreshold (long? instrumentationId, long? id);

        /// <summary>
        /// Get an instrumentation threshold
        /// </summary>
        /// <remarks>
        /// Get a single threshold of an instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation threshold</param>
        /// <returns>ApiResponse of ThresholdResponse</returns>
        ApiResponse<ThresholdResponse> GetInstrumentationThresholdWithHttpInfo (long? instrumentationId, long? id);
        /// <summary>
        /// Get instrumentation thresholds
        /// </summary>
        /// <remarks>
        /// Get all thresholds of an instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="key">filter by key (optional)</param>
        /// <param name="thresholdType">filter by type (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;name&#x60;, &#x60;key&#x60;, &#x60;threshold_type&#x60;, &#x60;notification&#x60;, &#x60;created_at&#x60;, &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ThresholdsResponse</returns>
        ThresholdsResponse GetInstrumentationThresholds (long? instrumentationId, string key = null, string thresholdType = null, string orderBy = null);

        /// <summary>
        /// Get instrumentation thresholds
        /// </summary>
        /// <remarks>
        /// Get all thresholds of an instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="key">filter by key (optional)</param>
        /// <param name="thresholdType">filter by type (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;name&#x60;, &#x60;key&#x60;, &#x60;threshold_type&#x60;, &#x60;notification&#x60;, &#x60;created_at&#x60;, &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of ThresholdsResponse</returns>
        ApiResponse<ThresholdsResponse> GetInstrumentationThresholdsWithHttpInfo (long? instrumentationId, string key = null, string thresholdType = null, string orderBy = null);
        /// <summary>
        /// Get all possible types of the specified instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of all possible instrumentation types for the specified instrument. You can apply the query parameters listed below to get a filtered list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>InstrumentationTypes</returns>
        InstrumentationTypes GetInstrumentationTypesOptions (long? instrumentationId, int? page = null, int? perPage = null, string tenantId = null, string name = null, string code = null, string acceptLanguage = null);

        /// <summary>
        /// Get all possible types of the specified instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of all possible instrumentation types for the specified instrument. You can apply the query parameters listed below to get a filtered list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>ApiResponse of InstrumentationTypes</returns>
        ApiResponse<InstrumentationTypes> GetInstrumentationTypesOptionsWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string tenantId = null, string name = null, string code = null, string acceptLanguage = null);
        /// <summary>
        /// Get instrumentation value objects for a specific key.
        /// </summary>
        /// <remarks>
        /// Returns a collection of the history value objects of the value objects for the specified key. For a selected result of the value objects the filter parameters selector and interval are mandatory. With the filter parameters from, to or datetime, it is possible to receive the history of a defined time period. Possible include values: &#x60;&#x60;&#x60;asset&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="key">key for the instrumentation values</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="from">Start date filter for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="to">End date for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="datetime">exact date for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="selector">Supported selector methods are &#x60;first, last&#x60;. This value is mandatory if interval is defined. (optional)</param>
        /// <param name="interval">Interval which is used for the selector. The value is mandatory if selector is defined. Supported intervals are number of &#x60;s, m, h, d, w&#x60;. Example &#x60;3h&#x60;. (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;timestamp&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default ordering is the order the values were entered in. (optional)</param>
        /// <returns>AssetKeyValueObjectsResponse</returns>
        AssetKeyValueObjectsResponse GetInstrumentationValueObjectsForKey (long? instrumentationId, string key, int? page = null, int? perPage = null, string include = null, DateTime? from = null, DateTime? to = null, DateTime? datetime = null, string selector = null, string interval = null, string orderBy = null);

        /// <summary>
        /// Get instrumentation value objects for a specific key.
        /// </summary>
        /// <remarks>
        /// Returns a collection of the history value objects of the value objects for the specified key. For a selected result of the value objects the filter parameters selector and interval are mandatory. With the filter parameters from, to or datetime, it is possible to receive the history of a defined time period. Possible include values: &#x60;&#x60;&#x60;asset&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="key">key for the instrumentation values</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="from">Start date filter for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="to">End date for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="datetime">exact date for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="selector">Supported selector methods are &#x60;first, last&#x60;. This value is mandatory if interval is defined. (optional)</param>
        /// <param name="interval">Interval which is used for the selector. The value is mandatory if selector is defined. Supported intervals are number of &#x60;s, m, h, d, w&#x60;. Example &#x60;3h&#x60;. (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;timestamp&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default ordering is the order the values were entered in. (optional)</param>
        /// <returns>ApiResponse of AssetKeyValueObjectsResponse</returns>
        ApiResponse<AssetKeyValueObjectsResponse> GetInstrumentationValueObjectsForKeyWithHttpInfo (long? instrumentationId, string key, int? page = null, int? perPage = null, string include = null, DateTime? from = null, DateTime? to = null, DateTime? datetime = null, string selector = null, string interval = null, string orderBy = null);
        /// <summary>
        /// Get latest values for the instrumentation.
        /// </summary>
        /// <remarks>
        /// Returns a collection of the latest values for all keys of the instrumentation. Possible include values: &#x60;&#x60;&#x60;unit, asset&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="usePreferredUnits">whether to return the values in the preferred units described in the asset specification &#x27;preferred_units&#x27; or not, for the instrumentation the mapping will result from the merge of all its assets mappings. These values have lower precedence than the parameter key_unit_id. Example value of the specification is &#x27;{\&quot;key_1\&quot;\\:\&quot;unit_code_1\&quot;, \&quot;key_2\&quot;\\:\&quot;unit_code_2\&quot;}&#x27; (optional)</param>
        /// <param name="key">only the values of the specified keys will be returned. If no key is specified all keys of the asset with its latest values will be received. Multiple values can be specified in a comma seperated list. (optional)</param>
        /// <param name="keyUnitId">value of the provided key will be returned in the specified unit. If no key_unit is defined the last written unit will be returned. Accepted format is &#x60;key[unit_id]&#x60;. Multiple values can be provided in a comma seperated list. (optional)</param>
        /// <param name="group">Group of the asset value. (optional)</param>
        /// <returns>AssetValuesResponse</returns>
        AssetValuesResponse GetInstrumentationValues (long? instrumentationId, int? page = null, int? perPage = null, string include = null, bool? usePreferredUnits = null, string key = null, string keyUnitId = null, string group = null);

        /// <summary>
        /// Get latest values for the instrumentation.
        /// </summary>
        /// <remarks>
        /// Returns a collection of the latest values for all keys of the instrumentation. Possible include values: &#x60;&#x60;&#x60;unit, asset&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="usePreferredUnits">whether to return the values in the preferred units described in the asset specification &#x27;preferred_units&#x27; or not, for the instrumentation the mapping will result from the merge of all its assets mappings. These values have lower precedence than the parameter key_unit_id. Example value of the specification is &#x27;{\&quot;key_1\&quot;\\:\&quot;unit_code_1\&quot;, \&quot;key_2\&quot;\\:\&quot;unit_code_2\&quot;}&#x27; (optional)</param>
        /// <param name="key">only the values of the specified keys will be returned. If no key is specified all keys of the asset with its latest values will be received. Multiple values can be specified in a comma seperated list. (optional)</param>
        /// <param name="keyUnitId">value of the provided key will be returned in the specified unit. If no key_unit is defined the last written unit will be returned. Accepted format is &#x60;key[unit_id]&#x60;. Multiple values can be provided in a comma seperated list. (optional)</param>
        /// <param name="group">Group of the asset value. (optional)</param>
        /// <returns>ApiResponse of AssetValuesResponse</returns>
        ApiResponse<AssetValuesResponse> GetInstrumentationValuesWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string include = null, bool? usePreferredUnits = null, string key = null, string keyUnitId = null, string group = null);
        /// <summary>
        /// Get instrumentation values for a specific key.
        /// </summary>
        /// <remarks>
        /// Returns a collection of the history values of an values for the specified key. For a aggregated result of the values the filter parameters aggregation and interval are mandatory. Receiving the result in a specific unit please use the filter parameter unit. The allowed units can be found in the intro section. With the filter parameters from to it is possible to receive the history of a defined time period. Possible include values: &#x60;&#x60;&#x60;unit&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="key">key for the instrumentation values</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page, default value is 500, maximum is 1000 (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="usePreferredUnits">whether to return the values in the preferred units described in the asset specification &#x27;preferred_units&#x27; or not, for the instrumentation the mapping will result from the merge of all its assets mappings. These values have lower precedence than the parameter unit_id. Example value of the specification is &#x27;{\&quot;key_1\&quot;\\:\&quot;unit_code_1\&quot;, \&quot;key_2\&quot;\\:\&quot;unit_code_2\&quot;}&#x27; (optional)</param>
        /// <param name="from">Start date filter for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="to">End date for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="unitId">Id of the unit in which the values are to be returned. (optional)</param>
        /// <param name="aggregation">Supported aggregation methods are &#x60;mean, min, max, sum, stddev&#x60;. This value is mandatory if interval is defined. (optional)</param>
        /// <param name="interval">Interval which is used for the aggregation. The value is mandatory if aggregation is defined. Supported intervals are number of &#x60;s, m, h, d, w&#x60;. Example &#x60;3h&#x60;. (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;timestamp&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default ordering is the order the values were entered in. (optional)</param>
        /// <returns>AssetKeyValuesResponse</returns>
        AssetKeyValuesResponse GetInstrumentationValuesForKey (long? instrumentationId, string key, int? page = null, int? perPage = null, string include = null, bool? usePreferredUnits = null, DateTime? from = null, DateTime? to = null, int? unitId = null, string aggregation = null, string interval = null, string orderBy = null);

        /// <summary>
        /// Get instrumentation values for a specific key.
        /// </summary>
        /// <remarks>
        /// Returns a collection of the history values of an values for the specified key. For a aggregated result of the values the filter parameters aggregation and interval are mandatory. Receiving the result in a specific unit please use the filter parameter unit. The allowed units can be found in the intro section. With the filter parameters from to it is possible to receive the history of a defined time period. Possible include values: &#x60;&#x60;&#x60;unit&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="key">key for the instrumentation values</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page, default value is 500, maximum is 1000 (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="usePreferredUnits">whether to return the values in the preferred units described in the asset specification &#x27;preferred_units&#x27; or not, for the instrumentation the mapping will result from the merge of all its assets mappings. These values have lower precedence than the parameter unit_id. Example value of the specification is &#x27;{\&quot;key_1\&quot;\\:\&quot;unit_code_1\&quot;, \&quot;key_2\&quot;\\:\&quot;unit_code_2\&quot;}&#x27; (optional)</param>
        /// <param name="from">Start date filter for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="to">End date for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="unitId">Id of the unit in which the values are to be returned. (optional)</param>
        /// <param name="aggregation">Supported aggregation methods are &#x60;mean, min, max, sum, stddev&#x60;. This value is mandatory if interval is defined. (optional)</param>
        /// <param name="interval">Interval which is used for the aggregation. The value is mandatory if aggregation is defined. Supported intervals are number of &#x60;s, m, h, d, w&#x60;. Example &#x60;3h&#x60;. (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;timestamp&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default ordering is the order the values were entered in. (optional)</param>
        /// <returns>ApiResponse of AssetKeyValuesResponse</returns>
        ApiResponse<AssetKeyValuesResponse> GetInstrumentationValuesForKeyWithHttpInfo (long? instrumentationId, string key, int? page = null, int? perPage = null, string include = null, bool? usePreferredUnits = null, DateTime? from = null, DateTime? to = null, int? unitId = null, string aggregation = null, string interval = null, string orderBy = null);
        /// <summary>
        /// Get a range of instrumentations
        /// </summary>
        /// <remarks>
        /// Returns a list of instrumentations in your accessible scope. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;specifications, specifications[key1,key2], pictures, tenant, parent, status, worst_asset_status, type, type.tenant, type.parent, values, values.unit, values_in_preferred_units, values_in_preferred_units.unit&#x60;&#x60;&#x60; 
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="tag">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="criticality">Filter accepts undefined, low, medium or high (optional)</param>
        /// <param name="accessibility">Filter accepts undefined, easy, moderate or difficult (optional)</param>
        /// <param name="nodeId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all objects with no nodes assigned or \&quot;!null\&quot; for any assigned node.  By adding &#x60;+&#x60; after the id, the filter considers the given node and all its sub components but this is not usable in combination with a comma list. (optional)</param>
        /// <param name="assetId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all objects with no assets assigned or \&quot;!null\&quot; for any assigned asset (optional)</param>
        /// <param name="systemId">One or multiple ids (comma list). Filter accepts \&quot;null\&quot; for all objects with no systems assigned or \&quot;!null\&quot; for any assigned system (optional)</param>
        /// <param name="assetStatusId">One or multiple ids (comma list). Expected id format is integer. This retrieves all Instrumentations where at least one of its assets has one of the given statuses. (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;tag&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>InstrumentationsResponse</returns>
        InstrumentationsResponse GetInstrumentations (int? page = null, int? perPage = null, string include = null, string tag = null, string statusId = null, string typeId = null, string parentId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string criticality = null, string accessibility = null, string nodeId = null, string assetId = null, string systemId = null, string assetStatusId = null, string permission = null, string orderBy = null);

        /// <summary>
        /// Get a range of instrumentations
        /// </summary>
        /// <remarks>
        /// Returns a list of instrumentations in your accessible scope. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;specifications, specifications[key1,key2], pictures, tenant, parent, status, worst_asset_status, type, type.tenant, type.parent, values, values.unit, values_in_preferred_units, values_in_preferred_units.unit&#x60;&#x60;&#x60; 
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="tag">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="criticality">Filter accepts undefined, low, medium or high (optional)</param>
        /// <param name="accessibility">Filter accepts undefined, easy, moderate or difficult (optional)</param>
        /// <param name="nodeId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all objects with no nodes assigned or \&quot;!null\&quot; for any assigned node.  By adding &#x60;+&#x60; after the id, the filter considers the given node and all its sub components but this is not usable in combination with a comma list. (optional)</param>
        /// <param name="assetId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all objects with no assets assigned or \&quot;!null\&quot; for any assigned asset (optional)</param>
        /// <param name="systemId">One or multiple ids (comma list). Filter accepts \&quot;null\&quot; for all objects with no systems assigned or \&quot;!null\&quot; for any assigned system (optional)</param>
        /// <param name="assetStatusId">One or multiple ids (comma list). Expected id format is integer. This retrieves all Instrumentations where at least one of its assets has one of the given statuses. (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;tag&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of InstrumentationsResponse</returns>
        ApiResponse<InstrumentationsResponse> GetInstrumentationsWithHttpInfo (int? page = null, int? perPage = null, string include = null, string tag = null, string statusId = null, string typeId = null, string parentId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string criticality = null, string accessibility = null, string nodeId = null, string assetId = null, string systemId = null, string assetStatusId = null, string permission = null, string orderBy = null);
        /// <summary>
        /// Get all nodes of one Instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of all nodes that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="hidden">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>NodesResponse</returns>
        NodesResponse GetNodesOfInstrumentation (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string parentId = null, string tenantId = null, bool? hidden = null, string permission = null, string orderBy = null);

        /// <summary>
        /// Get all nodes of one Instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of all nodes that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="hidden">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of NodesResponse</returns>
        ApiResponse<NodesResponse> GetNodesOfInstrumentationWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string parentId = null, string tenantId = null, bool? hidden = null, string permission = null, string orderBy = null);
        /// <summary>
        /// Get the history of one specification attribute of an instrumentation.
        /// </summary>
        /// <remarks>
        /// This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>SpecificationHistoryResponse</returns>
        SpecificationHistoryResponse GetSpecificationHistoryOfInstrumentation (long? instrumentationId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null);

        /// <summary>
        /// Get the history of one specification attribute of an instrumentation.
        /// </summary>
        /// <remarks>
        /// This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>ApiResponse of SpecificationHistoryResponse</returns>
        ApiResponse<SpecificationHistoryResponse> GetSpecificationHistoryOfInstrumentationWithHttpInfo (long? instrumentationId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null);
        /// <summary>
        /// Get existing instrumentation specification keys
        /// </summary>
        /// <remarks>
        /// Returns the existing specification keys in all readable instrumentations.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>SpecificationKeys</returns>
        SpecificationKeys GetSpecificationKeysOfInstrumentations (string key = null, bool? uiVisible = null);

        /// <summary>
        /// Get existing instrumentation specification keys
        /// </summary>
        /// <remarks>
        /// Returns the existing specification keys in all readable instrumentations.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>ApiResponse of SpecificationKeys</returns>
        ApiResponse<SpecificationKeys> GetSpecificationKeysOfInstrumentationsWithHttpInfo (string key = null, bool? uiVisible = null);
        /// <summary>
        /// Get specifications of an instrumentation
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>SpecificationsUIVisibleResponse</returns>
        SpecificationsUIVisibleResponse GetSpecificationsOfInstrumentation (long? instrumentationId, string key = null, bool? uiVisible = null);

        /// <summary>
        /// Get specifications of an instrumentation
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>ApiResponse of SpecificationsUIVisibleResponse</returns>
        ApiResponse<SpecificationsUIVisibleResponse> GetSpecificationsOfInstrumentationWithHttpInfo (long? instrumentationId, string key = null, bool? uiVisible = null);
        /// <summary>
        /// Get all systems of one instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of all systems that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;pictures, specifications, specifications[key1,key2], tenant, parent, status, type, type.tenant, type.parent &#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>SystemsResponse</returns>
        SystemsResponse GetSystemsOfInstrumentation (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string statusId = null, string typeId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string permission = null, string orderBy = null);

        /// <summary>
        /// Get all systems of one instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of all systems that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;pictures, specifications, specifications[key1,key2], tenant, parent, status, type, type.tenant, type.parent &#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of SystemsResponse</returns>
        ApiResponse<SystemsResponse> GetSystemsOfInstrumentationWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string statusId = null, string typeId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string permission = null, string orderBy = null);
        /// <summary>
        /// Remove assets from an instrumentation
        /// </summary>
        /// <remarks>
        /// Remove one or more assets from an instrumentation in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the asset.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the assets will be removed</param>
        /// <returns></returns>
        void RemoveAssetsFromInstrumentation (AssetIDs body, long? instrumentationId);

        /// <summary>
        /// Remove assets from an instrumentation
        /// </summary>
        /// <remarks>
        /// Remove one or more assets from an instrumentation in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the asset.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the assets will be removed</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveAssetsFromInstrumentationWithHttpInfo (AssetIDs body, long? instrumentationId);
        /// <summary>
        /// Remove bill of materials from an instrumentation
        /// </summary>
        /// <remarks>
        /// Remove one or more bill of materials from an instrumentation in your accessible scope.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the bill of materials will be removed</param>
        /// <returns></returns>
        void RemoveBillOfMaterialsFromInstrumentation (BillOfMaterialIDs body, long? instrumentationId);

        /// <summary>
        /// Remove bill of materials from an instrumentation
        /// </summary>
        /// <remarks>
        /// Remove one or more bill of materials from an instrumentation in your accessible scope.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the bill of materials will be removed</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveBillOfMaterialsFromInstrumentationWithHttpInfo (BillOfMaterialIDs body, long? instrumentationId);
        /// <summary>
        /// Remove documents from an instrumentation
        /// </summary>
        /// <remarks>
        /// Remove one or more documents from an instrumentation. This action requires &#x60;can_update&#x60; permission on the instrumentation and &#x60;can_read&#x60; permission on the document.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the documents will be removed</param>
        /// <returns></returns>
        void RemoveDocumentsFromInstrumentation (DocumentIDs body, long? instrumentationId);

        /// <summary>
        /// Remove documents from an instrumentation
        /// </summary>
        /// <remarks>
        /// Remove one or more documents from an instrumentation. This action requires &#x60;can_update&#x60; permission on the instrumentation and &#x60;can_read&#x60; permission on the document.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the documents will be removed</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveDocumentsFromInstrumentationWithHttpInfo (DocumentIDs body, long? instrumentationId);
        /// <summary>
        /// Remove events from an instrumentation
        /// </summary>
        /// <remarks>
        /// Remove one or more events from an instrumentation in your accessible scope. If the event has no more related instrumentations, the event will be deleted
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the events will removed.</param>
        /// <returns></returns>
        void RemoveEventFromInstrumentation (Events1 body, long? instrumentationId);

        /// <summary>
        /// Remove events from an instrumentation
        /// </summary>
        /// <remarks>
        /// Remove one or more events from an instrumentation in your accessible scope. If the event has no more related instrumentations, the event will be deleted
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the events will removed.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveEventFromInstrumentationWithHttpInfo (Events1 body, long? instrumentationId);
        /// <summary>
        /// Remove nodes from an instrumentation
        /// </summary>
        /// <remarks>
        /// Remove one or more nodes from an instrumentation in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the node.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the nodes will be removed</param>
        /// <returns></returns>
        void RemoveNodesFromInstrumentation (NodeIDs body, long? instrumentationId);

        /// <summary>
        /// Remove nodes from an instrumentation
        /// </summary>
        /// <remarks>
        /// Remove one or more nodes from an instrumentation in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the node.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the nodes will be removed</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveNodesFromInstrumentationWithHttpInfo (NodeIDs body, long? instrumentationId);
        /// <summary>
        /// Delete specifications of an instrumentation
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns></returns>
        void RemoveSpecificationsFromInstrumentation (List<string> body, long? instrumentationId);

        /// <summary>
        /// Delete specifications of an instrumentation
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveSpecificationsFromInstrumentationWithHttpInfo (List<string> body, long? instrumentationId);
        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of an instrumentation in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns></returns>
        void RenameSpecificationsOfInstrumentation (SpecificationsRename body, long? instrumentationId);

        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of an instrumentation in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RenameSpecificationsOfInstrumentationWithHttpInfo (SpecificationsRename body, long? instrumentationId);
        /// <summary>
        /// Replace the assets of an instrumentation
        /// </summary>
        /// <remarks>
        /// Replaces all assets belonging to an instrumentation. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the asset.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="instrumentationId">Id of the instrumentation of which the assets will be replaced</param>
        /// <returns></returns>
        void ReplaceAssetsOfInstrumentation (AssetIDs body, long? instrumentationId);

        /// <summary>
        /// Replace the assets of an instrumentation
        /// </summary>
        /// <remarks>
        /// Replaces all assets belonging to an instrumentation. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the asset.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="instrumentationId">Id of the instrumentation of which the assets will be replaced</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReplaceAssetsOfInstrumentationWithHttpInfo (AssetIDs body, long? instrumentationId);
        /// <summary>
        /// Replace the bill of materials of an instrumentation
        /// </summary>
        /// <remarks>
        /// Replaces all bill of materials belonging to an instrumentation. You can send a list of resources that will replace all previous values.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="instrumentationId">Id of the instrumentation of which the bill of materials will be replaced</param>
        /// <returns></returns>
        void ReplaceBillOfMaterialsOfInstrumentation (BillOfMaterialIDs body, long? instrumentationId);

        /// <summary>
        /// Replace the bill of materials of an instrumentation
        /// </summary>
        /// <remarks>
        /// Replaces all bill of materials belonging to an instrumentation. You can send a list of resources that will replace all previous values.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="instrumentationId">Id of the instrumentation of which the bill of materials will be replaced</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReplaceBillOfMaterialsOfInstrumentationWithHttpInfo (BillOfMaterialIDs body, long? instrumentationId);
        /// <summary>
        /// Replace the documents of an instrumentation
        /// </summary>
        /// <remarks>
        /// Replaces all documents belonging to an instrumentation. You can send a list of resources that will replace all previous values. This action requires &#x60;can_udpate&#x60; permission on the instrumentation and &#x60;can_read&#x60; permission on the document.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="instrumentationId">Id of the instrumentation of which the documents will be replaced</param>
        /// <returns></returns>
        void ReplaceDocumentsOfInstrumentation (DocumentIDs body, long? instrumentationId);

        /// <summary>
        /// Replace the documents of an instrumentation
        /// </summary>
        /// <remarks>
        /// Replaces all documents belonging to an instrumentation. You can send a list of resources that will replace all previous values. This action requires &#x60;can_udpate&#x60; permission on the instrumentation and &#x60;can_read&#x60; permission on the document.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="instrumentationId">Id of the instrumentation of which the documents will be replaced</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReplaceDocumentsOfInstrumentationWithHttpInfo (DocumentIDs body, long? instrumentationId);
        /// <summary>
        /// Replace the nodes of an instrumentation
        /// </summary>
        /// <remarks>
        /// Replaces all nodes belonging to an instrumentation in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the node.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="instrumentationId">Id of the instrumentation of which the nodes will be replaced</param>
        /// <returns></returns>
        void ReplaceNodesOfInstrumentation (NodeIDs body, long? instrumentationId);

        /// <summary>
        /// Replace the nodes of an instrumentation
        /// </summary>
        /// <remarks>
        /// Replaces all nodes belonging to an instrumentation in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the node.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="instrumentationId">Id of the instrumentation of which the nodes will be replaced</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReplaceNodesOfInstrumentationWithHttpInfo (NodeIDs body, long? instrumentationId);
        /// <summary>
        /// Update an instrumentation
        /// </summary>
        /// <remarks>
        /// Update accessible parameters of the requested resource in your accessible scope. To assign a parent instrumentation the user needs &#x60;can_permit&#x60; permission on the parent and on the current instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the instrumentation to update</param>
        /// <returns></returns>
        void UpdateInstrumentation (InstrumentationRequest body, long? id);

        /// <summary>
        /// Update an instrumentation
        /// </summary>
        /// <remarks>
        /// Update accessible parameters of the requested resource in your accessible scope. To assign a parent instrumentation the user needs &#x60;can_permit&#x60; permission on the parent and on the current instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the instrumentation to update</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateInstrumentationWithHttpInfo (InstrumentationRequest body, long? id);
        /// <summary>
        /// Update an instrumentation picture
        /// </summary>
        /// <remarks>
        /// Upload a new instrumentation picture. Check the file-storage quota. Allowed content-types are - image/gif - image/jpg - image/jpeg - image/png
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="image"></param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>PictureResponse</returns>
        PictureResponse UpdateInstrumentationPicture (byte[] image, long? instrumentationId, long? id);

        /// <summary>
        /// Update an instrumentation picture
        /// </summary>
        /// <remarks>
        /// Upload a new instrumentation picture. Check the file-storage quota. Allowed content-types are - image/gif - image/jpg - image/jpeg - image/png
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="image"></param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>ApiResponse of PictureResponse</returns>
        ApiResponse<PictureResponse> UpdateInstrumentationPictureWithHttpInfo (byte[] image, long? instrumentationId, long? id);
        /// <summary>
        /// Update an instrumentation picture link
        /// </summary>
        /// <remarks>
        /// Update an instrumentation picture link.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Picture link object to be updated</param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>PictureResponse</returns>
        PictureResponse UpdateInstrumentationPictureLink (PictureLinkRequest body, long? instrumentationId, long? id);

        /// <summary>
        /// Update an instrumentation picture link
        /// </summary>
        /// <remarks>
        /// Update an instrumentation picture link.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Picture link object to be updated</param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>ApiResponse of PictureResponse</returns>
        ApiResponse<PictureResponse> UpdateInstrumentationPictureLinkWithHttpInfo (PictureLinkRequest body, long? instrumentationId, long? id);
        /// <summary>
        /// Update an instrumentation threshold
        /// </summary>
        /// <remarks>
        /// Replaces the threshold belonging to an instrumentation. This action requires &#x60;can_update&#x60; permission on the instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object body that will be updated.</param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation threshold</param>
        /// <returns>ThresholdResponse</returns>
        ThresholdResponse UpdateInstrumentationThreshold (ThresholdRequest body, long? instrumentationId, long? id);

        /// <summary>
        /// Update an instrumentation threshold
        /// </summary>
        /// <remarks>
        /// Replaces the threshold belonging to an instrumentation. This action requires &#x60;can_update&#x60; permission on the instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object body that will be updated.</param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation threshold</param>
        /// <returns>ApiResponse of ThresholdResponse</returns>
        ApiResponse<ThresholdResponse> UpdateInstrumentationThresholdWithHttpInfo (ThresholdRequest body, long? instrumentationId, long? id);
        /// <summary>
        /// Update specifications of an instrumentation
        /// </summary>
        /// <remarks>
        /// Update the specification object of an instrumentation in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns></returns>
        void UpdateSpecificationsOfInstrumentation (Dictionary<string, SpecificationUIVisibleRequest> body, long? instrumentationId);

        /// <summary>
        /// Update specifications of an instrumentation
        /// </summary>
        /// <remarks>
        /// Update the specification object of an instrumentation in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateSpecificationsOfInstrumentationWithHttpInfo (Dictionary<string, SpecificationUIVisibleRequest> body, long? instrumentationId);
        /// <summary>
        /// Upload an instrumentation picture
        /// </summary>
        /// <remarks>
        /// Upload a new instrumentation picture. Checks the file-storage quota. Allowed content-types are - image/gif - image/jpg - image/jpeg - image/png
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="image"></param>
        /// <param name="id">Id of the instrumentation</param>
        /// <returns>PictureResponse</returns>
        PictureResponse UploadInstrumentationPicture (byte[] image, long? id);

        /// <summary>
        /// Upload an instrumentation picture
        /// </summary>
        /// <remarks>
        /// Upload a new instrumentation picture. Checks the file-storage quota. Allowed content-types are - image/gif - image/jpg - image/jpeg - image/png
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="image"></param>
        /// <param name="id">Id of the instrumentation</param>
        /// <returns>ApiResponse of PictureResponse</returns>
        ApiResponse<PictureResponse> UploadInstrumentationPictureWithHttpInfo (byte[] image, long? id);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Add assets to an instrumentation
        /// </summary>
        /// <remarks>
        /// Add one or more assets to an instrumentation. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the asset.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="instrumentationId">Id of the instrumentation to which the assets will be added</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task AddAssetsToInstrumentationAsync (AssetIDs body, long? instrumentationId);

        /// <summary>
        /// Add assets to an instrumentation
        /// </summary>
        /// <remarks>
        /// Add one or more assets to an instrumentation. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the asset.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="instrumentationId">Id of the instrumentation to which the assets will be added</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> AddAssetsToInstrumentationAsyncWithHttpInfo (AssetIDs body, long? instrumentationId);
        /// <summary>
        /// Add bill of materials to an instrumentation
        /// </summary>
        /// <remarks>
        /// Add one or more bill of materials to an instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="instrumentationId">Id of the instrumentation to which the bill of materials will be added</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task AddBillOfMaterialsToInstrumentationAsync (BillOfMaterialIDs body, long? instrumentationId);

        /// <summary>
        /// Add bill of materials to an instrumentation
        /// </summary>
        /// <remarks>
        /// Add one or more bill of materials to an instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="instrumentationId">Id of the instrumentation to which the bill of materials will be added</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> AddBillOfMaterialsToInstrumentationAsyncWithHttpInfo (BillOfMaterialIDs body, long? instrumentationId);
        /// <summary>
        /// Add documents to an instrumentation
        /// </summary>
        /// <remarks>
        /// Add one or more documents to an instrumentation. This action requires &#x60;can_update&#x60; permission on the instrumentation and &#x60;can_read&#x60; permission on the document.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="instrumentationId">Id of the instrumentation to which the documents will be added</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task AddDocumentsToInstrumentationAsync (DocumentIDs body, long? instrumentationId);

        /// <summary>
        /// Add documents to an instrumentation
        /// </summary>
        /// <remarks>
        /// Add one or more documents to an instrumentation. This action requires &#x60;can_update&#x60; permission on the instrumentation and &#x60;can_read&#x60; permission on the document.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="instrumentationId">Id of the instrumentation to which the documents will be added</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> AddDocumentsToInstrumentationAsyncWithHttpInfo (DocumentIDs body, long? instrumentationId);
        /// <summary>
        /// Add a link as instrumentation picture
        /// </summary>
        /// <remarks>
        /// Add an external resource as instrumentation picture.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Picture link object to be created</param>
        /// <param name="id">Id of the instrumentation</param>
        /// <returns>Task of PictureResponse</returns>
        System.Threading.Tasks.Task<PictureResponse> AddInstrumentationPictureLinkAsync (PictureLinkRequest body, long? id);

        /// <summary>
        /// Add a link as instrumentation picture
        /// </summary>
        /// <remarks>
        /// Add an external resource as instrumentation picture.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Picture link object to be created</param>
        /// <param name="id">Id of the instrumentation</param>
        /// <returns>Task of ApiResponse (PictureResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<PictureResponse>> AddInstrumentationPictureLinkAsyncWithHttpInfo (PictureLinkRequest body, long? id);
        /// <summary>
        /// Add nodes to an instrumentation
        /// </summary>
        /// <remarks>
        /// Add one or more nodes to an instrumentation in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the node.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="instrumentationId">Id of the instrumentation to which the nodes will be added</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task AddNodesToInstrumentationAsync (NodeIDs body, long? instrumentationId);

        /// <summary>
        /// Add nodes to an instrumentation
        /// </summary>
        /// <remarks>
        /// Add one or more nodes to an instrumentation in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the node.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="instrumentationId">Id of the instrumentation to which the nodes will be added</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> AddNodesToInstrumentationAsyncWithHttpInfo (NodeIDs body, long? instrumentationId);
        /// <summary>
        /// Create a new event for an instrumentation
        /// </summary>
        /// <remarks>
        /// Events must have a name, and can have a start_datetime (if not provided, the date of creation will be used as default value), end_datetime, event_type, event_status, description and responsible
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object to be created.</param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <returns>Task of EventResponse</returns>
        System.Threading.Tasks.Task<EventResponse> CreateEventForInstrumentationAsync (EventRequestNoInstrumentations body, long? instrumentationId);

        /// <summary>
        /// Create a new event for an instrumentation
        /// </summary>
        /// <remarks>
        /// Events must have a name, and can have a start_datetime (if not provided, the date of creation will be used as default value), end_datetime, event_type, event_status, description and responsible
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object to be created.</param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <returns>Task of ApiResponse (EventResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<EventResponse>> CreateEventForInstrumentationAsyncWithHttpInfo (EventRequestNoInstrumentations body, long? instrumentationId);
        /// <summary>
        /// Create a new instrumentation
        /// </summary>
        /// <remarks>
        /// Create a new instrumentation. The tag of the given instrumentation needs to be unique within its parent. The instrumentation will not be created when this constraint is violated.  To assign a parent instrumentation the user needs &#x60;can_permit&#x60; permission on the parent.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Instrumentation object that needs to be created. tag, instrumentation status and instrumentation type are required</param>
        /// <returns>Task of InstrumentationResponse</returns>
        System.Threading.Tasks.Task<InstrumentationResponse> CreateInstrumentationAsync (InstrumentationRequest body);

        /// <summary>
        /// Create a new instrumentation
        /// </summary>
        /// <remarks>
        /// Create a new instrumentation. The tag of the given instrumentation needs to be unique within its parent. The instrumentation will not be created when this constraint is violated.  To assign a parent instrumentation the user needs &#x60;can_permit&#x60; permission on the parent.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Instrumentation object that needs to be created. tag, instrumentation status and instrumentation type are required</param>
        /// <returns>Task of ApiResponse (InstrumentationResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<InstrumentationResponse>> CreateInstrumentationAsyncWithHttpInfo (InstrumentationRequest body);
        /// <summary>
        /// Create an instrumentation threshold
        /// </summary>
        /// <remarks>
        /// Create a new instrumentation threshold. This action requires &#x60;&#x60;&#x60;can_udpate&#x60;&#x60;&#x60; permission on the instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object body that will be created.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>Task of ThresholdResponse</returns>
        System.Threading.Tasks.Task<ThresholdResponse> CreateInstrumentationThresholdAsync (ThresholdRequest body, long? instrumentationId);

        /// <summary>
        /// Create an instrumentation threshold
        /// </summary>
        /// <remarks>
        /// Create a new instrumentation threshold. This action requires &#x60;&#x60;&#x60;can_udpate&#x60;&#x60;&#x60; permission on the instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object body that will be created.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>Task of ApiResponse (ThresholdResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<ThresholdResponse>> CreateInstrumentationThresholdAsyncWithHttpInfo (ThresholdRequest body, long? instrumentationId);
        /// <summary>
        /// Delete an instrumentation
        /// </summary>
        /// <remarks>
        /// Delete a specific resource in your accessible scope, identified by the id in the URL.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the instrumentation to delete</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteInstrumentationAsync (long? id);

        /// <summary>
        /// Delete an instrumentation
        /// </summary>
        /// <remarks>
        /// Delete a specific resource in your accessible scope, identified by the id in the URL.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the instrumentation to delete</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteInstrumentationAsyncWithHttpInfo (long? id);
        /// <summary>
        /// Delete an instrumentation picture
        /// </summary>
        /// <remarks>
        /// Delete an instrumentation picture.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteInstrumentationPictureAsync (long? instrumentationId, long? id);

        /// <summary>
        /// Delete an instrumentation picture
        /// </summary>
        /// <remarks>
        /// Delete an instrumentation picture.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteInstrumentationPictureAsyncWithHttpInfo (long? instrumentationId, long? id);
        /// <summary>
        /// Delete an instrumentation threshold.
        /// </summary>
        /// <remarks>
        /// Delete an instrumentation threshold.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation threshold</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteInstrumentationThresholdAsync (long? instrumentationId, long? id);

        /// <summary>
        /// Delete an instrumentation threshold.
        /// </summary>
        /// <remarks>
        /// Delete an instrumentation threshold.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation threshold</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteInstrumentationThresholdAsyncWithHttpInfo (long? instrumentationId, long? id);
        /// <summary>
        /// Download an instrumentation picture
        /// </summary>
        /// <remarks>
        /// Download an instrumentation picture.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DownloadInstrumentationPictureAsync (long? instrumentationId, long? id);

        /// <summary>
        /// Download an instrumentation picture
        /// </summary>
        /// <remarks>
        /// Download an instrumentation picture.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DownloadInstrumentationPictureAsyncWithHttpInfo (long? instrumentationId, long? id);
        /// <summary>
        /// Get all assets of one instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of all assets that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;status, tenant, parent, pictures, product, product.manufacturer, product.pictures, product.status, product.categories, product.categories.parent, specifications, specifications[key1,key2], product.tenant,                             product.manufacturer.tenant, status.tenant, instrumentations &#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="serialNumber">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productCategoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="manufacturerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusCode">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productionDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="nodeId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all objects with no nodes assigned or \&quot;!null\&quot; for any assigned node (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="ownershipClaimed">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;serial_number&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, &#x60;last_seen_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of AssetsResponse</returns>
        System.Threading.Tasks.Task<AssetsResponse> GetAssetsOfInstrumentationAsync (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string serialNumber = null, string productId = null, string productCategoryId = null, string parentId = null, string manufacturerId = null, string statusId = null, string statusCode = null, string tenantId = null, DateTime? productionDate = null, DateTime? productionDateFrom = null, DateTime? productionDateTo = null, string specificationsKey = null, string specificationsValue = null, string nodeId = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, bool? ownershipClaimed = null, string permission = null, string orderBy = null);

        /// <summary>
        /// Get all assets of one instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of all assets that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;status, tenant, parent, pictures, product, product.manufacturer, product.pictures, product.status, product.categories, product.categories.parent, specifications, specifications[key1,key2], product.tenant,                             product.manufacturer.tenant, status.tenant, instrumentations &#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="serialNumber">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productCategoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="manufacturerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusCode">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productionDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="nodeId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all objects with no nodes assigned or \&quot;!null\&quot; for any assigned node (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="ownershipClaimed">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;serial_number&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, &#x60;last_seen_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (AssetsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<AssetsResponse>> GetAssetsOfInstrumentationAsyncWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string serialNumber = null, string productId = null, string productCategoryId = null, string parentId = null, string manufacturerId = null, string statusId = null, string statusCode = null, string tenantId = null, DateTime? productionDate = null, DateTime? productionDateFrom = null, DateTime? productionDateTo = null, string specificationsKey = null, string specificationsValue = null, string nodeId = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, bool? ownershipClaimed = null, string permission = null, string orderBy = null);
        /// <summary>
        /// Get all assets an instrumentation was assigned to
        /// </summary>
        /// <remarks>
        /// Returns a list of all assets history available in your scope which have been assigned to the specified instrumentation. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="assetId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="_event">Filter accepts &#x60;create&#x60; or &#x60;destroy&#x60; (optional)</param>
        /// <param name="eventDatetimeFrom">Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="eventDatetimeTo">Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;event&#x60; or &#x60;event_datetime&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>Task of InstrumentationAssetsHistoryResponse</returns>
        System.Threading.Tasks.Task<InstrumentationAssetsHistoryResponse> GetAssetsOfInstrumentationHistoryAsync (long? instrumentationId, int? page = null, int? perPage = null, string assetId = null, string _event = null, DateTime? eventDatetimeFrom = null, DateTime? eventDatetimeTo = null, string orderBy = null);

        /// <summary>
        /// Get all assets an instrumentation was assigned to
        /// </summary>
        /// <remarks>
        /// Returns a list of all assets history available in your scope which have been assigned to the specified instrumentation. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="assetId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="_event">Filter accepts &#x60;create&#x60; or &#x60;destroy&#x60; (optional)</param>
        /// <param name="eventDatetimeFrom">Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="eventDatetimeTo">Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;event&#x60; or &#x60;event_datetime&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>Task of ApiResponse (InstrumentationAssetsHistoryResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<InstrumentationAssetsHistoryResponse>> GetAssetsOfInstrumentationHistoryAsyncWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string assetId = null, string _event = null, DateTime? eventDatetimeFrom = null, DateTime? eventDatetimeTo = null, string orderBy = null);
        /// <summary>
        /// Get all bill of materials of an instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of all bill of materials that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="author">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="date">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="dateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="dateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <returns>Task of BillOfMaterialsResponse</returns>
        System.Threading.Tasks.Task<BillOfMaterialsResponse> GetBillOfMaterialsOfInstrumentationAsync (long? instrumentationId, int? page = null, int? perPage = null, string name = null, string author = null, string date = null, string dateFrom = null, string dateTo = null);

        /// <summary>
        /// Get all bill of materials of an instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of all bill of materials that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="author">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="date">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="dateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="dateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <returns>Task of ApiResponse (BillOfMaterialsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<BillOfMaterialsResponse>> GetBillOfMaterialsOfInstrumentationAsyncWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string name = null, string author = null, string date = null, string dateFrom = null, string dateTo = null);
        /// <summary>
        /// Get all documents of an instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of documents. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;status, tenant, classification, categories, categories.parent, categories.standards, attachments&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="documentVersion">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="number">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="classificationId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="categoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="validFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validUntil">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validAt">Expected date format is YYYY-MM-DD or YYYY-MM or YYYY (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of DocumentsResponse</returns>
        System.Threading.Tasks.Task<DocumentsResponse> GetDocumentsOfInstrumentationAsync (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string documentVersion = null, string number = null, string statusId = null, string classificationId = null, string tenantId = null, string categoryId = null, DateTime? validFrom = null, DateTime? validUntil = null, DateTime? validAt = null, string acceptLanguage = null);

        /// <summary>
        /// Get all documents of an instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of documents. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;status, tenant, classification, categories, categories.parent, categories.standards, attachments&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="documentVersion">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="number">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="classificationId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="categoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="validFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validUntil">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validAt">Expected date format is YYYY-MM-DD or YYYY-MM or YYYY (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of ApiResponse (DocumentsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<DocumentsResponse>> GetDocumentsOfInstrumentationAsyncWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string documentVersion = null, string number = null, string statusId = null, string classificationId = null, string tenantId = null, string categoryId = null, DateTime? validFrom = null, DateTime? validUntil = null, DateTime? validAt = null, string acceptLanguage = null);
        /// <summary>
        /// Get all events of one instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of all events belonging to an instrumentation in your accessible scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="startDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;start_datetime&#x60;, &#x60;end_datetime&#x60;, &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of EventsResponse</returns>
        System.Threading.Tasks.Task<EventsResponse> GetEventsOfInstrumentationAsync (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string statusId = null, string startDatetime = null, string startDatetimeFrom = null, string startDatetimeTo = null, string endDatetime = null, DateTime? endDatetimeFrom = null, string endDatetimeTo = null, string tenantId = null, string orderBy = null);

        /// <summary>
        /// Get all events of one instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of all events belonging to an instrumentation in your accessible scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="startDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;start_datetime&#x60;, &#x60;end_datetime&#x60;, &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (EventsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<EventsResponse>> GetEventsOfInstrumentationAsyncWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string statusId = null, string startDatetime = null, string startDatetimeFrom = null, string startDatetimeTo = null, string endDatetime = null, DateTime? endDatetimeFrom = null, string endDatetimeTo = null, string tenantId = null, string orderBy = null);
        /// <summary>
        /// Get a single instrumentation
        /// </summary>
        /// <remarks>
        /// Get a specific instrumentation in your accessible scope, identified by the id in the URL.  Possible include values: &#x60;&#x60;&#x60;specifications, specifications[key1,key2], pictures, tenant, parent, status, worst_asset_status, type, type.parent, type.tenant, values, values.unit, values.asset, values_in_preferred_units, values_in_preferred_units.unit, values_in_preferred_units.asset &#x60;&#x60;&#x60; 
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the instrumentation to fetch</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <returns>Task of InstrumentationResponse</returns>
        System.Threading.Tasks.Task<InstrumentationResponse> GetInstrumentationByIdAsync (long? id, string include = null);

        /// <summary>
        /// Get a single instrumentation
        /// </summary>
        /// <remarks>
        /// Get a specific instrumentation in your accessible scope, identified by the id in the URL.  Possible include values: &#x60;&#x60;&#x60;specifications, specifications[key1,key2], pictures, tenant, parent, status, worst_asset_status, type, type.parent, type.tenant, values, values.unit, values.asset, values_in_preferred_units, values_in_preferred_units.unit, values_in_preferred_units.asset &#x60;&#x60;&#x60; 
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the instrumentation to fetch</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <returns>Task of ApiResponse (InstrumentationResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<InstrumentationResponse>> GetInstrumentationByIdAsyncWithHttpInfo (long? id, string include = null);
        /// <summary>
        /// Get the status of the specific instrumentation
        /// </summary>
        /// <remarks>
        /// Returns the status of the instrumentation. Needed if only permission on instrumentation but not on tenant. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of InstrumentationStatusResponse</returns>
        System.Threading.Tasks.Task<InstrumentationStatusResponse> GetInstrumentationIdStatusAsync (long? instrumentationId, string acceptLanguage = null);

        /// <summary>
        /// Get the status of the specific instrumentation
        /// </summary>
        /// <remarks>
        /// Returns the status of the instrumentation. Needed if only permission on instrumentation but not on tenant. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of ApiResponse (InstrumentationStatusResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<InstrumentationStatusResponse>> GetInstrumentationIdStatusAsyncWithHttpInfo (long? instrumentationId, string acceptLanguage = null);
        /// <summary>
        /// Get the type of the specific instrumentation
        /// </summary>
        /// <remarks>
        /// Returns the type of the instrumentation. Needed if only permission on instrumentation but not on tenant. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language. Possible include values: &#x60;&#x60;&#x60;parent&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of InstrumentationTypeResponse</returns>
        System.Threading.Tasks.Task<InstrumentationTypeResponse> GetInstrumentationIdTypeAsync (long? instrumentationId, string acceptLanguage = null);

        /// <summary>
        /// Get the type of the specific instrumentation
        /// </summary>
        /// <remarks>
        /// Returns the type of the instrumentation. Needed if only permission on instrumentation but not on tenant. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language. Possible include values: &#x60;&#x60;&#x60;parent&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of ApiResponse (InstrumentationTypeResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<InstrumentationTypeResponse>> GetInstrumentationIdTypeAsyncWithHttpInfo (long? instrumentationId, string acceptLanguage = null);
        /// <summary>
        /// Get an instrumentation picture
        /// </summary>
        /// <remarks>
        /// Get a single picture of an instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>Task of PictureResponse</returns>
        System.Threading.Tasks.Task<PictureResponse> GetInstrumentationPictureAsync (long? instrumentationId, long? id);

        /// <summary>
        /// Get an instrumentation picture
        /// </summary>
        /// <remarks>
        /// Get a single picture of an instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>Task of ApiResponse (PictureResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<PictureResponse>> GetInstrumentationPictureAsyncWithHttpInfo (long? instrumentationId, long? id);
        /// <summary>
        /// Get instrumentation pictures
        /// </summary>
        /// <remarks>
        /// Get all pictures of an instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the instrumentation</param>
        /// <param name="width">filter by width (optional)</param>
        /// <param name="widthFrom">filter by width_from (optional)</param>
        /// <param name="widthTo">filter by width_to (optional)</param>
        /// <param name="height">filter by height (optional)</param>
        /// <param name="heightFrom">filter by height_from (optional)</param>
        /// <param name="heightTo">filter by height_to (optional)</param>
        /// <returns>Task of PicturesResponse</returns>
        System.Threading.Tasks.Task<PicturesResponse> GetInstrumentationPicturesAsync (long? id, int? width = null, int? widthFrom = null, int? widthTo = null, int? height = null, int? heightFrom = null, int? heightTo = null);

        /// <summary>
        /// Get instrumentation pictures
        /// </summary>
        /// <remarks>
        /// Get all pictures of an instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the instrumentation</param>
        /// <param name="width">filter by width (optional)</param>
        /// <param name="widthFrom">filter by width_from (optional)</param>
        /// <param name="widthTo">filter by width_to (optional)</param>
        /// <param name="height">filter by height (optional)</param>
        /// <param name="heightFrom">filter by height_from (optional)</param>
        /// <param name="heightTo">filter by height_to (optional)</param>
        /// <returns>Task of ApiResponse (PicturesResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<PicturesResponse>> GetInstrumentationPicturesAsyncWithHttpInfo (long? id, int? width = null, int? widthFrom = null, int? widthTo = null, int? height = null, int? heightFrom = null, int? heightTo = null);
        /// <summary>
        /// Get all possible statuses of the specified instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of all possible instrumentation statuses for the specified instrument. You can apply the query parameters listed below to get a filtered list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of InstrumentationStatuses</returns>
        System.Threading.Tasks.Task<InstrumentationStatuses> GetInstrumentationStatusesOptionsAsync (long? instrumentationId, int? page = null, int? perPage = null, string tenantId = null, string name = null, string code = null, string acceptLanguage = null);

        /// <summary>
        /// Get all possible statuses of the specified instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of all possible instrumentation statuses for the specified instrument. You can apply the query parameters listed below to get a filtered list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of ApiResponse (InstrumentationStatuses)</returns>
        System.Threading.Tasks.Task<ApiResponse<InstrumentationStatuses>> GetInstrumentationStatusesOptionsAsyncWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string tenantId = null, string name = null, string code = null, string acceptLanguage = null);
        /// <summary>
        /// Get an instrumentation threshold
        /// </summary>
        /// <remarks>
        /// Get a single threshold of an instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation threshold</param>
        /// <returns>Task of ThresholdResponse</returns>
        System.Threading.Tasks.Task<ThresholdResponse> GetInstrumentationThresholdAsync (long? instrumentationId, long? id);

        /// <summary>
        /// Get an instrumentation threshold
        /// </summary>
        /// <remarks>
        /// Get a single threshold of an instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation threshold</param>
        /// <returns>Task of ApiResponse (ThresholdResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<ThresholdResponse>> GetInstrumentationThresholdAsyncWithHttpInfo (long? instrumentationId, long? id);
        /// <summary>
        /// Get instrumentation thresholds
        /// </summary>
        /// <remarks>
        /// Get all thresholds of an instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="key">filter by key (optional)</param>
        /// <param name="thresholdType">filter by type (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;name&#x60;, &#x60;key&#x60;, &#x60;threshold_type&#x60;, &#x60;notification&#x60;, &#x60;created_at&#x60;, &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ThresholdsResponse</returns>
        System.Threading.Tasks.Task<ThresholdsResponse> GetInstrumentationThresholdsAsync (long? instrumentationId, string key = null, string thresholdType = null, string orderBy = null);

        /// <summary>
        /// Get instrumentation thresholds
        /// </summary>
        /// <remarks>
        /// Get all thresholds of an instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="key">filter by key (optional)</param>
        /// <param name="thresholdType">filter by type (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;name&#x60;, &#x60;key&#x60;, &#x60;threshold_type&#x60;, &#x60;notification&#x60;, &#x60;created_at&#x60;, &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (ThresholdsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<ThresholdsResponse>> GetInstrumentationThresholdsAsyncWithHttpInfo (long? instrumentationId, string key = null, string thresholdType = null, string orderBy = null);
        /// <summary>
        /// Get all possible types of the specified instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of all possible instrumentation types for the specified instrument. You can apply the query parameters listed below to get a filtered list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of InstrumentationTypes</returns>
        System.Threading.Tasks.Task<InstrumentationTypes> GetInstrumentationTypesOptionsAsync (long? instrumentationId, int? page = null, int? perPage = null, string tenantId = null, string name = null, string code = null, string acceptLanguage = null);

        /// <summary>
        /// Get all possible types of the specified instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of all possible instrumentation types for the specified instrument. You can apply the query parameters listed below to get a filtered list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of ApiResponse (InstrumentationTypes)</returns>
        System.Threading.Tasks.Task<ApiResponse<InstrumentationTypes>> GetInstrumentationTypesOptionsAsyncWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string tenantId = null, string name = null, string code = null, string acceptLanguage = null);
        /// <summary>
        /// Get instrumentation value objects for a specific key.
        /// </summary>
        /// <remarks>
        /// Returns a collection of the history value objects of the value objects for the specified key. For a selected result of the value objects the filter parameters selector and interval are mandatory. With the filter parameters from, to or datetime, it is possible to receive the history of a defined time period. Possible include values: &#x60;&#x60;&#x60;asset&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="key">key for the instrumentation values</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="from">Start date filter for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="to">End date for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="datetime">exact date for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="selector">Supported selector methods are &#x60;first, last&#x60;. This value is mandatory if interval is defined. (optional)</param>
        /// <param name="interval">Interval which is used for the selector. The value is mandatory if selector is defined. Supported intervals are number of &#x60;s, m, h, d, w&#x60;. Example &#x60;3h&#x60;. (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;timestamp&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default ordering is the order the values were entered in. (optional)</param>
        /// <returns>Task of AssetKeyValueObjectsResponse</returns>
        System.Threading.Tasks.Task<AssetKeyValueObjectsResponse> GetInstrumentationValueObjectsForKeyAsync (long? instrumentationId, string key, int? page = null, int? perPage = null, string include = null, DateTime? from = null, DateTime? to = null, DateTime? datetime = null, string selector = null, string interval = null, string orderBy = null);

        /// <summary>
        /// Get instrumentation value objects for a specific key.
        /// </summary>
        /// <remarks>
        /// Returns a collection of the history value objects of the value objects for the specified key. For a selected result of the value objects the filter parameters selector and interval are mandatory. With the filter parameters from, to or datetime, it is possible to receive the history of a defined time period. Possible include values: &#x60;&#x60;&#x60;asset&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="key">key for the instrumentation values</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="from">Start date filter for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="to">End date for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="datetime">exact date for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="selector">Supported selector methods are &#x60;first, last&#x60;. This value is mandatory if interval is defined. (optional)</param>
        /// <param name="interval">Interval which is used for the selector. The value is mandatory if selector is defined. Supported intervals are number of &#x60;s, m, h, d, w&#x60;. Example &#x60;3h&#x60;. (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;timestamp&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default ordering is the order the values were entered in. (optional)</param>
        /// <returns>Task of ApiResponse (AssetKeyValueObjectsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<AssetKeyValueObjectsResponse>> GetInstrumentationValueObjectsForKeyAsyncWithHttpInfo (long? instrumentationId, string key, int? page = null, int? perPage = null, string include = null, DateTime? from = null, DateTime? to = null, DateTime? datetime = null, string selector = null, string interval = null, string orderBy = null);
        /// <summary>
        /// Get latest values for the instrumentation.
        /// </summary>
        /// <remarks>
        /// Returns a collection of the latest values for all keys of the instrumentation. Possible include values: &#x60;&#x60;&#x60;unit, asset&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="usePreferredUnits">whether to return the values in the preferred units described in the asset specification &#x27;preferred_units&#x27; or not, for the instrumentation the mapping will result from the merge of all its assets mappings. These values have lower precedence than the parameter key_unit_id. Example value of the specification is &#x27;{\&quot;key_1\&quot;\\:\&quot;unit_code_1\&quot;, \&quot;key_2\&quot;\\:\&quot;unit_code_2\&quot;}&#x27; (optional)</param>
        /// <param name="key">only the values of the specified keys will be returned. If no key is specified all keys of the asset with its latest values will be received. Multiple values can be specified in a comma seperated list. (optional)</param>
        /// <param name="keyUnitId">value of the provided key will be returned in the specified unit. If no key_unit is defined the last written unit will be returned. Accepted format is &#x60;key[unit_id]&#x60;. Multiple values can be provided in a comma seperated list. (optional)</param>
        /// <param name="group">Group of the asset value. (optional)</param>
        /// <returns>Task of AssetValuesResponse</returns>
        System.Threading.Tasks.Task<AssetValuesResponse> GetInstrumentationValuesAsync (long? instrumentationId, int? page = null, int? perPage = null, string include = null, bool? usePreferredUnits = null, string key = null, string keyUnitId = null, string group = null);

        /// <summary>
        /// Get latest values for the instrumentation.
        /// </summary>
        /// <remarks>
        /// Returns a collection of the latest values for all keys of the instrumentation. Possible include values: &#x60;&#x60;&#x60;unit, asset&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="usePreferredUnits">whether to return the values in the preferred units described in the asset specification &#x27;preferred_units&#x27; or not, for the instrumentation the mapping will result from the merge of all its assets mappings. These values have lower precedence than the parameter key_unit_id. Example value of the specification is &#x27;{\&quot;key_1\&quot;\\:\&quot;unit_code_1\&quot;, \&quot;key_2\&quot;\\:\&quot;unit_code_2\&quot;}&#x27; (optional)</param>
        /// <param name="key">only the values of the specified keys will be returned. If no key is specified all keys of the asset with its latest values will be received. Multiple values can be specified in a comma seperated list. (optional)</param>
        /// <param name="keyUnitId">value of the provided key will be returned in the specified unit. If no key_unit is defined the last written unit will be returned. Accepted format is &#x60;key[unit_id]&#x60;. Multiple values can be provided in a comma seperated list. (optional)</param>
        /// <param name="group">Group of the asset value. (optional)</param>
        /// <returns>Task of ApiResponse (AssetValuesResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<AssetValuesResponse>> GetInstrumentationValuesAsyncWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string include = null, bool? usePreferredUnits = null, string key = null, string keyUnitId = null, string group = null);
        /// <summary>
        /// Get instrumentation values for a specific key.
        /// </summary>
        /// <remarks>
        /// Returns a collection of the history values of an values for the specified key. For a aggregated result of the values the filter parameters aggregation and interval are mandatory. Receiving the result in a specific unit please use the filter parameter unit. The allowed units can be found in the intro section. With the filter parameters from to it is possible to receive the history of a defined time period. Possible include values: &#x60;&#x60;&#x60;unit&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="key">key for the instrumentation values</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page, default value is 500, maximum is 1000 (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="usePreferredUnits">whether to return the values in the preferred units described in the asset specification &#x27;preferred_units&#x27; or not, for the instrumentation the mapping will result from the merge of all its assets mappings. These values have lower precedence than the parameter unit_id. Example value of the specification is &#x27;{\&quot;key_1\&quot;\\:\&quot;unit_code_1\&quot;, \&quot;key_2\&quot;\\:\&quot;unit_code_2\&quot;}&#x27; (optional)</param>
        /// <param name="from">Start date filter for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="to">End date for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="unitId">Id of the unit in which the values are to be returned. (optional)</param>
        /// <param name="aggregation">Supported aggregation methods are &#x60;mean, min, max, sum, stddev&#x60;. This value is mandatory if interval is defined. (optional)</param>
        /// <param name="interval">Interval which is used for the aggregation. The value is mandatory if aggregation is defined. Supported intervals are number of &#x60;s, m, h, d, w&#x60;. Example &#x60;3h&#x60;. (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;timestamp&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default ordering is the order the values were entered in. (optional)</param>
        /// <returns>Task of AssetKeyValuesResponse</returns>
        System.Threading.Tasks.Task<AssetKeyValuesResponse> GetInstrumentationValuesForKeyAsync (long? instrumentationId, string key, int? page = null, int? perPage = null, string include = null, bool? usePreferredUnits = null, DateTime? from = null, DateTime? to = null, int? unitId = null, string aggregation = null, string interval = null, string orderBy = null);

        /// <summary>
        /// Get instrumentation values for a specific key.
        /// </summary>
        /// <remarks>
        /// Returns a collection of the history values of an values for the specified key. For a aggregated result of the values the filter parameters aggregation and interval are mandatory. Receiving the result in a specific unit please use the filter parameter unit. The allowed units can be found in the intro section. With the filter parameters from to it is possible to receive the history of a defined time period. Possible include values: &#x60;&#x60;&#x60;unit&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="key">key for the instrumentation values</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page, default value is 500, maximum is 1000 (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="usePreferredUnits">whether to return the values in the preferred units described in the asset specification &#x27;preferred_units&#x27; or not, for the instrumentation the mapping will result from the merge of all its assets mappings. These values have lower precedence than the parameter unit_id. Example value of the specification is &#x27;{\&quot;key_1\&quot;\\:\&quot;unit_code_1\&quot;, \&quot;key_2\&quot;\\:\&quot;unit_code_2\&quot;}&#x27; (optional)</param>
        /// <param name="from">Start date filter for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="to">End date for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="unitId">Id of the unit in which the values are to be returned. (optional)</param>
        /// <param name="aggregation">Supported aggregation methods are &#x60;mean, min, max, sum, stddev&#x60;. This value is mandatory if interval is defined. (optional)</param>
        /// <param name="interval">Interval which is used for the aggregation. The value is mandatory if aggregation is defined. Supported intervals are number of &#x60;s, m, h, d, w&#x60;. Example &#x60;3h&#x60;. (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;timestamp&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default ordering is the order the values were entered in. (optional)</param>
        /// <returns>Task of ApiResponse (AssetKeyValuesResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<AssetKeyValuesResponse>> GetInstrumentationValuesForKeyAsyncWithHttpInfo (long? instrumentationId, string key, int? page = null, int? perPage = null, string include = null, bool? usePreferredUnits = null, DateTime? from = null, DateTime? to = null, int? unitId = null, string aggregation = null, string interval = null, string orderBy = null);
        /// <summary>
        /// Get a range of instrumentations
        /// </summary>
        /// <remarks>
        /// Returns a list of instrumentations in your accessible scope. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;specifications, specifications[key1,key2], pictures, tenant, parent, status, worst_asset_status, type, type.tenant, type.parent, values, values.unit, values_in_preferred_units, values_in_preferred_units.unit&#x60;&#x60;&#x60; 
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="tag">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="criticality">Filter accepts undefined, low, medium or high (optional)</param>
        /// <param name="accessibility">Filter accepts undefined, easy, moderate or difficult (optional)</param>
        /// <param name="nodeId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all objects with no nodes assigned or \&quot;!null\&quot; for any assigned node.  By adding &#x60;+&#x60; after the id, the filter considers the given node and all its sub components but this is not usable in combination with a comma list. (optional)</param>
        /// <param name="assetId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all objects with no assets assigned or \&quot;!null\&quot; for any assigned asset (optional)</param>
        /// <param name="systemId">One or multiple ids (comma list). Filter accepts \&quot;null\&quot; for all objects with no systems assigned or \&quot;!null\&quot; for any assigned system (optional)</param>
        /// <param name="assetStatusId">One or multiple ids (comma list). Expected id format is integer. This retrieves all Instrumentations where at least one of its assets has one of the given statuses. (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;tag&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of InstrumentationsResponse</returns>
        System.Threading.Tasks.Task<InstrumentationsResponse> GetInstrumentationsAsync (int? page = null, int? perPage = null, string include = null, string tag = null, string statusId = null, string typeId = null, string parentId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string criticality = null, string accessibility = null, string nodeId = null, string assetId = null, string systemId = null, string assetStatusId = null, string permission = null, string orderBy = null);

        /// <summary>
        /// Get a range of instrumentations
        /// </summary>
        /// <remarks>
        /// Returns a list of instrumentations in your accessible scope. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;specifications, specifications[key1,key2], pictures, tenant, parent, status, worst_asset_status, type, type.tenant, type.parent, values, values.unit, values_in_preferred_units, values_in_preferred_units.unit&#x60;&#x60;&#x60; 
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="tag">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="criticality">Filter accepts undefined, low, medium or high (optional)</param>
        /// <param name="accessibility">Filter accepts undefined, easy, moderate or difficult (optional)</param>
        /// <param name="nodeId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all objects with no nodes assigned or \&quot;!null\&quot; for any assigned node.  By adding &#x60;+&#x60; after the id, the filter considers the given node and all its sub components but this is not usable in combination with a comma list. (optional)</param>
        /// <param name="assetId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all objects with no assets assigned or \&quot;!null\&quot; for any assigned asset (optional)</param>
        /// <param name="systemId">One or multiple ids (comma list). Filter accepts \&quot;null\&quot; for all objects with no systems assigned or \&quot;!null\&quot; for any assigned system (optional)</param>
        /// <param name="assetStatusId">One or multiple ids (comma list). Expected id format is integer. This retrieves all Instrumentations where at least one of its assets has one of the given statuses. (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;tag&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (InstrumentationsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<InstrumentationsResponse>> GetInstrumentationsAsyncWithHttpInfo (int? page = null, int? perPage = null, string include = null, string tag = null, string statusId = null, string typeId = null, string parentId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string criticality = null, string accessibility = null, string nodeId = null, string assetId = null, string systemId = null, string assetStatusId = null, string permission = null, string orderBy = null);
        /// <summary>
        /// Get all nodes of one Instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of all nodes that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="hidden">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of NodesResponse</returns>
        System.Threading.Tasks.Task<NodesResponse> GetNodesOfInstrumentationAsync (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string parentId = null, string tenantId = null, bool? hidden = null, string permission = null, string orderBy = null);

        /// <summary>
        /// Get all nodes of one Instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of all nodes that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="hidden">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (NodesResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<NodesResponse>> GetNodesOfInstrumentationAsyncWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string parentId = null, string tenantId = null, bool? hidden = null, string permission = null, string orderBy = null);
        /// <summary>
        /// Get the history of one specification attribute of an instrumentation.
        /// </summary>
        /// <remarks>
        /// This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>Task of SpecificationHistoryResponse</returns>
        System.Threading.Tasks.Task<SpecificationHistoryResponse> GetSpecificationHistoryOfInstrumentationAsync (long? instrumentationId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null);

        /// <summary>
        /// Get the history of one specification attribute of an instrumentation.
        /// </summary>
        /// <remarks>
        /// This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationHistoryResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SpecificationHistoryResponse>> GetSpecificationHistoryOfInstrumentationAsyncWithHttpInfo (long? instrumentationId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null);
        /// <summary>
        /// Get existing instrumentation specification keys
        /// </summary>
        /// <remarks>
        /// Returns the existing specification keys in all readable instrumentations.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of SpecificationKeys</returns>
        System.Threading.Tasks.Task<SpecificationKeys> GetSpecificationKeysOfInstrumentationsAsync (string key = null, bool? uiVisible = null);

        /// <summary>
        /// Get existing instrumentation specification keys
        /// </summary>
        /// <remarks>
        /// Returns the existing specification keys in all readable instrumentations.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationKeys)</returns>
        System.Threading.Tasks.Task<ApiResponse<SpecificationKeys>> GetSpecificationKeysOfInstrumentationsAsyncWithHttpInfo (string key = null, bool? uiVisible = null);
        /// <summary>
        /// Get specifications of an instrumentation
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of SpecificationsUIVisibleResponse</returns>
        System.Threading.Tasks.Task<SpecificationsUIVisibleResponse> GetSpecificationsOfInstrumentationAsync (long? instrumentationId, string key = null, bool? uiVisible = null);

        /// <summary>
        /// Get specifications of an instrumentation
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationsUIVisibleResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SpecificationsUIVisibleResponse>> GetSpecificationsOfInstrumentationAsyncWithHttpInfo (long? instrumentationId, string key = null, bool? uiVisible = null);
        /// <summary>
        /// Get all systems of one instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of all systems that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;pictures, specifications, specifications[key1,key2], tenant, parent, status, type, type.tenant, type.parent &#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of SystemsResponse</returns>
        System.Threading.Tasks.Task<SystemsResponse> GetSystemsOfInstrumentationAsync (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string statusId = null, string typeId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string permission = null, string orderBy = null);

        /// <summary>
        /// Get all systems of one instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of all systems that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;pictures, specifications, specifications[key1,key2], tenant, parent, status, type, type.tenant, type.parent &#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (SystemsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SystemsResponse>> GetSystemsOfInstrumentationAsyncWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string statusId = null, string typeId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string permission = null, string orderBy = null);
        /// <summary>
        /// Remove assets from an instrumentation
        /// </summary>
        /// <remarks>
        /// Remove one or more assets from an instrumentation in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the asset.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the assets will be removed</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveAssetsFromInstrumentationAsync (AssetIDs body, long? instrumentationId);

        /// <summary>
        /// Remove assets from an instrumentation
        /// </summary>
        /// <remarks>
        /// Remove one or more assets from an instrumentation in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the asset.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the assets will be removed</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveAssetsFromInstrumentationAsyncWithHttpInfo (AssetIDs body, long? instrumentationId);
        /// <summary>
        /// Remove bill of materials from an instrumentation
        /// </summary>
        /// <remarks>
        /// Remove one or more bill of materials from an instrumentation in your accessible scope.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the bill of materials will be removed</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveBillOfMaterialsFromInstrumentationAsync (BillOfMaterialIDs body, long? instrumentationId);

        /// <summary>
        /// Remove bill of materials from an instrumentation
        /// </summary>
        /// <remarks>
        /// Remove one or more bill of materials from an instrumentation in your accessible scope.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the bill of materials will be removed</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveBillOfMaterialsFromInstrumentationAsyncWithHttpInfo (BillOfMaterialIDs body, long? instrumentationId);
        /// <summary>
        /// Remove documents from an instrumentation
        /// </summary>
        /// <remarks>
        /// Remove one or more documents from an instrumentation. This action requires &#x60;can_update&#x60; permission on the instrumentation and &#x60;can_read&#x60; permission on the document.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the documents will be removed</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveDocumentsFromInstrumentationAsync (DocumentIDs body, long? instrumentationId);

        /// <summary>
        /// Remove documents from an instrumentation
        /// </summary>
        /// <remarks>
        /// Remove one or more documents from an instrumentation. This action requires &#x60;can_update&#x60; permission on the instrumentation and &#x60;can_read&#x60; permission on the document.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the documents will be removed</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveDocumentsFromInstrumentationAsyncWithHttpInfo (DocumentIDs body, long? instrumentationId);
        /// <summary>
        /// Remove events from an instrumentation
        /// </summary>
        /// <remarks>
        /// Remove one or more events from an instrumentation in your accessible scope. If the event has no more related instrumentations, the event will be deleted
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the events will removed.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveEventFromInstrumentationAsync (Events1 body, long? instrumentationId);

        /// <summary>
        /// Remove events from an instrumentation
        /// </summary>
        /// <remarks>
        /// Remove one or more events from an instrumentation in your accessible scope. If the event has no more related instrumentations, the event will be deleted
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the events will removed.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveEventFromInstrumentationAsyncWithHttpInfo (Events1 body, long? instrumentationId);
        /// <summary>
        /// Remove nodes from an instrumentation
        /// </summary>
        /// <remarks>
        /// Remove one or more nodes from an instrumentation in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the node.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the nodes will be removed</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveNodesFromInstrumentationAsync (NodeIDs body, long? instrumentationId);

        /// <summary>
        /// Remove nodes from an instrumentation
        /// </summary>
        /// <remarks>
        /// Remove one or more nodes from an instrumentation in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the node.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the nodes will be removed</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveNodesFromInstrumentationAsyncWithHttpInfo (NodeIDs body, long? instrumentationId);
        /// <summary>
        /// Delete specifications of an instrumentation
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveSpecificationsFromInstrumentationAsync (List<string> body, long? instrumentationId);

        /// <summary>
        /// Delete specifications of an instrumentation
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveSpecificationsFromInstrumentationAsyncWithHttpInfo (List<string> body, long? instrumentationId);
        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of an instrumentation in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RenameSpecificationsOfInstrumentationAsync (SpecificationsRename body, long? instrumentationId);

        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of an instrumentation in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RenameSpecificationsOfInstrumentationAsyncWithHttpInfo (SpecificationsRename body, long? instrumentationId);
        /// <summary>
        /// Replace the assets of an instrumentation
        /// </summary>
        /// <remarks>
        /// Replaces all assets belonging to an instrumentation. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the asset.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="instrumentationId">Id of the instrumentation of which the assets will be replaced</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task ReplaceAssetsOfInstrumentationAsync (AssetIDs body, long? instrumentationId);

        /// <summary>
        /// Replace the assets of an instrumentation
        /// </summary>
        /// <remarks>
        /// Replaces all assets belonging to an instrumentation. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the asset.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="instrumentationId">Id of the instrumentation of which the assets will be replaced</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> ReplaceAssetsOfInstrumentationAsyncWithHttpInfo (AssetIDs body, long? instrumentationId);
        /// <summary>
        /// Replace the bill of materials of an instrumentation
        /// </summary>
        /// <remarks>
        /// Replaces all bill of materials belonging to an instrumentation. You can send a list of resources that will replace all previous values.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="instrumentationId">Id of the instrumentation of which the bill of materials will be replaced</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task ReplaceBillOfMaterialsOfInstrumentationAsync (BillOfMaterialIDs body, long? instrumentationId);

        /// <summary>
        /// Replace the bill of materials of an instrumentation
        /// </summary>
        /// <remarks>
        /// Replaces all bill of materials belonging to an instrumentation. You can send a list of resources that will replace all previous values.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="instrumentationId">Id of the instrumentation of which the bill of materials will be replaced</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> ReplaceBillOfMaterialsOfInstrumentationAsyncWithHttpInfo (BillOfMaterialIDs body, long? instrumentationId);
        /// <summary>
        /// Replace the documents of an instrumentation
        /// </summary>
        /// <remarks>
        /// Replaces all documents belonging to an instrumentation. You can send a list of resources that will replace all previous values. This action requires &#x60;can_udpate&#x60; permission on the instrumentation and &#x60;can_read&#x60; permission on the document.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="instrumentationId">Id of the instrumentation of which the documents will be replaced</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task ReplaceDocumentsOfInstrumentationAsync (DocumentIDs body, long? instrumentationId);

        /// <summary>
        /// Replace the documents of an instrumentation
        /// </summary>
        /// <remarks>
        /// Replaces all documents belonging to an instrumentation. You can send a list of resources that will replace all previous values. This action requires &#x60;can_udpate&#x60; permission on the instrumentation and &#x60;can_read&#x60; permission on the document.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="instrumentationId">Id of the instrumentation of which the documents will be replaced</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> ReplaceDocumentsOfInstrumentationAsyncWithHttpInfo (DocumentIDs body, long? instrumentationId);
        /// <summary>
        /// Replace the nodes of an instrumentation
        /// </summary>
        /// <remarks>
        /// Replaces all nodes belonging to an instrumentation in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the node.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="instrumentationId">Id of the instrumentation of which the nodes will be replaced</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task ReplaceNodesOfInstrumentationAsync (NodeIDs body, long? instrumentationId);

        /// <summary>
        /// Replace the nodes of an instrumentation
        /// </summary>
        /// <remarks>
        /// Replaces all nodes belonging to an instrumentation in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the node.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="instrumentationId">Id of the instrumentation of which the nodes will be replaced</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> ReplaceNodesOfInstrumentationAsyncWithHttpInfo (NodeIDs body, long? instrumentationId);
        /// <summary>
        /// Update an instrumentation
        /// </summary>
        /// <remarks>
        /// Update accessible parameters of the requested resource in your accessible scope. To assign a parent instrumentation the user needs &#x60;can_permit&#x60; permission on the parent and on the current instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the instrumentation to update</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UpdateInstrumentationAsync (InstrumentationRequest body, long? id);

        /// <summary>
        /// Update an instrumentation
        /// </summary>
        /// <remarks>
        /// Update accessible parameters of the requested resource in your accessible scope. To assign a parent instrumentation the user needs &#x60;can_permit&#x60; permission on the parent and on the current instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the instrumentation to update</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UpdateInstrumentationAsyncWithHttpInfo (InstrumentationRequest body, long? id);
        /// <summary>
        /// Update an instrumentation picture
        /// </summary>
        /// <remarks>
        /// Upload a new instrumentation picture. Check the file-storage quota. Allowed content-types are - image/gif - image/jpg - image/jpeg - image/png
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="image"></param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>Task of PictureResponse</returns>
        System.Threading.Tasks.Task<PictureResponse> UpdateInstrumentationPictureAsync (byte[] image, long? instrumentationId, long? id);

        /// <summary>
        /// Update an instrumentation picture
        /// </summary>
        /// <remarks>
        /// Upload a new instrumentation picture. Check the file-storage quota. Allowed content-types are - image/gif - image/jpg - image/jpeg - image/png
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="image"></param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>Task of ApiResponse (PictureResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<PictureResponse>> UpdateInstrumentationPictureAsyncWithHttpInfo (byte[] image, long? instrumentationId, long? id);
        /// <summary>
        /// Update an instrumentation picture link
        /// </summary>
        /// <remarks>
        /// Update an instrumentation picture link.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Picture link object to be updated</param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>Task of PictureResponse</returns>
        System.Threading.Tasks.Task<PictureResponse> UpdateInstrumentationPictureLinkAsync (PictureLinkRequest body, long? instrumentationId, long? id);

        /// <summary>
        /// Update an instrumentation picture link
        /// </summary>
        /// <remarks>
        /// Update an instrumentation picture link.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Picture link object to be updated</param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>Task of ApiResponse (PictureResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<PictureResponse>> UpdateInstrumentationPictureLinkAsyncWithHttpInfo (PictureLinkRequest body, long? instrumentationId, long? id);
        /// <summary>
        /// Update an instrumentation threshold
        /// </summary>
        /// <remarks>
        /// Replaces the threshold belonging to an instrumentation. This action requires &#x60;can_update&#x60; permission on the instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object body that will be updated.</param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation threshold</param>
        /// <returns>Task of ThresholdResponse</returns>
        System.Threading.Tasks.Task<ThresholdResponse> UpdateInstrumentationThresholdAsync (ThresholdRequest body, long? instrumentationId, long? id);

        /// <summary>
        /// Update an instrumentation threshold
        /// </summary>
        /// <remarks>
        /// Replaces the threshold belonging to an instrumentation. This action requires &#x60;can_update&#x60; permission on the instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object body that will be updated.</param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation threshold</param>
        /// <returns>Task of ApiResponse (ThresholdResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<ThresholdResponse>> UpdateInstrumentationThresholdAsyncWithHttpInfo (ThresholdRequest body, long? instrumentationId, long? id);
        /// <summary>
        /// Update specifications of an instrumentation
        /// </summary>
        /// <remarks>
        /// Update the specification object of an instrumentation in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UpdateSpecificationsOfInstrumentationAsync (Dictionary<string, SpecificationUIVisibleRequest> body, long? instrumentationId);

        /// <summary>
        /// Update specifications of an instrumentation
        /// </summary>
        /// <remarks>
        /// Update the specification object of an instrumentation in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSpecificationsOfInstrumentationAsyncWithHttpInfo (Dictionary<string, SpecificationUIVisibleRequest> body, long? instrumentationId);
        /// <summary>
        /// Upload an instrumentation picture
        /// </summary>
        /// <remarks>
        /// Upload a new instrumentation picture. Checks the file-storage quota. Allowed content-types are - image/gif - image/jpg - image/jpeg - image/png
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="image"></param>
        /// <param name="id">Id of the instrumentation</param>
        /// <returns>Task of PictureResponse</returns>
        System.Threading.Tasks.Task<PictureResponse> UploadInstrumentationPictureAsync (byte[] image, long? id);

        /// <summary>
        /// Upload an instrumentation picture
        /// </summary>
        /// <remarks>
        /// Upload a new instrumentation picture. Checks the file-storage quota. Allowed content-types are - image/gif - image/jpg - image/jpeg - image/png
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="image"></param>
        /// <param name="id">Id of the instrumentation</param>
        /// <returns>Task of ApiResponse (PictureResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<PictureResponse>> UploadInstrumentationPictureAsyncWithHttpInfo (byte[] image, long? id);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
        public partial class InstrumentationApi : IInstrumentationApi
    {
        private Netilion.Api.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="InstrumentationApi"/> class.
        /// </summary>
        /// <returns></returns>
        public InstrumentationApi(String basePath)
        {
            this.Configuration = new Netilion.Api.Client.Configuration { BasePath = basePath };

            ExceptionFactory = Netilion.Api.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="InstrumentationApi"/> class
        /// </summary>
        /// <returns></returns>
        public InstrumentationApi()
        {
            this.Configuration = Netilion.Api.Client.Configuration.Default;

            ExceptionFactory = Netilion.Api.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="InstrumentationApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public InstrumentationApi(Netilion.Api.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = Netilion.Api.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = Netilion.Api.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Netilion.Api.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Netilion.Api.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Add assets to an instrumentation Add one or more assets to an instrumentation. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the asset.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="instrumentationId">Id of the instrumentation to which the assets will be added</param>
        /// <returns></returns>
        public void AddAssetsToInstrumentation (AssetIDs body, long? instrumentationId)
        {
             AddAssetsToInstrumentationWithHttpInfo(body, instrumentationId);
        }

        /// <summary>
        /// Add assets to an instrumentation Add one or more assets to an instrumentation. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the asset.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="instrumentationId">Id of the instrumentation to which the assets will be added</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> AddAssetsToInstrumentationWithHttpInfo (AssetIDs body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->AddAssetsToInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->AddAssetsToInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/assets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddAssetsToInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Add assets to an instrumentation Add one or more assets to an instrumentation. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the asset.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="instrumentationId">Id of the instrumentation to which the assets will be added</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task AddAssetsToInstrumentationAsync (AssetIDs body, long? instrumentationId)
        {
             await AddAssetsToInstrumentationAsyncWithHttpInfo(body, instrumentationId);

        }

        /// <summary>
        /// Add assets to an instrumentation Add one or more assets to an instrumentation. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the asset.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="instrumentationId">Id of the instrumentation to which the assets will be added</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> AddAssetsToInstrumentationAsyncWithHttpInfo (AssetIDs body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->AddAssetsToInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->AddAssetsToInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/assets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddAssetsToInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Add bill of materials to an instrumentation Add one or more bill of materials to an instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="instrumentationId">Id of the instrumentation to which the bill of materials will be added</param>
        /// <returns></returns>
        public void AddBillOfMaterialsToInstrumentation (BillOfMaterialIDs body, long? instrumentationId)
        {
             AddBillOfMaterialsToInstrumentationWithHttpInfo(body, instrumentationId);
        }

        /// <summary>
        /// Add bill of materials to an instrumentation Add one or more bill of materials to an instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="instrumentationId">Id of the instrumentation to which the bill of materials will be added</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> AddBillOfMaterialsToInstrumentationWithHttpInfo (BillOfMaterialIDs body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->AddBillOfMaterialsToInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->AddBillOfMaterialsToInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/bill_of_materials";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddBillOfMaterialsToInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Add bill of materials to an instrumentation Add one or more bill of materials to an instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="instrumentationId">Id of the instrumentation to which the bill of materials will be added</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task AddBillOfMaterialsToInstrumentationAsync (BillOfMaterialIDs body, long? instrumentationId)
        {
             await AddBillOfMaterialsToInstrumentationAsyncWithHttpInfo(body, instrumentationId);

        }

        /// <summary>
        /// Add bill of materials to an instrumentation Add one or more bill of materials to an instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="instrumentationId">Id of the instrumentation to which the bill of materials will be added</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> AddBillOfMaterialsToInstrumentationAsyncWithHttpInfo (BillOfMaterialIDs body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->AddBillOfMaterialsToInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->AddBillOfMaterialsToInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/bill_of_materials";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddBillOfMaterialsToInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Add documents to an instrumentation Add one or more documents to an instrumentation. This action requires &#x60;can_update&#x60; permission on the instrumentation and &#x60;can_read&#x60; permission on the document.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="instrumentationId">Id of the instrumentation to which the documents will be added</param>
        /// <returns></returns>
        public void AddDocumentsToInstrumentation (DocumentIDs body, long? instrumentationId)
        {
             AddDocumentsToInstrumentationWithHttpInfo(body, instrumentationId);
        }

        /// <summary>
        /// Add documents to an instrumentation Add one or more documents to an instrumentation. This action requires &#x60;can_update&#x60; permission on the instrumentation and &#x60;can_read&#x60; permission on the document.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="instrumentationId">Id of the instrumentation to which the documents will be added</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> AddDocumentsToInstrumentationWithHttpInfo (DocumentIDs body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->AddDocumentsToInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->AddDocumentsToInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/documents";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddDocumentsToInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Add documents to an instrumentation Add one or more documents to an instrumentation. This action requires &#x60;can_update&#x60; permission on the instrumentation and &#x60;can_read&#x60; permission on the document.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="instrumentationId">Id of the instrumentation to which the documents will be added</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task AddDocumentsToInstrumentationAsync (DocumentIDs body, long? instrumentationId)
        {
             await AddDocumentsToInstrumentationAsyncWithHttpInfo(body, instrumentationId);

        }

        /// <summary>
        /// Add documents to an instrumentation Add one or more documents to an instrumentation. This action requires &#x60;can_update&#x60; permission on the instrumentation and &#x60;can_read&#x60; permission on the document.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="instrumentationId">Id of the instrumentation to which the documents will be added</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> AddDocumentsToInstrumentationAsyncWithHttpInfo (DocumentIDs body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->AddDocumentsToInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->AddDocumentsToInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/documents";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddDocumentsToInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Add a link as instrumentation picture Add an external resource as instrumentation picture.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Picture link object to be created</param>
        /// <param name="id">Id of the instrumentation</param>
        /// <returns>PictureResponse</returns>
        public PictureResponse AddInstrumentationPictureLink (PictureLinkRequest body, long? id)
        {
             ApiResponse<PictureResponse> localVarResponse = AddInstrumentationPictureLinkWithHttpInfo(body, id);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Add a link as instrumentation picture Add an external resource as instrumentation picture.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Picture link object to be created</param>
        /// <param name="id">Id of the instrumentation</param>
        /// <returns>ApiResponse of PictureResponse</returns>
        public ApiResponse< PictureResponse > AddInstrumentationPictureLinkWithHttpInfo (PictureLinkRequest body, long? id)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->AddInstrumentationPictureLink");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling InstrumentationApi->AddInstrumentationPictureLink");

            var localVarPath = "/instrumentations/{id}/pictures/links";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddInstrumentationPictureLink", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PictureResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (PictureResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(PictureResponse)));
        }

        /// <summary>
        /// Add a link as instrumentation picture Add an external resource as instrumentation picture.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Picture link object to be created</param>
        /// <param name="id">Id of the instrumentation</param>
        /// <returns>Task of PictureResponse</returns>
        public async System.Threading.Tasks.Task<PictureResponse> AddInstrumentationPictureLinkAsync (PictureLinkRequest body, long? id)
        {
             ApiResponse<PictureResponse> localVarResponse = await AddInstrumentationPictureLinkAsyncWithHttpInfo(body, id);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Add a link as instrumentation picture Add an external resource as instrumentation picture.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Picture link object to be created</param>
        /// <param name="id">Id of the instrumentation</param>
        /// <returns>Task of ApiResponse (PictureResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<PictureResponse>> AddInstrumentationPictureLinkAsyncWithHttpInfo (PictureLinkRequest body, long? id)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->AddInstrumentationPictureLink");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling InstrumentationApi->AddInstrumentationPictureLink");

            var localVarPath = "/instrumentations/{id}/pictures/links";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddInstrumentationPictureLink", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PictureResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (PictureResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(PictureResponse)));
        }

        /// <summary>
        /// Add nodes to an instrumentation Add one or more nodes to an instrumentation in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the node.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="instrumentationId">Id of the instrumentation to which the nodes will be added</param>
        /// <returns></returns>
        public void AddNodesToInstrumentation (NodeIDs body, long? instrumentationId)
        {
             AddNodesToInstrumentationWithHttpInfo(body, instrumentationId);
        }

        /// <summary>
        /// Add nodes to an instrumentation Add one or more nodes to an instrumentation in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the node.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="instrumentationId">Id of the instrumentation to which the nodes will be added</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> AddNodesToInstrumentationWithHttpInfo (NodeIDs body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->AddNodesToInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->AddNodesToInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/nodes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddNodesToInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Add nodes to an instrumentation Add one or more nodes to an instrumentation in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the node.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="instrumentationId">Id of the instrumentation to which the nodes will be added</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task AddNodesToInstrumentationAsync (NodeIDs body, long? instrumentationId)
        {
             await AddNodesToInstrumentationAsyncWithHttpInfo(body, instrumentationId);

        }

        /// <summary>
        /// Add nodes to an instrumentation Add one or more nodes to an instrumentation in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the node.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="instrumentationId">Id of the instrumentation to which the nodes will be added</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> AddNodesToInstrumentationAsyncWithHttpInfo (NodeIDs body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->AddNodesToInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->AddNodesToInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/nodes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddNodesToInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Create a new event for an instrumentation Events must have a name, and can have a start_datetime (if not provided, the date of creation will be used as default value), end_datetime, event_type, event_status, description and responsible
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object to be created.</param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <returns>EventResponse</returns>
        public EventResponse CreateEventForInstrumentation (EventRequestNoInstrumentations body, long? instrumentationId)
        {
             ApiResponse<EventResponse> localVarResponse = CreateEventForInstrumentationWithHttpInfo(body, instrumentationId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Create a new event for an instrumentation Events must have a name, and can have a start_datetime (if not provided, the date of creation will be used as default value), end_datetime, event_type, event_status, description and responsible
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object to be created.</param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <returns>ApiResponse of EventResponse</returns>
        public ApiResponse< EventResponse > CreateEventForInstrumentationWithHttpInfo (EventRequestNoInstrumentations body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->CreateEventForInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->CreateEventForInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/events";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateEventForInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<EventResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (EventResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(EventResponse)));
        }

        /// <summary>
        /// Create a new event for an instrumentation Events must have a name, and can have a start_datetime (if not provided, the date of creation will be used as default value), end_datetime, event_type, event_status, description and responsible
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object to be created.</param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <returns>Task of EventResponse</returns>
        public async System.Threading.Tasks.Task<EventResponse> CreateEventForInstrumentationAsync (EventRequestNoInstrumentations body, long? instrumentationId)
        {
             ApiResponse<EventResponse> localVarResponse = await CreateEventForInstrumentationAsyncWithHttpInfo(body, instrumentationId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Create a new event for an instrumentation Events must have a name, and can have a start_datetime (if not provided, the date of creation will be used as default value), end_datetime, event_type, event_status, description and responsible
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object to be created.</param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <returns>Task of ApiResponse (EventResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<EventResponse>> CreateEventForInstrumentationAsyncWithHttpInfo (EventRequestNoInstrumentations body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->CreateEventForInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->CreateEventForInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/events";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateEventForInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<EventResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (EventResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(EventResponse)));
        }

        /// <summary>
        /// Create a new instrumentation Create a new instrumentation. The tag of the given instrumentation needs to be unique within its parent. The instrumentation will not be created when this constraint is violated.  To assign a parent instrumentation the user needs &#x60;can_permit&#x60; permission on the parent.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Instrumentation object that needs to be created. tag, instrumentation status and instrumentation type are required</param>
        /// <returns>InstrumentationResponse</returns>
        public InstrumentationResponse CreateInstrumentation (InstrumentationRequest body)
        {
             ApiResponse<InstrumentationResponse> localVarResponse = CreateInstrumentationWithHttpInfo(body);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Create a new instrumentation Create a new instrumentation. The tag of the given instrumentation needs to be unique within its parent. The instrumentation will not be created when this constraint is violated.  To assign a parent instrumentation the user needs &#x60;can_permit&#x60; permission on the parent.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Instrumentation object that needs to be created. tag, instrumentation status and instrumentation type are required</param>
        /// <returns>ApiResponse of InstrumentationResponse</returns>
        public ApiResponse< InstrumentationResponse > CreateInstrumentationWithHttpInfo (InstrumentationRequest body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->CreateInstrumentation");

            var localVarPath = "/instrumentations";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InstrumentationResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InstrumentationResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InstrumentationResponse)));
        }

        /// <summary>
        /// Create a new instrumentation Create a new instrumentation. The tag of the given instrumentation needs to be unique within its parent. The instrumentation will not be created when this constraint is violated.  To assign a parent instrumentation the user needs &#x60;can_permit&#x60; permission on the parent.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Instrumentation object that needs to be created. tag, instrumentation status and instrumentation type are required</param>
        /// <returns>Task of InstrumentationResponse</returns>
        public async System.Threading.Tasks.Task<InstrumentationResponse> CreateInstrumentationAsync (InstrumentationRequest body)
        {
             ApiResponse<InstrumentationResponse> localVarResponse = await CreateInstrumentationAsyncWithHttpInfo(body);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Create a new instrumentation Create a new instrumentation. The tag of the given instrumentation needs to be unique within its parent. The instrumentation will not be created when this constraint is violated.  To assign a parent instrumentation the user needs &#x60;can_permit&#x60; permission on the parent.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Instrumentation object that needs to be created. tag, instrumentation status and instrumentation type are required</param>
        /// <returns>Task of ApiResponse (InstrumentationResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InstrumentationResponse>> CreateInstrumentationAsyncWithHttpInfo (InstrumentationRequest body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->CreateInstrumentation");

            var localVarPath = "/instrumentations";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InstrumentationResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InstrumentationResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InstrumentationResponse)));
        }

        /// <summary>
        /// Create an instrumentation threshold Create a new instrumentation threshold. This action requires &#x60;&#x60;&#x60;can_udpate&#x60;&#x60;&#x60; permission on the instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object body that will be created.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>ThresholdResponse</returns>
        public ThresholdResponse CreateInstrumentationThreshold (ThresholdRequest body, long? instrumentationId)
        {
             ApiResponse<ThresholdResponse> localVarResponse = CreateInstrumentationThresholdWithHttpInfo(body, instrumentationId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Create an instrumentation threshold Create a new instrumentation threshold. This action requires &#x60;&#x60;&#x60;can_udpate&#x60;&#x60;&#x60; permission on the instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object body that will be created.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>ApiResponse of ThresholdResponse</returns>
        public ApiResponse< ThresholdResponse > CreateInstrumentationThresholdWithHttpInfo (ThresholdRequest body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->CreateInstrumentationThreshold");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->CreateInstrumentationThreshold");

            var localVarPath = "/instrumentations/{instrumentation_id}/thresholds";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateInstrumentationThreshold", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ThresholdResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (ThresholdResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ThresholdResponse)));
        }

        /// <summary>
        /// Create an instrumentation threshold Create a new instrumentation threshold. This action requires &#x60;&#x60;&#x60;can_udpate&#x60;&#x60;&#x60; permission on the instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object body that will be created.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>Task of ThresholdResponse</returns>
        public async System.Threading.Tasks.Task<ThresholdResponse> CreateInstrumentationThresholdAsync (ThresholdRequest body, long? instrumentationId)
        {
             ApiResponse<ThresholdResponse> localVarResponse = await CreateInstrumentationThresholdAsyncWithHttpInfo(body, instrumentationId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Create an instrumentation threshold Create a new instrumentation threshold. This action requires &#x60;&#x60;&#x60;can_udpate&#x60;&#x60;&#x60; permission on the instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object body that will be created.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>Task of ApiResponse (ThresholdResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ThresholdResponse>> CreateInstrumentationThresholdAsyncWithHttpInfo (ThresholdRequest body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->CreateInstrumentationThreshold");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->CreateInstrumentationThreshold");

            var localVarPath = "/instrumentations/{instrumentation_id}/thresholds";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateInstrumentationThreshold", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ThresholdResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (ThresholdResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ThresholdResponse)));
        }

        /// <summary>
        /// Delete an instrumentation Delete a specific resource in your accessible scope, identified by the id in the URL.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the instrumentation to delete</param>
        /// <returns></returns>
        public void DeleteInstrumentation (long? id)
        {
             DeleteInstrumentationWithHttpInfo(id);
        }

        /// <summary>
        /// Delete an instrumentation Delete a specific resource in your accessible scope, identified by the id in the URL.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the instrumentation to delete</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteInstrumentationWithHttpInfo (long? id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling InstrumentationApi->DeleteInstrumentation");

            var localVarPath = "/instrumentations/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete an instrumentation Delete a specific resource in your accessible scope, identified by the id in the URL.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the instrumentation to delete</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteInstrumentationAsync (long? id)
        {
             await DeleteInstrumentationAsyncWithHttpInfo(id);

        }

        /// <summary>
        /// Delete an instrumentation Delete a specific resource in your accessible scope, identified by the id in the URL.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the instrumentation to delete</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> DeleteInstrumentationAsyncWithHttpInfo (long? id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling InstrumentationApi->DeleteInstrumentation");

            var localVarPath = "/instrumentations/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete an instrumentation picture Delete an instrumentation picture.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns></returns>
        public void DeleteInstrumentationPicture (long? instrumentationId, long? id)
        {
             DeleteInstrumentationPictureWithHttpInfo(instrumentationId, id);
        }

        /// <summary>
        /// Delete an instrumentation picture Delete an instrumentation picture.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteInstrumentationPictureWithHttpInfo (long? instrumentationId, long? id)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->DeleteInstrumentationPicture");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling InstrumentationApi->DeleteInstrumentationPicture");

            var localVarPath = "/instrumentations/{instrumentation_id}/pictures/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteInstrumentationPicture", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete an instrumentation picture Delete an instrumentation picture.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteInstrumentationPictureAsync (long? instrumentationId, long? id)
        {
             await DeleteInstrumentationPictureAsyncWithHttpInfo(instrumentationId, id);

        }

        /// <summary>
        /// Delete an instrumentation picture Delete an instrumentation picture.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> DeleteInstrumentationPictureAsyncWithHttpInfo (long? instrumentationId, long? id)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->DeleteInstrumentationPicture");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling InstrumentationApi->DeleteInstrumentationPicture");

            var localVarPath = "/instrumentations/{instrumentation_id}/pictures/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteInstrumentationPicture", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete an instrumentation threshold. Delete an instrumentation threshold.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation threshold</param>
        /// <returns></returns>
        public void DeleteInstrumentationThreshold (long? instrumentationId, long? id)
        {
             DeleteInstrumentationThresholdWithHttpInfo(instrumentationId, id);
        }

        /// <summary>
        /// Delete an instrumentation threshold. Delete an instrumentation threshold.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation threshold</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteInstrumentationThresholdWithHttpInfo (long? instrumentationId, long? id)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->DeleteInstrumentationThreshold");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling InstrumentationApi->DeleteInstrumentationThreshold");

            var localVarPath = "/instrumentations/{instrumentation_id}/thresholds/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteInstrumentationThreshold", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete an instrumentation threshold. Delete an instrumentation threshold.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation threshold</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteInstrumentationThresholdAsync (long? instrumentationId, long? id)
        {
             await DeleteInstrumentationThresholdAsyncWithHttpInfo(instrumentationId, id);

        }

        /// <summary>
        /// Delete an instrumentation threshold. Delete an instrumentation threshold.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation threshold</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> DeleteInstrumentationThresholdAsyncWithHttpInfo (long? instrumentationId, long? id)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->DeleteInstrumentationThreshold");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling InstrumentationApi->DeleteInstrumentationThreshold");

            var localVarPath = "/instrumentations/{instrumentation_id}/thresholds/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteInstrumentationThreshold", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Download an instrumentation picture Download an instrumentation picture.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns></returns>
        public void DownloadInstrumentationPicture (long? instrumentationId, long? id)
        {
             DownloadInstrumentationPictureWithHttpInfo(instrumentationId, id);
        }

        /// <summary>
        /// Download an instrumentation picture Download an instrumentation picture.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DownloadInstrumentationPictureWithHttpInfo (long? instrumentationId, long? id)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->DownloadInstrumentationPicture");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling InstrumentationApi->DownloadInstrumentationPicture");

            var localVarPath = "/instrumentations/{instrumentation_id}/pictures/{id}/download";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DownloadInstrumentationPicture", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Download an instrumentation picture Download an instrumentation picture.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DownloadInstrumentationPictureAsync (long? instrumentationId, long? id)
        {
             await DownloadInstrumentationPictureAsyncWithHttpInfo(instrumentationId, id);

        }

        /// <summary>
        /// Download an instrumentation picture Download an instrumentation picture.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> DownloadInstrumentationPictureAsyncWithHttpInfo (long? instrumentationId, long? id)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->DownloadInstrumentationPicture");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling InstrumentationApi->DownloadInstrumentationPicture");

            var localVarPath = "/instrumentations/{instrumentation_id}/pictures/{id}/download";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DownloadInstrumentationPicture", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Get all assets of one instrumentation Returns a list of all assets that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;status, tenant, parent, pictures, product, product.manufacturer, product.pictures, product.status, product.categories, product.categories.parent, specifications, specifications[key1,key2], product.tenant,                             product.manufacturer.tenant, status.tenant, instrumentations &#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="serialNumber">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productCategoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="manufacturerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusCode">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productionDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="nodeId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all objects with no nodes assigned or \&quot;!null\&quot; for any assigned node (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="ownershipClaimed">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;serial_number&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, &#x60;last_seen_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>AssetsResponse</returns>
        public AssetsResponse GetAssetsOfInstrumentation (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string serialNumber = null, string productId = null, string productCategoryId = null, string parentId = null, string manufacturerId = null, string statusId = null, string statusCode = null, string tenantId = null, DateTime? productionDate = null, DateTime? productionDateFrom = null, DateTime? productionDateTo = null, string specificationsKey = null, string specificationsValue = null, string nodeId = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, bool? ownershipClaimed = null, string permission = null, string orderBy = null)
        {
             ApiResponse<AssetsResponse> localVarResponse = GetAssetsOfInstrumentationWithHttpInfo(instrumentationId, page, perPage, include, serialNumber, productId, productCategoryId, parentId, manufacturerId, statusId, statusCode, tenantId, productionDate, productionDateFrom, productionDateTo, specificationsKey, specificationsValue, nodeId, createdAt, createdAtFrom, createdAtTo, updatedAt, updatedAtFrom, updatedAtTo, ownershipClaimed, permission, orderBy);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get all assets of one instrumentation Returns a list of all assets that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;status, tenant, parent, pictures, product, product.manufacturer, product.pictures, product.status, product.categories, product.categories.parent, specifications, specifications[key1,key2], product.tenant,                             product.manufacturer.tenant, status.tenant, instrumentations &#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="serialNumber">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productCategoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="manufacturerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusCode">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productionDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="nodeId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all objects with no nodes assigned or \&quot;!null\&quot; for any assigned node (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="ownershipClaimed">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;serial_number&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, &#x60;last_seen_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of AssetsResponse</returns>
        public ApiResponse< AssetsResponse > GetAssetsOfInstrumentationWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string serialNumber = null, string productId = null, string productCategoryId = null, string parentId = null, string manufacturerId = null, string statusId = null, string statusCode = null, string tenantId = null, DateTime? productionDate = null, DateTime? productionDateFrom = null, DateTime? productionDateTo = null, string specificationsKey = null, string specificationsValue = null, string nodeId = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, bool? ownershipClaimed = null, string permission = null, string orderBy = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetAssetsOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/assets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (serialNumber != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "serial_number", serialNumber)); // query parameter
            if (productId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "product_id", productId)); // query parameter
            if (productCategoryId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "product_category_id", productCategoryId)); // query parameter
            if (parentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "parent_id", parentId)); // query parameter
            if (manufacturerId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "manufacturer_id", manufacturerId)); // query parameter
            if (statusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_id", statusId)); // query parameter
            if (statusCode != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_code", statusCode)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (productionDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "production_date", productionDate)); // query parameter
            if (productionDateFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "production_date_from", productionDateFrom)); // query parameter
            if (productionDateTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "production_date_to", productionDateTo)); // query parameter
            if (specificationsKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_key", specificationsKey)); // query parameter
            if (specificationsValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_value", specificationsValue)); // query parameter
            if (nodeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "node_id", nodeId)); // query parameter
            if (createdAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "created_at", createdAt)); // query parameter
            if (createdAtFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "created_at_from", createdAtFrom)); // query parameter
            if (createdAtTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "created_at_to", createdAtTo)); // query parameter
            if (updatedAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at", updatedAt)); // query parameter
            if (updatedAtFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_from", updatedAtFrom)); // query parameter
            if (updatedAtTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_to", updatedAtTo)); // query parameter
            if (ownershipClaimed != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ownership_claimed", ownershipClaimed)); // query parameter
            if (permission != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "permission", permission)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetAssetsOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AssetsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (AssetsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AssetsResponse)));
        }

        /// <summary>
        /// Get all assets of one instrumentation Returns a list of all assets that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;status, tenant, parent, pictures, product, product.manufacturer, product.pictures, product.status, product.categories, product.categories.parent, specifications, specifications[key1,key2], product.tenant,                             product.manufacturer.tenant, status.tenant, instrumentations &#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="serialNumber">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productCategoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="manufacturerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusCode">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productionDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="nodeId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all objects with no nodes assigned or \&quot;!null\&quot; for any assigned node (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="ownershipClaimed">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;serial_number&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, &#x60;last_seen_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of AssetsResponse</returns>
        public async System.Threading.Tasks.Task<AssetsResponse> GetAssetsOfInstrumentationAsync (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string serialNumber = null, string productId = null, string productCategoryId = null, string parentId = null, string manufacturerId = null, string statusId = null, string statusCode = null, string tenantId = null, DateTime? productionDate = null, DateTime? productionDateFrom = null, DateTime? productionDateTo = null, string specificationsKey = null, string specificationsValue = null, string nodeId = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, bool? ownershipClaimed = null, string permission = null, string orderBy = null)
        {
             ApiResponse<AssetsResponse> localVarResponse = await GetAssetsOfInstrumentationAsyncWithHttpInfo(instrumentationId, page, perPage, include, serialNumber, productId, productCategoryId, parentId, manufacturerId, statusId, statusCode, tenantId, productionDate, productionDateFrom, productionDateTo, specificationsKey, specificationsValue, nodeId, createdAt, createdAtFrom, createdAtTo, updatedAt, updatedAtFrom, updatedAtTo, ownershipClaimed, permission, orderBy);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get all assets of one instrumentation Returns a list of all assets that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;status, tenant, parent, pictures, product, product.manufacturer, product.pictures, product.status, product.categories, product.categories.parent, specifications, specifications[key1,key2], product.tenant,                             product.manufacturer.tenant, status.tenant, instrumentations &#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="serialNumber">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productCategoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="manufacturerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusCode">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productionDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="nodeId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all objects with no nodes assigned or \&quot;!null\&quot; for any assigned node (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="ownershipClaimed">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;serial_number&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, &#x60;last_seen_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (AssetsResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<AssetsResponse>> GetAssetsOfInstrumentationAsyncWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string serialNumber = null, string productId = null, string productCategoryId = null, string parentId = null, string manufacturerId = null, string statusId = null, string statusCode = null, string tenantId = null, DateTime? productionDate = null, DateTime? productionDateFrom = null, DateTime? productionDateTo = null, string specificationsKey = null, string specificationsValue = null, string nodeId = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, bool? ownershipClaimed = null, string permission = null, string orderBy = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetAssetsOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/assets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (serialNumber != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "serial_number", serialNumber)); // query parameter
            if (productId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "product_id", productId)); // query parameter
            if (productCategoryId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "product_category_id", productCategoryId)); // query parameter
            if (parentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "parent_id", parentId)); // query parameter
            if (manufacturerId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "manufacturer_id", manufacturerId)); // query parameter
            if (statusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_id", statusId)); // query parameter
            if (statusCode != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_code", statusCode)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (productionDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "production_date", productionDate)); // query parameter
            if (productionDateFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "production_date_from", productionDateFrom)); // query parameter
            if (productionDateTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "production_date_to", productionDateTo)); // query parameter
            if (specificationsKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_key", specificationsKey)); // query parameter
            if (specificationsValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_value", specificationsValue)); // query parameter
            if (nodeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "node_id", nodeId)); // query parameter
            if (createdAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "created_at", createdAt)); // query parameter
            if (createdAtFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "created_at_from", createdAtFrom)); // query parameter
            if (createdAtTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "created_at_to", createdAtTo)); // query parameter
            if (updatedAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at", updatedAt)); // query parameter
            if (updatedAtFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_from", updatedAtFrom)); // query parameter
            if (updatedAtTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_to", updatedAtTo)); // query parameter
            if (ownershipClaimed != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ownership_claimed", ownershipClaimed)); // query parameter
            if (permission != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "permission", permission)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetAssetsOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AssetsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (AssetsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AssetsResponse)));
        }

        /// <summary>
        /// Get all assets an instrumentation was assigned to Returns a list of all assets history available in your scope which have been assigned to the specified instrumentation. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="assetId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="_event">Filter accepts &#x60;create&#x60; or &#x60;destroy&#x60; (optional)</param>
        /// <param name="eventDatetimeFrom">Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="eventDatetimeTo">Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;event&#x60; or &#x60;event_datetime&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>InstrumentationAssetsHistoryResponse</returns>
        public InstrumentationAssetsHistoryResponse GetAssetsOfInstrumentationHistory (long? instrumentationId, int? page = null, int? perPage = null, string assetId = null, string _event = null, DateTime? eventDatetimeFrom = null, DateTime? eventDatetimeTo = null, string orderBy = null)
        {
             ApiResponse<InstrumentationAssetsHistoryResponse> localVarResponse = GetAssetsOfInstrumentationHistoryWithHttpInfo(instrumentationId, page, perPage, assetId, _event, eventDatetimeFrom, eventDatetimeTo, orderBy);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get all assets an instrumentation was assigned to Returns a list of all assets history available in your scope which have been assigned to the specified instrumentation. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="assetId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="_event">Filter accepts &#x60;create&#x60; or &#x60;destroy&#x60; (optional)</param>
        /// <param name="eventDatetimeFrom">Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="eventDatetimeTo">Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;event&#x60; or &#x60;event_datetime&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>ApiResponse of InstrumentationAssetsHistoryResponse</returns>
        public ApiResponse< InstrumentationAssetsHistoryResponse > GetAssetsOfInstrumentationHistoryWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string assetId = null, string _event = null, DateTime? eventDatetimeFrom = null, DateTime? eventDatetimeTo = null, string orderBy = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetAssetsOfInstrumentationHistory");

            var localVarPath = "/instrumentations/{instrumentation_id}/assets/history";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (assetId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asset_id", assetId)); // query parameter
            if (_event != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "event", _event)); // query parameter
            if (eventDatetimeFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "event_datetime_from", eventDatetimeFrom)); // query parameter
            if (eventDatetimeTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "event_datetime_to", eventDatetimeTo)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetAssetsOfInstrumentationHistory", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InstrumentationAssetsHistoryResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InstrumentationAssetsHistoryResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InstrumentationAssetsHistoryResponse)));
        }

        /// <summary>
        /// Get all assets an instrumentation was assigned to Returns a list of all assets history available in your scope which have been assigned to the specified instrumentation. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="assetId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="_event">Filter accepts &#x60;create&#x60; or &#x60;destroy&#x60; (optional)</param>
        /// <param name="eventDatetimeFrom">Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="eventDatetimeTo">Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;event&#x60; or &#x60;event_datetime&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>Task of InstrumentationAssetsHistoryResponse</returns>
        public async System.Threading.Tasks.Task<InstrumentationAssetsHistoryResponse> GetAssetsOfInstrumentationHistoryAsync (long? instrumentationId, int? page = null, int? perPage = null, string assetId = null, string _event = null, DateTime? eventDatetimeFrom = null, DateTime? eventDatetimeTo = null, string orderBy = null)
        {
             ApiResponse<InstrumentationAssetsHistoryResponse> localVarResponse = await GetAssetsOfInstrumentationHistoryAsyncWithHttpInfo(instrumentationId, page, perPage, assetId, _event, eventDatetimeFrom, eventDatetimeTo, orderBy);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get all assets an instrumentation was assigned to Returns a list of all assets history available in your scope which have been assigned to the specified instrumentation. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="assetId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="_event">Filter accepts &#x60;create&#x60; or &#x60;destroy&#x60; (optional)</param>
        /// <param name="eventDatetimeFrom">Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="eventDatetimeTo">Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;event&#x60; or &#x60;event_datetime&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>Task of ApiResponse (InstrumentationAssetsHistoryResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InstrumentationAssetsHistoryResponse>> GetAssetsOfInstrumentationHistoryAsyncWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string assetId = null, string _event = null, DateTime? eventDatetimeFrom = null, DateTime? eventDatetimeTo = null, string orderBy = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetAssetsOfInstrumentationHistory");

            var localVarPath = "/instrumentations/{instrumentation_id}/assets/history";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (assetId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asset_id", assetId)); // query parameter
            if (_event != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "event", _event)); // query parameter
            if (eventDatetimeFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "event_datetime_from", eventDatetimeFrom)); // query parameter
            if (eventDatetimeTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "event_datetime_to", eventDatetimeTo)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetAssetsOfInstrumentationHistory", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InstrumentationAssetsHistoryResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InstrumentationAssetsHistoryResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InstrumentationAssetsHistoryResponse)));
        }

        /// <summary>
        /// Get all bill of materials of an instrumentation Returns a list of all bill of materials that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="author">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="date">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="dateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="dateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <returns>BillOfMaterialsResponse</returns>
        public BillOfMaterialsResponse GetBillOfMaterialsOfInstrumentation (long? instrumentationId, int? page = null, int? perPage = null, string name = null, string author = null, string date = null, string dateFrom = null, string dateTo = null)
        {
             ApiResponse<BillOfMaterialsResponse> localVarResponse = GetBillOfMaterialsOfInstrumentationWithHttpInfo(instrumentationId, page, perPage, name, author, date, dateFrom, dateTo);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get all bill of materials of an instrumentation Returns a list of all bill of materials that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="author">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="date">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="dateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="dateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <returns>ApiResponse of BillOfMaterialsResponse</returns>
        public ApiResponse< BillOfMaterialsResponse > GetBillOfMaterialsOfInstrumentationWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string name = null, string author = null, string date = null, string dateFrom = null, string dateTo = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetBillOfMaterialsOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/bill_of_materials";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (author != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "author", author)); // query parameter
            if (date != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "date", date)); // query parameter
            if (dateFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "date_from", dateFrom)); // query parameter
            if (dateTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "date_to", dateTo)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetBillOfMaterialsOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BillOfMaterialsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (BillOfMaterialsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(BillOfMaterialsResponse)));
        }

        /// <summary>
        /// Get all bill of materials of an instrumentation Returns a list of all bill of materials that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="author">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="date">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="dateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="dateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <returns>Task of BillOfMaterialsResponse</returns>
        public async System.Threading.Tasks.Task<BillOfMaterialsResponse> GetBillOfMaterialsOfInstrumentationAsync (long? instrumentationId, int? page = null, int? perPage = null, string name = null, string author = null, string date = null, string dateFrom = null, string dateTo = null)
        {
             ApiResponse<BillOfMaterialsResponse> localVarResponse = await GetBillOfMaterialsOfInstrumentationAsyncWithHttpInfo(instrumentationId, page, perPage, name, author, date, dateFrom, dateTo);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get all bill of materials of an instrumentation Returns a list of all bill of materials that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="author">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="date">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="dateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="dateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <returns>Task of ApiResponse (BillOfMaterialsResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<BillOfMaterialsResponse>> GetBillOfMaterialsOfInstrumentationAsyncWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string name = null, string author = null, string date = null, string dateFrom = null, string dateTo = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetBillOfMaterialsOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/bill_of_materials";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (author != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "author", author)); // query parameter
            if (date != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "date", date)); // query parameter
            if (dateFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "date_from", dateFrom)); // query parameter
            if (dateTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "date_to", dateTo)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetBillOfMaterialsOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BillOfMaterialsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (BillOfMaterialsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(BillOfMaterialsResponse)));
        }

        /// <summary>
        /// Get all documents of an instrumentation Returns a list of documents. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;status, tenant, classification, categories, categories.parent, categories.standards, attachments&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="documentVersion">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="number">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="classificationId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="categoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="validFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validUntil">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validAt">Expected date format is YYYY-MM-DD or YYYY-MM or YYYY (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>DocumentsResponse</returns>
        public DocumentsResponse GetDocumentsOfInstrumentation (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string documentVersion = null, string number = null, string statusId = null, string classificationId = null, string tenantId = null, string categoryId = null, DateTime? validFrom = null, DateTime? validUntil = null, DateTime? validAt = null, string acceptLanguage = null)
        {
             ApiResponse<DocumentsResponse> localVarResponse = GetDocumentsOfInstrumentationWithHttpInfo(instrumentationId, page, perPage, include, name, documentVersion, number, statusId, classificationId, tenantId, categoryId, validFrom, validUntil, validAt, acceptLanguage);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get all documents of an instrumentation Returns a list of documents. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;status, tenant, classification, categories, categories.parent, categories.standards, attachments&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="documentVersion">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="number">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="classificationId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="categoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="validFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validUntil">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validAt">Expected date format is YYYY-MM-DD or YYYY-MM or YYYY (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>ApiResponse of DocumentsResponse</returns>
        public ApiResponse< DocumentsResponse > GetDocumentsOfInstrumentationWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string documentVersion = null, string number = null, string statusId = null, string classificationId = null, string tenantId = null, string categoryId = null, DateTime? validFrom = null, DateTime? validUntil = null, DateTime? validAt = null, string acceptLanguage = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetDocumentsOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/documents";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (documentVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "document_version", documentVersion)); // query parameter
            if (number != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "number", number)); // query parameter
            if (statusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_id", statusId)); // query parameter
            if (classificationId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "classification_id", classificationId)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (categoryId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "category_id", categoryId)); // query parameter
            if (validFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "valid_from", validFrom)); // query parameter
            if (validUntil != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "valid_until", validUntil)); // query parameter
            if (validAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "valid_at", validAt)); // query parameter
            if (acceptLanguage != null) localVarHeaderParams.Add("Accept-Language", this.Configuration.ApiClient.ParameterToString(acceptLanguage)); // header parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetDocumentsOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<DocumentsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (DocumentsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(DocumentsResponse)));
        }

        /// <summary>
        /// Get all documents of an instrumentation Returns a list of documents. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;status, tenant, classification, categories, categories.parent, categories.standards, attachments&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="documentVersion">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="number">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="classificationId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="categoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="validFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validUntil">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validAt">Expected date format is YYYY-MM-DD or YYYY-MM or YYYY (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of DocumentsResponse</returns>
        public async System.Threading.Tasks.Task<DocumentsResponse> GetDocumentsOfInstrumentationAsync (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string documentVersion = null, string number = null, string statusId = null, string classificationId = null, string tenantId = null, string categoryId = null, DateTime? validFrom = null, DateTime? validUntil = null, DateTime? validAt = null, string acceptLanguage = null)
        {
             ApiResponse<DocumentsResponse> localVarResponse = await GetDocumentsOfInstrumentationAsyncWithHttpInfo(instrumentationId, page, perPage, include, name, documentVersion, number, statusId, classificationId, tenantId, categoryId, validFrom, validUntil, validAt, acceptLanguage);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get all documents of an instrumentation Returns a list of documents. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;status, tenant, classification, categories, categories.parent, categories.standards, attachments&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="documentVersion">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="number">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="classificationId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="categoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="validFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validUntil">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validAt">Expected date format is YYYY-MM-DD or YYYY-MM or YYYY (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of ApiResponse (DocumentsResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<DocumentsResponse>> GetDocumentsOfInstrumentationAsyncWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string documentVersion = null, string number = null, string statusId = null, string classificationId = null, string tenantId = null, string categoryId = null, DateTime? validFrom = null, DateTime? validUntil = null, DateTime? validAt = null, string acceptLanguage = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetDocumentsOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/documents";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (documentVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "document_version", documentVersion)); // query parameter
            if (number != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "number", number)); // query parameter
            if (statusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_id", statusId)); // query parameter
            if (classificationId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "classification_id", classificationId)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (categoryId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "category_id", categoryId)); // query parameter
            if (validFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "valid_from", validFrom)); // query parameter
            if (validUntil != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "valid_until", validUntil)); // query parameter
            if (validAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "valid_at", validAt)); // query parameter
            if (acceptLanguage != null) localVarHeaderParams.Add("Accept-Language", this.Configuration.ApiClient.ParameterToString(acceptLanguage)); // header parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetDocumentsOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<DocumentsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (DocumentsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(DocumentsResponse)));
        }

        /// <summary>
        /// Get all events of one instrumentation Returns a list of all events belonging to an instrumentation in your accessible scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="startDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;start_datetime&#x60;, &#x60;end_datetime&#x60;, &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>EventsResponse</returns>
        public EventsResponse GetEventsOfInstrumentation (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string statusId = null, string startDatetime = null, string startDatetimeFrom = null, string startDatetimeTo = null, string endDatetime = null, DateTime? endDatetimeFrom = null, string endDatetimeTo = null, string tenantId = null, string orderBy = null)
        {
             ApiResponse<EventsResponse> localVarResponse = GetEventsOfInstrumentationWithHttpInfo(instrumentationId, page, perPage, include, name, typeId, statusId, startDatetime, startDatetimeFrom, startDatetimeTo, endDatetime, endDatetimeFrom, endDatetimeTo, tenantId, orderBy);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get all events of one instrumentation Returns a list of all events belonging to an instrumentation in your accessible scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="startDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;start_datetime&#x60;, &#x60;end_datetime&#x60;, &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of EventsResponse</returns>
        public ApiResponse< EventsResponse > GetEventsOfInstrumentationWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string statusId = null, string startDatetime = null, string startDatetimeFrom = null, string startDatetimeTo = null, string endDatetime = null, DateTime? endDatetimeFrom = null, string endDatetimeTo = null, string tenantId = null, string orderBy = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetEventsOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/events";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (typeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type_id", typeId)); // query parameter
            if (statusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_id", statusId)); // query parameter
            if (startDatetime != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start_datetime", startDatetime)); // query parameter
            if (startDatetimeFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start_datetime_from", startDatetimeFrom)); // query parameter
            if (startDatetimeTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start_datetime_to", startDatetimeTo)); // query parameter
            if (endDatetime != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "end_datetime", endDatetime)); // query parameter
            if (endDatetimeFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "end_datetime_from", endDatetimeFrom)); // query parameter
            if (endDatetimeTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "end_datetime_to", endDatetimeTo)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetEventsOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<EventsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (EventsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(EventsResponse)));
        }

        /// <summary>
        /// Get all events of one instrumentation Returns a list of all events belonging to an instrumentation in your accessible scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="startDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;start_datetime&#x60;, &#x60;end_datetime&#x60;, &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of EventsResponse</returns>
        public async System.Threading.Tasks.Task<EventsResponse> GetEventsOfInstrumentationAsync (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string statusId = null, string startDatetime = null, string startDatetimeFrom = null, string startDatetimeTo = null, string endDatetime = null, DateTime? endDatetimeFrom = null, string endDatetimeTo = null, string tenantId = null, string orderBy = null)
        {
             ApiResponse<EventsResponse> localVarResponse = await GetEventsOfInstrumentationAsyncWithHttpInfo(instrumentationId, page, perPage, include, name, typeId, statusId, startDatetime, startDatetimeFrom, startDatetimeTo, endDatetime, endDatetimeFrom, endDatetimeTo, tenantId, orderBy);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get all events of one instrumentation Returns a list of all events belonging to an instrumentation in your accessible scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="startDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;start_datetime&#x60;, &#x60;end_datetime&#x60;, &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (EventsResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<EventsResponse>> GetEventsOfInstrumentationAsyncWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string statusId = null, string startDatetime = null, string startDatetimeFrom = null, string startDatetimeTo = null, string endDatetime = null, DateTime? endDatetimeFrom = null, string endDatetimeTo = null, string tenantId = null, string orderBy = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetEventsOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/events";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (typeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type_id", typeId)); // query parameter
            if (statusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_id", statusId)); // query parameter
            if (startDatetime != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start_datetime", startDatetime)); // query parameter
            if (startDatetimeFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start_datetime_from", startDatetimeFrom)); // query parameter
            if (startDatetimeTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start_datetime_to", startDatetimeTo)); // query parameter
            if (endDatetime != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "end_datetime", endDatetime)); // query parameter
            if (endDatetimeFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "end_datetime_from", endDatetimeFrom)); // query parameter
            if (endDatetimeTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "end_datetime_to", endDatetimeTo)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetEventsOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<EventsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (EventsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(EventsResponse)));
        }

        /// <summary>
        /// Get a single instrumentation Get a specific instrumentation in your accessible scope, identified by the id in the URL.  Possible include values: &#x60;&#x60;&#x60;specifications, specifications[key1,key2], pictures, tenant, parent, status, worst_asset_status, type, type.parent, type.tenant, values, values.unit, values.asset, values_in_preferred_units, values_in_preferred_units.unit, values_in_preferred_units.asset &#x60;&#x60;&#x60; 
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the instrumentation to fetch</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <returns>InstrumentationResponse</returns>
        public InstrumentationResponse GetInstrumentationById (long? id, string include = null)
        {
             ApiResponse<InstrumentationResponse> localVarResponse = GetInstrumentationByIdWithHttpInfo(id, include);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get a single instrumentation Get a specific instrumentation in your accessible scope, identified by the id in the URL.  Possible include values: &#x60;&#x60;&#x60;specifications, specifications[key1,key2], pictures, tenant, parent, status, worst_asset_status, type, type.parent, type.tenant, values, values.unit, values.asset, values_in_preferred_units, values_in_preferred_units.unit, values_in_preferred_units.asset &#x60;&#x60;&#x60; 
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the instrumentation to fetch</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <returns>ApiResponse of InstrumentationResponse</returns>
        public ApiResponse< InstrumentationResponse > GetInstrumentationByIdWithHttpInfo (long? id, string include = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling InstrumentationApi->GetInstrumentationById");

            var localVarPath = "/instrumentations/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetInstrumentationById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InstrumentationResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InstrumentationResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InstrumentationResponse)));
        }

        /// <summary>
        /// Get a single instrumentation Get a specific instrumentation in your accessible scope, identified by the id in the URL.  Possible include values: &#x60;&#x60;&#x60;specifications, specifications[key1,key2], pictures, tenant, parent, status, worst_asset_status, type, type.parent, type.tenant, values, values.unit, values.asset, values_in_preferred_units, values_in_preferred_units.unit, values_in_preferred_units.asset &#x60;&#x60;&#x60; 
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the instrumentation to fetch</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <returns>Task of InstrumentationResponse</returns>
        public async System.Threading.Tasks.Task<InstrumentationResponse> GetInstrumentationByIdAsync (long? id, string include = null)
        {
             ApiResponse<InstrumentationResponse> localVarResponse = await GetInstrumentationByIdAsyncWithHttpInfo(id, include);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get a single instrumentation Get a specific instrumentation in your accessible scope, identified by the id in the URL.  Possible include values: &#x60;&#x60;&#x60;specifications, specifications[key1,key2], pictures, tenant, parent, status, worst_asset_status, type, type.parent, type.tenant, values, values.unit, values.asset, values_in_preferred_units, values_in_preferred_units.unit, values_in_preferred_units.asset &#x60;&#x60;&#x60; 
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the instrumentation to fetch</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <returns>Task of ApiResponse (InstrumentationResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InstrumentationResponse>> GetInstrumentationByIdAsyncWithHttpInfo (long? id, string include = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling InstrumentationApi->GetInstrumentationById");

            var localVarPath = "/instrumentations/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetInstrumentationById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InstrumentationResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InstrumentationResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InstrumentationResponse)));
        }

        /// <summary>
        /// Get the status of the specific instrumentation Returns the status of the instrumentation. Needed if only permission on instrumentation but not on tenant. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>InstrumentationStatusResponse</returns>
        public InstrumentationStatusResponse GetInstrumentationIdStatus (long? instrumentationId, string acceptLanguage = null)
        {
             ApiResponse<InstrumentationStatusResponse> localVarResponse = GetInstrumentationIdStatusWithHttpInfo(instrumentationId, acceptLanguage);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get the status of the specific instrumentation Returns the status of the instrumentation. Needed if only permission on instrumentation but not on tenant. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>ApiResponse of InstrumentationStatusResponse</returns>
        public ApiResponse< InstrumentationStatusResponse > GetInstrumentationIdStatusWithHttpInfo (long? instrumentationId, string acceptLanguage = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetInstrumentationIdStatus");

            var localVarPath = "/instrumentations/{instrumentation_id}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (acceptLanguage != null) localVarHeaderParams.Add("Accept-Language", this.Configuration.ApiClient.ParameterToString(acceptLanguage)); // header parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetInstrumentationIdStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InstrumentationStatusResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InstrumentationStatusResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InstrumentationStatusResponse)));
        }

        /// <summary>
        /// Get the status of the specific instrumentation Returns the status of the instrumentation. Needed if only permission on instrumentation but not on tenant. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of InstrumentationStatusResponse</returns>
        public async System.Threading.Tasks.Task<InstrumentationStatusResponse> GetInstrumentationIdStatusAsync (long? instrumentationId, string acceptLanguage = null)
        {
             ApiResponse<InstrumentationStatusResponse> localVarResponse = await GetInstrumentationIdStatusAsyncWithHttpInfo(instrumentationId, acceptLanguage);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get the status of the specific instrumentation Returns the status of the instrumentation. Needed if only permission on instrumentation but not on tenant. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of ApiResponse (InstrumentationStatusResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InstrumentationStatusResponse>> GetInstrumentationIdStatusAsyncWithHttpInfo (long? instrumentationId, string acceptLanguage = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetInstrumentationIdStatus");

            var localVarPath = "/instrumentations/{instrumentation_id}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (acceptLanguage != null) localVarHeaderParams.Add("Accept-Language", this.Configuration.ApiClient.ParameterToString(acceptLanguage)); // header parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetInstrumentationIdStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InstrumentationStatusResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InstrumentationStatusResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InstrumentationStatusResponse)));
        }

        /// <summary>
        /// Get the type of the specific instrumentation Returns the type of the instrumentation. Needed if only permission on instrumentation but not on tenant. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language. Possible include values: &#x60;&#x60;&#x60;parent&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>InstrumentationTypeResponse</returns>
        public InstrumentationTypeResponse GetInstrumentationIdType (long? instrumentationId, string acceptLanguage = null)
        {
             ApiResponse<InstrumentationTypeResponse> localVarResponse = GetInstrumentationIdTypeWithHttpInfo(instrumentationId, acceptLanguage);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get the type of the specific instrumentation Returns the type of the instrumentation. Needed if only permission on instrumentation but not on tenant. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language. Possible include values: &#x60;&#x60;&#x60;parent&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>ApiResponse of InstrumentationTypeResponse</returns>
        public ApiResponse< InstrumentationTypeResponse > GetInstrumentationIdTypeWithHttpInfo (long? instrumentationId, string acceptLanguage = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetInstrumentationIdType");

            var localVarPath = "/instrumentations/{instrumentation_id}/type";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (acceptLanguage != null) localVarHeaderParams.Add("Accept-Language", this.Configuration.ApiClient.ParameterToString(acceptLanguage)); // header parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetInstrumentationIdType", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InstrumentationTypeResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InstrumentationTypeResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InstrumentationTypeResponse)));
        }

        /// <summary>
        /// Get the type of the specific instrumentation Returns the type of the instrumentation. Needed if only permission on instrumentation but not on tenant. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language. Possible include values: &#x60;&#x60;&#x60;parent&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of InstrumentationTypeResponse</returns>
        public async System.Threading.Tasks.Task<InstrumentationTypeResponse> GetInstrumentationIdTypeAsync (long? instrumentationId, string acceptLanguage = null)
        {
             ApiResponse<InstrumentationTypeResponse> localVarResponse = await GetInstrumentationIdTypeAsyncWithHttpInfo(instrumentationId, acceptLanguage);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get the type of the specific instrumentation Returns the type of the instrumentation. Needed if only permission on instrumentation but not on tenant. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language. Possible include values: &#x60;&#x60;&#x60;parent&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of ApiResponse (InstrumentationTypeResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InstrumentationTypeResponse>> GetInstrumentationIdTypeAsyncWithHttpInfo (long? instrumentationId, string acceptLanguage = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetInstrumentationIdType");

            var localVarPath = "/instrumentations/{instrumentation_id}/type";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (acceptLanguage != null) localVarHeaderParams.Add("Accept-Language", this.Configuration.ApiClient.ParameterToString(acceptLanguage)); // header parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetInstrumentationIdType", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InstrumentationTypeResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InstrumentationTypeResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InstrumentationTypeResponse)));
        }

        /// <summary>
        /// Get an instrumentation picture Get a single picture of an instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>PictureResponse</returns>
        public PictureResponse GetInstrumentationPicture (long? instrumentationId, long? id)
        {
             ApiResponse<PictureResponse> localVarResponse = GetInstrumentationPictureWithHttpInfo(instrumentationId, id);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get an instrumentation picture Get a single picture of an instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>ApiResponse of PictureResponse</returns>
        public ApiResponse< PictureResponse > GetInstrumentationPictureWithHttpInfo (long? instrumentationId, long? id)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetInstrumentationPicture");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling InstrumentationApi->GetInstrumentationPicture");

            var localVarPath = "/instrumentations/{instrumentation_id}/pictures/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetInstrumentationPicture", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PictureResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (PictureResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(PictureResponse)));
        }

        /// <summary>
        /// Get an instrumentation picture Get a single picture of an instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>Task of PictureResponse</returns>
        public async System.Threading.Tasks.Task<PictureResponse> GetInstrumentationPictureAsync (long? instrumentationId, long? id)
        {
             ApiResponse<PictureResponse> localVarResponse = await GetInstrumentationPictureAsyncWithHttpInfo(instrumentationId, id);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get an instrumentation picture Get a single picture of an instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>Task of ApiResponse (PictureResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<PictureResponse>> GetInstrumentationPictureAsyncWithHttpInfo (long? instrumentationId, long? id)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetInstrumentationPicture");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling InstrumentationApi->GetInstrumentationPicture");

            var localVarPath = "/instrumentations/{instrumentation_id}/pictures/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetInstrumentationPicture", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PictureResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (PictureResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(PictureResponse)));
        }

        /// <summary>
        /// Get instrumentation pictures Get all pictures of an instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the instrumentation</param>
        /// <param name="width">filter by width (optional)</param>
        /// <param name="widthFrom">filter by width_from (optional)</param>
        /// <param name="widthTo">filter by width_to (optional)</param>
        /// <param name="height">filter by height (optional)</param>
        /// <param name="heightFrom">filter by height_from (optional)</param>
        /// <param name="heightTo">filter by height_to (optional)</param>
        /// <returns>PicturesResponse</returns>
        public PicturesResponse GetInstrumentationPictures (long? id, int? width = null, int? widthFrom = null, int? widthTo = null, int? height = null, int? heightFrom = null, int? heightTo = null)
        {
             ApiResponse<PicturesResponse> localVarResponse = GetInstrumentationPicturesWithHttpInfo(id, width, widthFrom, widthTo, height, heightFrom, heightTo);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get instrumentation pictures Get all pictures of an instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the instrumentation</param>
        /// <param name="width">filter by width (optional)</param>
        /// <param name="widthFrom">filter by width_from (optional)</param>
        /// <param name="widthTo">filter by width_to (optional)</param>
        /// <param name="height">filter by height (optional)</param>
        /// <param name="heightFrom">filter by height_from (optional)</param>
        /// <param name="heightTo">filter by height_to (optional)</param>
        /// <returns>ApiResponse of PicturesResponse</returns>
        public ApiResponse< PicturesResponse > GetInstrumentationPicturesWithHttpInfo (long? id, int? width = null, int? widthFrom = null, int? widthTo = null, int? height = null, int? heightFrom = null, int? heightTo = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling InstrumentationApi->GetInstrumentationPictures");

            var localVarPath = "/instrumentations/{id}/pictures";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (width != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "width", width)); // query parameter
            if (widthFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "width_from", widthFrom)); // query parameter
            if (widthTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "width_to", widthTo)); // query parameter
            if (height != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "height", height)); // query parameter
            if (heightFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "height_from", heightFrom)); // query parameter
            if (heightTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "height_to", heightTo)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetInstrumentationPictures", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PicturesResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (PicturesResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(PicturesResponse)));
        }

        /// <summary>
        /// Get instrumentation pictures Get all pictures of an instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the instrumentation</param>
        /// <param name="width">filter by width (optional)</param>
        /// <param name="widthFrom">filter by width_from (optional)</param>
        /// <param name="widthTo">filter by width_to (optional)</param>
        /// <param name="height">filter by height (optional)</param>
        /// <param name="heightFrom">filter by height_from (optional)</param>
        /// <param name="heightTo">filter by height_to (optional)</param>
        /// <returns>Task of PicturesResponse</returns>
        public async System.Threading.Tasks.Task<PicturesResponse> GetInstrumentationPicturesAsync (long? id, int? width = null, int? widthFrom = null, int? widthTo = null, int? height = null, int? heightFrom = null, int? heightTo = null)
        {
             ApiResponse<PicturesResponse> localVarResponse = await GetInstrumentationPicturesAsyncWithHttpInfo(id, width, widthFrom, widthTo, height, heightFrom, heightTo);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get instrumentation pictures Get all pictures of an instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the instrumentation</param>
        /// <param name="width">filter by width (optional)</param>
        /// <param name="widthFrom">filter by width_from (optional)</param>
        /// <param name="widthTo">filter by width_to (optional)</param>
        /// <param name="height">filter by height (optional)</param>
        /// <param name="heightFrom">filter by height_from (optional)</param>
        /// <param name="heightTo">filter by height_to (optional)</param>
        /// <returns>Task of ApiResponse (PicturesResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<PicturesResponse>> GetInstrumentationPicturesAsyncWithHttpInfo (long? id, int? width = null, int? widthFrom = null, int? widthTo = null, int? height = null, int? heightFrom = null, int? heightTo = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling InstrumentationApi->GetInstrumentationPictures");

            var localVarPath = "/instrumentations/{id}/pictures";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (width != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "width", width)); // query parameter
            if (widthFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "width_from", widthFrom)); // query parameter
            if (widthTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "width_to", widthTo)); // query parameter
            if (height != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "height", height)); // query parameter
            if (heightFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "height_from", heightFrom)); // query parameter
            if (heightTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "height_to", heightTo)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetInstrumentationPictures", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PicturesResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (PicturesResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(PicturesResponse)));
        }

        /// <summary>
        /// Get all possible statuses of the specified instrumentation Returns a list of all possible instrumentation statuses for the specified instrument. You can apply the query parameters listed below to get a filtered list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>InstrumentationStatuses</returns>
        public InstrumentationStatuses GetInstrumentationStatusesOptions (long? instrumentationId, int? page = null, int? perPage = null, string tenantId = null, string name = null, string code = null, string acceptLanguage = null)
        {
             ApiResponse<InstrumentationStatuses> localVarResponse = GetInstrumentationStatusesOptionsWithHttpInfo(instrumentationId, page, perPage, tenantId, name, code, acceptLanguage);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get all possible statuses of the specified instrumentation Returns a list of all possible instrumentation statuses for the specified instrument. You can apply the query parameters listed below to get a filtered list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>ApiResponse of InstrumentationStatuses</returns>
        public ApiResponse< InstrumentationStatuses > GetInstrumentationStatusesOptionsWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string tenantId = null, string name = null, string code = null, string acceptLanguage = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetInstrumentationStatusesOptions");

            var localVarPath = "/instrumentations/{instrumentation_id}/status-options";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (code != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "code", code)); // query parameter
            if (acceptLanguage != null) localVarHeaderParams.Add("Accept-Language", this.Configuration.ApiClient.ParameterToString(acceptLanguage)); // header parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetInstrumentationStatusesOptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InstrumentationStatuses>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InstrumentationStatuses) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InstrumentationStatuses)));
        }

        /// <summary>
        /// Get all possible statuses of the specified instrumentation Returns a list of all possible instrumentation statuses for the specified instrument. You can apply the query parameters listed below to get a filtered list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of InstrumentationStatuses</returns>
        public async System.Threading.Tasks.Task<InstrumentationStatuses> GetInstrumentationStatusesOptionsAsync (long? instrumentationId, int? page = null, int? perPage = null, string tenantId = null, string name = null, string code = null, string acceptLanguage = null)
        {
             ApiResponse<InstrumentationStatuses> localVarResponse = await GetInstrumentationStatusesOptionsAsyncWithHttpInfo(instrumentationId, page, perPage, tenantId, name, code, acceptLanguage);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get all possible statuses of the specified instrumentation Returns a list of all possible instrumentation statuses for the specified instrument. You can apply the query parameters listed below to get a filtered list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of ApiResponse (InstrumentationStatuses)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InstrumentationStatuses>> GetInstrumentationStatusesOptionsAsyncWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string tenantId = null, string name = null, string code = null, string acceptLanguage = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetInstrumentationStatusesOptions");

            var localVarPath = "/instrumentations/{instrumentation_id}/status-options";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (code != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "code", code)); // query parameter
            if (acceptLanguage != null) localVarHeaderParams.Add("Accept-Language", this.Configuration.ApiClient.ParameterToString(acceptLanguage)); // header parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetInstrumentationStatusesOptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InstrumentationStatuses>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InstrumentationStatuses) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InstrumentationStatuses)));
        }

        /// <summary>
        /// Get an instrumentation threshold Get a single threshold of an instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation threshold</param>
        /// <returns>ThresholdResponse</returns>
        public ThresholdResponse GetInstrumentationThreshold (long? instrumentationId, long? id)
        {
             ApiResponse<ThresholdResponse> localVarResponse = GetInstrumentationThresholdWithHttpInfo(instrumentationId, id);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get an instrumentation threshold Get a single threshold of an instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation threshold</param>
        /// <returns>ApiResponse of ThresholdResponse</returns>
        public ApiResponse< ThresholdResponse > GetInstrumentationThresholdWithHttpInfo (long? instrumentationId, long? id)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetInstrumentationThreshold");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling InstrumentationApi->GetInstrumentationThreshold");

            var localVarPath = "/instrumentations/{instrumentation_id}/thresholds/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetInstrumentationThreshold", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ThresholdResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (ThresholdResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ThresholdResponse)));
        }

        /// <summary>
        /// Get an instrumentation threshold Get a single threshold of an instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation threshold</param>
        /// <returns>Task of ThresholdResponse</returns>
        public async System.Threading.Tasks.Task<ThresholdResponse> GetInstrumentationThresholdAsync (long? instrumentationId, long? id)
        {
             ApiResponse<ThresholdResponse> localVarResponse = await GetInstrumentationThresholdAsyncWithHttpInfo(instrumentationId, id);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get an instrumentation threshold Get a single threshold of an instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation threshold</param>
        /// <returns>Task of ApiResponse (ThresholdResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ThresholdResponse>> GetInstrumentationThresholdAsyncWithHttpInfo (long? instrumentationId, long? id)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetInstrumentationThreshold");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling InstrumentationApi->GetInstrumentationThreshold");

            var localVarPath = "/instrumentations/{instrumentation_id}/thresholds/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetInstrumentationThreshold", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ThresholdResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (ThresholdResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ThresholdResponse)));
        }

        /// <summary>
        /// Get instrumentation thresholds Get all thresholds of an instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="key">filter by key (optional)</param>
        /// <param name="thresholdType">filter by type (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;name&#x60;, &#x60;key&#x60;, &#x60;threshold_type&#x60;, &#x60;notification&#x60;, &#x60;created_at&#x60;, &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ThresholdsResponse</returns>
        public ThresholdsResponse GetInstrumentationThresholds (long? instrumentationId, string key = null, string thresholdType = null, string orderBy = null)
        {
             ApiResponse<ThresholdsResponse> localVarResponse = GetInstrumentationThresholdsWithHttpInfo(instrumentationId, key, thresholdType, orderBy);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get instrumentation thresholds Get all thresholds of an instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="key">filter by key (optional)</param>
        /// <param name="thresholdType">filter by type (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;name&#x60;, &#x60;key&#x60;, &#x60;threshold_type&#x60;, &#x60;notification&#x60;, &#x60;created_at&#x60;, &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of ThresholdsResponse</returns>
        public ApiResponse< ThresholdsResponse > GetInstrumentationThresholdsWithHttpInfo (long? instrumentationId, string key = null, string thresholdType = null, string orderBy = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetInstrumentationThresholds");

            var localVarPath = "/instrumentations/{instrumentation_id}/thresholds";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            if (thresholdType != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "threshold_type", thresholdType)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetInstrumentationThresholds", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ThresholdsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (ThresholdsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ThresholdsResponse)));
        }

        /// <summary>
        /// Get instrumentation thresholds Get all thresholds of an instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="key">filter by key (optional)</param>
        /// <param name="thresholdType">filter by type (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;name&#x60;, &#x60;key&#x60;, &#x60;threshold_type&#x60;, &#x60;notification&#x60;, &#x60;created_at&#x60;, &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ThresholdsResponse</returns>
        public async System.Threading.Tasks.Task<ThresholdsResponse> GetInstrumentationThresholdsAsync (long? instrumentationId, string key = null, string thresholdType = null, string orderBy = null)
        {
             ApiResponse<ThresholdsResponse> localVarResponse = await GetInstrumentationThresholdsAsyncWithHttpInfo(instrumentationId, key, thresholdType, orderBy);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get instrumentation thresholds Get all thresholds of an instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="key">filter by key (optional)</param>
        /// <param name="thresholdType">filter by type (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;name&#x60;, &#x60;key&#x60;, &#x60;threshold_type&#x60;, &#x60;notification&#x60;, &#x60;created_at&#x60;, &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (ThresholdsResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ThresholdsResponse>> GetInstrumentationThresholdsAsyncWithHttpInfo (long? instrumentationId, string key = null, string thresholdType = null, string orderBy = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetInstrumentationThresholds");

            var localVarPath = "/instrumentations/{instrumentation_id}/thresholds";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            if (thresholdType != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "threshold_type", thresholdType)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetInstrumentationThresholds", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ThresholdsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (ThresholdsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ThresholdsResponse)));
        }

        /// <summary>
        /// Get all possible types of the specified instrumentation Returns a list of all possible instrumentation types for the specified instrument. You can apply the query parameters listed below to get a filtered list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>InstrumentationTypes</returns>
        public InstrumentationTypes GetInstrumentationTypesOptions (long? instrumentationId, int? page = null, int? perPage = null, string tenantId = null, string name = null, string code = null, string acceptLanguage = null)
        {
             ApiResponse<InstrumentationTypes> localVarResponse = GetInstrumentationTypesOptionsWithHttpInfo(instrumentationId, page, perPage, tenantId, name, code, acceptLanguage);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get all possible types of the specified instrumentation Returns a list of all possible instrumentation types for the specified instrument. You can apply the query parameters listed below to get a filtered list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>ApiResponse of InstrumentationTypes</returns>
        public ApiResponse< InstrumentationTypes > GetInstrumentationTypesOptionsWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string tenantId = null, string name = null, string code = null, string acceptLanguage = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetInstrumentationTypesOptions");

            var localVarPath = "/instrumentations/{instrumentation_id}/type-options";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (code != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "code", code)); // query parameter
            if (acceptLanguage != null) localVarHeaderParams.Add("Accept-Language", this.Configuration.ApiClient.ParameterToString(acceptLanguage)); // header parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetInstrumentationTypesOptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InstrumentationTypes>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InstrumentationTypes) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InstrumentationTypes)));
        }

        /// <summary>
        /// Get all possible types of the specified instrumentation Returns a list of all possible instrumentation types for the specified instrument. You can apply the query parameters listed below to get a filtered list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of InstrumentationTypes</returns>
        public async System.Threading.Tasks.Task<InstrumentationTypes> GetInstrumentationTypesOptionsAsync (long? instrumentationId, int? page = null, int? perPage = null, string tenantId = null, string name = null, string code = null, string acceptLanguage = null)
        {
             ApiResponse<InstrumentationTypes> localVarResponse = await GetInstrumentationTypesOptionsAsyncWithHttpInfo(instrumentationId, page, perPage, tenantId, name, code, acceptLanguage);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get all possible types of the specified instrumentation Returns a list of all possible instrumentation types for the specified instrument. You can apply the query parameters listed below to get a filtered list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of ApiResponse (InstrumentationTypes)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InstrumentationTypes>> GetInstrumentationTypesOptionsAsyncWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string tenantId = null, string name = null, string code = null, string acceptLanguage = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetInstrumentationTypesOptions");

            var localVarPath = "/instrumentations/{instrumentation_id}/type-options";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (code != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "code", code)); // query parameter
            if (acceptLanguage != null) localVarHeaderParams.Add("Accept-Language", this.Configuration.ApiClient.ParameterToString(acceptLanguage)); // header parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetInstrumentationTypesOptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InstrumentationTypes>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InstrumentationTypes) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InstrumentationTypes)));
        }

        /// <summary>
        /// Get instrumentation value objects for a specific key. Returns a collection of the history value objects of the value objects for the specified key. For a selected result of the value objects the filter parameters selector and interval are mandatory. With the filter parameters from, to or datetime, it is possible to receive the history of a defined time period. Possible include values: &#x60;&#x60;&#x60;asset&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="key">key for the instrumentation values</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="from">Start date filter for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="to">End date for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="datetime">exact date for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="selector">Supported selector methods are &#x60;first, last&#x60;. This value is mandatory if interval is defined. (optional)</param>
        /// <param name="interval">Interval which is used for the selector. The value is mandatory if selector is defined. Supported intervals are number of &#x60;s, m, h, d, w&#x60;. Example &#x60;3h&#x60;. (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;timestamp&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default ordering is the order the values were entered in. (optional)</param>
        /// <returns>AssetKeyValueObjectsResponse</returns>
        public AssetKeyValueObjectsResponse GetInstrumentationValueObjectsForKey (long? instrumentationId, string key, int? page = null, int? perPage = null, string include = null, DateTime? from = null, DateTime? to = null, DateTime? datetime = null, string selector = null, string interval = null, string orderBy = null)
        {
             ApiResponse<AssetKeyValueObjectsResponse> localVarResponse = GetInstrumentationValueObjectsForKeyWithHttpInfo(instrumentationId, key, page, perPage, include, from, to, datetime, selector, interval, orderBy);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get instrumentation value objects for a specific key. Returns a collection of the history value objects of the value objects for the specified key. For a selected result of the value objects the filter parameters selector and interval are mandatory. With the filter parameters from, to or datetime, it is possible to receive the history of a defined time period. Possible include values: &#x60;&#x60;&#x60;asset&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="key">key for the instrumentation values</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="from">Start date filter for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="to">End date for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="datetime">exact date for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="selector">Supported selector methods are &#x60;first, last&#x60;. This value is mandatory if interval is defined. (optional)</param>
        /// <param name="interval">Interval which is used for the selector. The value is mandatory if selector is defined. Supported intervals are number of &#x60;s, m, h, d, w&#x60;. Example &#x60;3h&#x60;. (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;timestamp&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default ordering is the order the values were entered in. (optional)</param>
        /// <returns>ApiResponse of AssetKeyValueObjectsResponse</returns>
        public ApiResponse< AssetKeyValueObjectsResponse > GetInstrumentationValueObjectsForKeyWithHttpInfo (long? instrumentationId, string key, int? page = null, int? perPage = null, string include = null, DateTime? from = null, DateTime? to = null, DateTime? datetime = null, string selector = null, string interval = null, string orderBy = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetInstrumentationValueObjectsForKey");
            // verify the required parameter 'key' is set
            if (key == null)
                throw new ApiException(400, "Missing required parameter 'key' when calling InstrumentationApi->GetInstrumentationValueObjectsForKey");

            var localVarPath = "/instrumentations/{instrumentation_id}/value_objects/{key}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (key != null) localVarPathParams.Add("key", this.Configuration.ApiClient.ParameterToString(key)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (from != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "from", from)); // query parameter
            if (to != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "to", to)); // query parameter
            if (datetime != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "datetime", datetime)); // query parameter
            if (selector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "selector", selector)); // query parameter
            if (interval != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "interval", interval)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetInstrumentationValueObjectsForKey", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AssetKeyValueObjectsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (AssetKeyValueObjectsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AssetKeyValueObjectsResponse)));
        }

        /// <summary>
        /// Get instrumentation value objects for a specific key. Returns a collection of the history value objects of the value objects for the specified key. For a selected result of the value objects the filter parameters selector and interval are mandatory. With the filter parameters from, to or datetime, it is possible to receive the history of a defined time period. Possible include values: &#x60;&#x60;&#x60;asset&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="key">key for the instrumentation values</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="from">Start date filter for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="to">End date for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="datetime">exact date for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="selector">Supported selector methods are &#x60;first, last&#x60;. This value is mandatory if interval is defined. (optional)</param>
        /// <param name="interval">Interval which is used for the selector. The value is mandatory if selector is defined. Supported intervals are number of &#x60;s, m, h, d, w&#x60;. Example &#x60;3h&#x60;. (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;timestamp&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default ordering is the order the values were entered in. (optional)</param>
        /// <returns>Task of AssetKeyValueObjectsResponse</returns>
        public async System.Threading.Tasks.Task<AssetKeyValueObjectsResponse> GetInstrumentationValueObjectsForKeyAsync (long? instrumentationId, string key, int? page = null, int? perPage = null, string include = null, DateTime? from = null, DateTime? to = null, DateTime? datetime = null, string selector = null, string interval = null, string orderBy = null)
        {
             ApiResponse<AssetKeyValueObjectsResponse> localVarResponse = await GetInstrumentationValueObjectsForKeyAsyncWithHttpInfo(instrumentationId, key, page, perPage, include, from, to, datetime, selector, interval, orderBy);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get instrumentation value objects for a specific key. Returns a collection of the history value objects of the value objects for the specified key. For a selected result of the value objects the filter parameters selector and interval are mandatory. With the filter parameters from, to or datetime, it is possible to receive the history of a defined time period. Possible include values: &#x60;&#x60;&#x60;asset&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="key">key for the instrumentation values</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="from">Start date filter for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="to">End date for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="datetime">exact date for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="selector">Supported selector methods are &#x60;first, last&#x60;. This value is mandatory if interval is defined. (optional)</param>
        /// <param name="interval">Interval which is used for the selector. The value is mandatory if selector is defined. Supported intervals are number of &#x60;s, m, h, d, w&#x60;. Example &#x60;3h&#x60;. (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;timestamp&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default ordering is the order the values were entered in. (optional)</param>
        /// <returns>Task of ApiResponse (AssetKeyValueObjectsResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<AssetKeyValueObjectsResponse>> GetInstrumentationValueObjectsForKeyAsyncWithHttpInfo (long? instrumentationId, string key, int? page = null, int? perPage = null, string include = null, DateTime? from = null, DateTime? to = null, DateTime? datetime = null, string selector = null, string interval = null, string orderBy = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetInstrumentationValueObjectsForKey");
            // verify the required parameter 'key' is set
            if (key == null)
                throw new ApiException(400, "Missing required parameter 'key' when calling InstrumentationApi->GetInstrumentationValueObjectsForKey");

            var localVarPath = "/instrumentations/{instrumentation_id}/value_objects/{key}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (key != null) localVarPathParams.Add("key", this.Configuration.ApiClient.ParameterToString(key)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (from != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "from", from)); // query parameter
            if (to != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "to", to)); // query parameter
            if (datetime != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "datetime", datetime)); // query parameter
            if (selector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "selector", selector)); // query parameter
            if (interval != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "interval", interval)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetInstrumentationValueObjectsForKey", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AssetKeyValueObjectsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (AssetKeyValueObjectsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AssetKeyValueObjectsResponse)));
        }

        /// <summary>
        /// Get latest values for the instrumentation. Returns a collection of the latest values for all keys of the instrumentation. Possible include values: &#x60;&#x60;&#x60;unit, asset&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="usePreferredUnits">whether to return the values in the preferred units described in the asset specification &#x27;preferred_units&#x27; or not, for the instrumentation the mapping will result from the merge of all its assets mappings. These values have lower precedence than the parameter key_unit_id. Example value of the specification is &#x27;{\&quot;key_1\&quot;\\:\&quot;unit_code_1\&quot;, \&quot;key_2\&quot;\\:\&quot;unit_code_2\&quot;}&#x27; (optional)</param>
        /// <param name="key">only the values of the specified keys will be returned. If no key is specified all keys of the asset with its latest values will be received. Multiple values can be specified in a comma seperated list. (optional)</param>
        /// <param name="keyUnitId">value of the provided key will be returned in the specified unit. If no key_unit is defined the last written unit will be returned. Accepted format is &#x60;key[unit_id]&#x60;. Multiple values can be provided in a comma seperated list. (optional)</param>
        /// <param name="group">Group of the asset value. (optional)</param>
        /// <returns>AssetValuesResponse</returns>
        public AssetValuesResponse GetInstrumentationValues (long? instrumentationId, int? page = null, int? perPage = null, string include = null, bool? usePreferredUnits = null, string key = null, string keyUnitId = null, string group = null)
        {
             ApiResponse<AssetValuesResponse> localVarResponse = GetInstrumentationValuesWithHttpInfo(instrumentationId, page, perPage, include, usePreferredUnits, key, keyUnitId, group);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get latest values for the instrumentation. Returns a collection of the latest values for all keys of the instrumentation. Possible include values: &#x60;&#x60;&#x60;unit, asset&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="usePreferredUnits">whether to return the values in the preferred units described in the asset specification &#x27;preferred_units&#x27; or not, for the instrumentation the mapping will result from the merge of all its assets mappings. These values have lower precedence than the parameter key_unit_id. Example value of the specification is &#x27;{\&quot;key_1\&quot;\\:\&quot;unit_code_1\&quot;, \&quot;key_2\&quot;\\:\&quot;unit_code_2\&quot;}&#x27; (optional)</param>
        /// <param name="key">only the values of the specified keys will be returned. If no key is specified all keys of the asset with its latest values will be received. Multiple values can be specified in a comma seperated list. (optional)</param>
        /// <param name="keyUnitId">value of the provided key will be returned in the specified unit. If no key_unit is defined the last written unit will be returned. Accepted format is &#x60;key[unit_id]&#x60;. Multiple values can be provided in a comma seperated list. (optional)</param>
        /// <param name="group">Group of the asset value. (optional)</param>
        /// <returns>ApiResponse of AssetValuesResponse</returns>
        public ApiResponse< AssetValuesResponse > GetInstrumentationValuesWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string include = null, bool? usePreferredUnits = null, string key = null, string keyUnitId = null, string group = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetInstrumentationValues");

            var localVarPath = "/instrumentations/{instrumentation_id}/values";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (usePreferredUnits != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "use_preferred_units", usePreferredUnits)); // query parameter
            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            if (keyUnitId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key_unit_id", keyUnitId)); // query parameter
            if (group != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "group", group)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetInstrumentationValues", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AssetValuesResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (AssetValuesResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AssetValuesResponse)));
        }

        /// <summary>
        /// Get latest values for the instrumentation. Returns a collection of the latest values for all keys of the instrumentation. Possible include values: &#x60;&#x60;&#x60;unit, asset&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="usePreferredUnits">whether to return the values in the preferred units described in the asset specification &#x27;preferred_units&#x27; or not, for the instrumentation the mapping will result from the merge of all its assets mappings. These values have lower precedence than the parameter key_unit_id. Example value of the specification is &#x27;{\&quot;key_1\&quot;\\:\&quot;unit_code_1\&quot;, \&quot;key_2\&quot;\\:\&quot;unit_code_2\&quot;}&#x27; (optional)</param>
        /// <param name="key">only the values of the specified keys will be returned. If no key is specified all keys of the asset with its latest values will be received. Multiple values can be specified in a comma seperated list. (optional)</param>
        /// <param name="keyUnitId">value of the provided key will be returned in the specified unit. If no key_unit is defined the last written unit will be returned. Accepted format is &#x60;key[unit_id]&#x60;. Multiple values can be provided in a comma seperated list. (optional)</param>
        /// <param name="group">Group of the asset value. (optional)</param>
        /// <returns>Task of AssetValuesResponse</returns>
        public async System.Threading.Tasks.Task<AssetValuesResponse> GetInstrumentationValuesAsync (long? instrumentationId, int? page = null, int? perPage = null, string include = null, bool? usePreferredUnits = null, string key = null, string keyUnitId = null, string group = null)
        {
             ApiResponse<AssetValuesResponse> localVarResponse = await GetInstrumentationValuesAsyncWithHttpInfo(instrumentationId, page, perPage, include, usePreferredUnits, key, keyUnitId, group);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get latest values for the instrumentation. Returns a collection of the latest values for all keys of the instrumentation. Possible include values: &#x60;&#x60;&#x60;unit, asset&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="usePreferredUnits">whether to return the values in the preferred units described in the asset specification &#x27;preferred_units&#x27; or not, for the instrumentation the mapping will result from the merge of all its assets mappings. These values have lower precedence than the parameter key_unit_id. Example value of the specification is &#x27;{\&quot;key_1\&quot;\\:\&quot;unit_code_1\&quot;, \&quot;key_2\&quot;\\:\&quot;unit_code_2\&quot;}&#x27; (optional)</param>
        /// <param name="key">only the values of the specified keys will be returned. If no key is specified all keys of the asset with its latest values will be received. Multiple values can be specified in a comma seperated list. (optional)</param>
        /// <param name="keyUnitId">value of the provided key will be returned in the specified unit. If no key_unit is defined the last written unit will be returned. Accepted format is &#x60;key[unit_id]&#x60;. Multiple values can be provided in a comma seperated list. (optional)</param>
        /// <param name="group">Group of the asset value. (optional)</param>
        /// <returns>Task of ApiResponse (AssetValuesResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<AssetValuesResponse>> GetInstrumentationValuesAsyncWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string include = null, bool? usePreferredUnits = null, string key = null, string keyUnitId = null, string group = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetInstrumentationValues");

            var localVarPath = "/instrumentations/{instrumentation_id}/values";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (usePreferredUnits != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "use_preferred_units", usePreferredUnits)); // query parameter
            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            if (keyUnitId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key_unit_id", keyUnitId)); // query parameter
            if (group != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "group", group)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetInstrumentationValues", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AssetValuesResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (AssetValuesResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AssetValuesResponse)));
        }

        /// <summary>
        /// Get instrumentation values for a specific key. Returns a collection of the history values of an values for the specified key. For a aggregated result of the values the filter parameters aggregation and interval are mandatory. Receiving the result in a specific unit please use the filter parameter unit. The allowed units can be found in the intro section. With the filter parameters from to it is possible to receive the history of a defined time period. Possible include values: &#x60;&#x60;&#x60;unit&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="key">key for the instrumentation values</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page, default value is 500, maximum is 1000 (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="usePreferredUnits">whether to return the values in the preferred units described in the asset specification &#x27;preferred_units&#x27; or not, for the instrumentation the mapping will result from the merge of all its assets mappings. These values have lower precedence than the parameter unit_id. Example value of the specification is &#x27;{\&quot;key_1\&quot;\\:\&quot;unit_code_1\&quot;, \&quot;key_2\&quot;\\:\&quot;unit_code_2\&quot;}&#x27; (optional)</param>
        /// <param name="from">Start date filter for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="to">End date for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="unitId">Id of the unit in which the values are to be returned. (optional)</param>
        /// <param name="aggregation">Supported aggregation methods are &#x60;mean, min, max, sum, stddev&#x60;. This value is mandatory if interval is defined. (optional)</param>
        /// <param name="interval">Interval which is used for the aggregation. The value is mandatory if aggregation is defined. Supported intervals are number of &#x60;s, m, h, d, w&#x60;. Example &#x60;3h&#x60;. (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;timestamp&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default ordering is the order the values were entered in. (optional)</param>
        /// <returns>AssetKeyValuesResponse</returns>
        public AssetKeyValuesResponse GetInstrumentationValuesForKey (long? instrumentationId, string key, int? page = null, int? perPage = null, string include = null, bool? usePreferredUnits = null, DateTime? from = null, DateTime? to = null, int? unitId = null, string aggregation = null, string interval = null, string orderBy = null)
        {
             ApiResponse<AssetKeyValuesResponse> localVarResponse = GetInstrumentationValuesForKeyWithHttpInfo(instrumentationId, key, page, perPage, include, usePreferredUnits, from, to, unitId, aggregation, interval, orderBy);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get instrumentation values for a specific key. Returns a collection of the history values of an values for the specified key. For a aggregated result of the values the filter parameters aggregation and interval are mandatory. Receiving the result in a specific unit please use the filter parameter unit. The allowed units can be found in the intro section. With the filter parameters from to it is possible to receive the history of a defined time period. Possible include values: &#x60;&#x60;&#x60;unit&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="key">key for the instrumentation values</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page, default value is 500, maximum is 1000 (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="usePreferredUnits">whether to return the values in the preferred units described in the asset specification &#x27;preferred_units&#x27; or not, for the instrumentation the mapping will result from the merge of all its assets mappings. These values have lower precedence than the parameter unit_id. Example value of the specification is &#x27;{\&quot;key_1\&quot;\\:\&quot;unit_code_1\&quot;, \&quot;key_2\&quot;\\:\&quot;unit_code_2\&quot;}&#x27; (optional)</param>
        /// <param name="from">Start date filter for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="to">End date for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="unitId">Id of the unit in which the values are to be returned. (optional)</param>
        /// <param name="aggregation">Supported aggregation methods are &#x60;mean, min, max, sum, stddev&#x60;. This value is mandatory if interval is defined. (optional)</param>
        /// <param name="interval">Interval which is used for the aggregation. The value is mandatory if aggregation is defined. Supported intervals are number of &#x60;s, m, h, d, w&#x60;. Example &#x60;3h&#x60;. (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;timestamp&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default ordering is the order the values were entered in. (optional)</param>
        /// <returns>ApiResponse of AssetKeyValuesResponse</returns>
        public ApiResponse< AssetKeyValuesResponse > GetInstrumentationValuesForKeyWithHttpInfo (long? instrumentationId, string key, int? page = null, int? perPage = null, string include = null, bool? usePreferredUnits = null, DateTime? from = null, DateTime? to = null, int? unitId = null, string aggregation = null, string interval = null, string orderBy = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetInstrumentationValuesForKey");
            // verify the required parameter 'key' is set
            if (key == null)
                throw new ApiException(400, "Missing required parameter 'key' when calling InstrumentationApi->GetInstrumentationValuesForKey");

            var localVarPath = "/instrumentations/{instrumentation_id}/values/{key}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (key != null) localVarPathParams.Add("key", this.Configuration.ApiClient.ParameterToString(key)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (usePreferredUnits != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "use_preferred_units", usePreferredUnits)); // query parameter
            if (from != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "from", from)); // query parameter
            if (to != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "to", to)); // query parameter
            if (unitId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "unit_id", unitId)); // query parameter
            if (aggregation != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "aggregation", aggregation)); // query parameter
            if (interval != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "interval", interval)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetInstrumentationValuesForKey", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AssetKeyValuesResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (AssetKeyValuesResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AssetKeyValuesResponse)));
        }

        /// <summary>
        /// Get instrumentation values for a specific key. Returns a collection of the history values of an values for the specified key. For a aggregated result of the values the filter parameters aggregation and interval are mandatory. Receiving the result in a specific unit please use the filter parameter unit. The allowed units can be found in the intro section. With the filter parameters from to it is possible to receive the history of a defined time period. Possible include values: &#x60;&#x60;&#x60;unit&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="key">key for the instrumentation values</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page, default value is 500, maximum is 1000 (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="usePreferredUnits">whether to return the values in the preferred units described in the asset specification &#x27;preferred_units&#x27; or not, for the instrumentation the mapping will result from the merge of all its assets mappings. These values have lower precedence than the parameter unit_id. Example value of the specification is &#x27;{\&quot;key_1\&quot;\\:\&quot;unit_code_1\&quot;, \&quot;key_2\&quot;\\:\&quot;unit_code_2\&quot;}&#x27; (optional)</param>
        /// <param name="from">Start date filter for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="to">End date for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="unitId">Id of the unit in which the values are to be returned. (optional)</param>
        /// <param name="aggregation">Supported aggregation methods are &#x60;mean, min, max, sum, stddev&#x60;. This value is mandatory if interval is defined. (optional)</param>
        /// <param name="interval">Interval which is used for the aggregation. The value is mandatory if aggregation is defined. Supported intervals are number of &#x60;s, m, h, d, w&#x60;. Example &#x60;3h&#x60;. (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;timestamp&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default ordering is the order the values were entered in. (optional)</param>
        /// <returns>Task of AssetKeyValuesResponse</returns>
        public async System.Threading.Tasks.Task<AssetKeyValuesResponse> GetInstrumentationValuesForKeyAsync (long? instrumentationId, string key, int? page = null, int? perPage = null, string include = null, bool? usePreferredUnits = null, DateTime? from = null, DateTime? to = null, int? unitId = null, string aggregation = null, string interval = null, string orderBy = null)
        {
             ApiResponse<AssetKeyValuesResponse> localVarResponse = await GetInstrumentationValuesForKeyAsyncWithHttpInfo(instrumentationId, key, page, perPage, include, usePreferredUnits, from, to, unitId, aggregation, interval, orderBy);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get instrumentation values for a specific key. Returns a collection of the history values of an values for the specified key. For a aggregated result of the values the filter parameters aggregation and interval are mandatory. Receiving the result in a specific unit please use the filter parameter unit. The allowed units can be found in the intro section. With the filter parameters from to it is possible to receive the history of a defined time period. Possible include values: &#x60;&#x60;&#x60;unit&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="key">key for the instrumentation values</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page, default value is 500, maximum is 1000 (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="usePreferredUnits">whether to return the values in the preferred units described in the asset specification &#x27;preferred_units&#x27; or not, for the instrumentation the mapping will result from the merge of all its assets mappings. These values have lower precedence than the parameter unit_id. Example value of the specification is &#x27;{\&quot;key_1\&quot;\\:\&quot;unit_code_1\&quot;, \&quot;key_2\&quot;\\:\&quot;unit_code_2\&quot;}&#x27; (optional)</param>
        /// <param name="from">Start date filter for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="to">End date for history values. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="unitId">Id of the unit in which the values are to be returned. (optional)</param>
        /// <param name="aggregation">Supported aggregation methods are &#x60;mean, min, max, sum, stddev&#x60;. This value is mandatory if interval is defined. (optional)</param>
        /// <param name="interval">Interval which is used for the aggregation. The value is mandatory if aggregation is defined. Supported intervals are number of &#x60;s, m, h, d, w&#x60;. Example &#x60;3h&#x60;. (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;timestamp&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default ordering is the order the values were entered in. (optional)</param>
        /// <returns>Task of ApiResponse (AssetKeyValuesResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<AssetKeyValuesResponse>> GetInstrumentationValuesForKeyAsyncWithHttpInfo (long? instrumentationId, string key, int? page = null, int? perPage = null, string include = null, bool? usePreferredUnits = null, DateTime? from = null, DateTime? to = null, int? unitId = null, string aggregation = null, string interval = null, string orderBy = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetInstrumentationValuesForKey");
            // verify the required parameter 'key' is set
            if (key == null)
                throw new ApiException(400, "Missing required parameter 'key' when calling InstrumentationApi->GetInstrumentationValuesForKey");

            var localVarPath = "/instrumentations/{instrumentation_id}/values/{key}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (key != null) localVarPathParams.Add("key", this.Configuration.ApiClient.ParameterToString(key)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (usePreferredUnits != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "use_preferred_units", usePreferredUnits)); // query parameter
            if (from != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "from", from)); // query parameter
            if (to != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "to", to)); // query parameter
            if (unitId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "unit_id", unitId)); // query parameter
            if (aggregation != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "aggregation", aggregation)); // query parameter
            if (interval != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "interval", interval)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetInstrumentationValuesForKey", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AssetKeyValuesResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (AssetKeyValuesResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AssetKeyValuesResponse)));
        }

        /// <summary>
        /// Get a range of instrumentations Returns a list of instrumentations in your accessible scope. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;specifications, specifications[key1,key2], pictures, tenant, parent, status, worst_asset_status, type, type.tenant, type.parent, values, values.unit, values_in_preferred_units, values_in_preferred_units.unit&#x60;&#x60;&#x60; 
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="tag">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="criticality">Filter accepts undefined, low, medium or high (optional)</param>
        /// <param name="accessibility">Filter accepts undefined, easy, moderate or difficult (optional)</param>
        /// <param name="nodeId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all objects with no nodes assigned or \&quot;!null\&quot; for any assigned node.  By adding &#x60;+&#x60; after the id, the filter considers the given node and all its sub components but this is not usable in combination with a comma list. (optional)</param>
        /// <param name="assetId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all objects with no assets assigned or \&quot;!null\&quot; for any assigned asset (optional)</param>
        /// <param name="systemId">One or multiple ids (comma list). Filter accepts \&quot;null\&quot; for all objects with no systems assigned or \&quot;!null\&quot; for any assigned system (optional)</param>
        /// <param name="assetStatusId">One or multiple ids (comma list). Expected id format is integer. This retrieves all Instrumentations where at least one of its assets has one of the given statuses. (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;tag&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>InstrumentationsResponse</returns>
        public InstrumentationsResponse GetInstrumentations (int? page = null, int? perPage = null, string include = null, string tag = null, string statusId = null, string typeId = null, string parentId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string criticality = null, string accessibility = null, string nodeId = null, string assetId = null, string systemId = null, string assetStatusId = null, string permission = null, string orderBy = null)
        {
             ApiResponse<InstrumentationsResponse> localVarResponse = GetInstrumentationsWithHttpInfo(page, perPage, include, tag, statusId, typeId, parentId, tenantId, specificationsKey, specificationsValue, criticality, accessibility, nodeId, assetId, systemId, assetStatusId, permission, orderBy);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get a range of instrumentations Returns a list of instrumentations in your accessible scope. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;specifications, specifications[key1,key2], pictures, tenant, parent, status, worst_asset_status, type, type.tenant, type.parent, values, values.unit, values_in_preferred_units, values_in_preferred_units.unit&#x60;&#x60;&#x60; 
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="tag">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="criticality">Filter accepts undefined, low, medium or high (optional)</param>
        /// <param name="accessibility">Filter accepts undefined, easy, moderate or difficult (optional)</param>
        /// <param name="nodeId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all objects with no nodes assigned or \&quot;!null\&quot; for any assigned node.  By adding &#x60;+&#x60; after the id, the filter considers the given node and all its sub components but this is not usable in combination with a comma list. (optional)</param>
        /// <param name="assetId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all objects with no assets assigned or \&quot;!null\&quot; for any assigned asset (optional)</param>
        /// <param name="systemId">One or multiple ids (comma list). Filter accepts \&quot;null\&quot; for all objects with no systems assigned or \&quot;!null\&quot; for any assigned system (optional)</param>
        /// <param name="assetStatusId">One or multiple ids (comma list). Expected id format is integer. This retrieves all Instrumentations where at least one of its assets has one of the given statuses. (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;tag&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of InstrumentationsResponse</returns>
        public ApiResponse< InstrumentationsResponse > GetInstrumentationsWithHttpInfo (int? page = null, int? perPage = null, string include = null, string tag = null, string statusId = null, string typeId = null, string parentId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string criticality = null, string accessibility = null, string nodeId = null, string assetId = null, string systemId = null, string assetStatusId = null, string permission = null, string orderBy = null)
        {

            var localVarPath = "/instrumentations";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (tag != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tag", tag)); // query parameter
            if (statusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_id", statusId)); // query parameter
            if (typeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type_id", typeId)); // query parameter
            if (parentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "parent_id", parentId)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (specificationsKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_key", specificationsKey)); // query parameter
            if (specificationsValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_value", specificationsValue)); // query parameter
            if (criticality != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "criticality", criticality)); // query parameter
            if (accessibility != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "accessibility", accessibility)); // query parameter
            if (nodeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "node_id", nodeId)); // query parameter
            if (assetId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asset_id", assetId)); // query parameter
            if (systemId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "system_id", systemId)); // query parameter
            if (assetStatusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asset_status_id", assetStatusId)); // query parameter
            if (permission != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "permission", permission)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetInstrumentations", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InstrumentationsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InstrumentationsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InstrumentationsResponse)));
        }

        /// <summary>
        /// Get a range of instrumentations Returns a list of instrumentations in your accessible scope. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;specifications, specifications[key1,key2], pictures, tenant, parent, status, worst_asset_status, type, type.tenant, type.parent, values, values.unit, values_in_preferred_units, values_in_preferred_units.unit&#x60;&#x60;&#x60; 
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="tag">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="criticality">Filter accepts undefined, low, medium or high (optional)</param>
        /// <param name="accessibility">Filter accepts undefined, easy, moderate or difficult (optional)</param>
        /// <param name="nodeId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all objects with no nodes assigned or \&quot;!null\&quot; for any assigned node.  By adding &#x60;+&#x60; after the id, the filter considers the given node and all its sub components but this is not usable in combination with a comma list. (optional)</param>
        /// <param name="assetId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all objects with no assets assigned or \&quot;!null\&quot; for any assigned asset (optional)</param>
        /// <param name="systemId">One or multiple ids (comma list). Filter accepts \&quot;null\&quot; for all objects with no systems assigned or \&quot;!null\&quot; for any assigned system (optional)</param>
        /// <param name="assetStatusId">One or multiple ids (comma list). Expected id format is integer. This retrieves all Instrumentations where at least one of its assets has one of the given statuses. (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;tag&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of InstrumentationsResponse</returns>
        public async System.Threading.Tasks.Task<InstrumentationsResponse> GetInstrumentationsAsync (int? page = null, int? perPage = null, string include = null, string tag = null, string statusId = null, string typeId = null, string parentId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string criticality = null, string accessibility = null, string nodeId = null, string assetId = null, string systemId = null, string assetStatusId = null, string permission = null, string orderBy = null)
        {
             ApiResponse<InstrumentationsResponse> localVarResponse = await GetInstrumentationsAsyncWithHttpInfo(page, perPage, include, tag, statusId, typeId, parentId, tenantId, specificationsKey, specificationsValue, criticality, accessibility, nodeId, assetId, systemId, assetStatusId, permission, orderBy);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get a range of instrumentations Returns a list of instrumentations in your accessible scope. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;specifications, specifications[key1,key2], pictures, tenant, parent, status, worst_asset_status, type, type.tenant, type.parent, values, values.unit, values_in_preferred_units, values_in_preferred_units.unit&#x60;&#x60;&#x60; 
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="tag">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="criticality">Filter accepts undefined, low, medium or high (optional)</param>
        /// <param name="accessibility">Filter accepts undefined, easy, moderate or difficult (optional)</param>
        /// <param name="nodeId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all objects with no nodes assigned or \&quot;!null\&quot; for any assigned node.  By adding &#x60;+&#x60; after the id, the filter considers the given node and all its sub components but this is not usable in combination with a comma list. (optional)</param>
        /// <param name="assetId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all objects with no assets assigned or \&quot;!null\&quot; for any assigned asset (optional)</param>
        /// <param name="systemId">One or multiple ids (comma list). Filter accepts \&quot;null\&quot; for all objects with no systems assigned or \&quot;!null\&quot; for any assigned system (optional)</param>
        /// <param name="assetStatusId">One or multiple ids (comma list). Expected id format is integer. This retrieves all Instrumentations where at least one of its assets has one of the given statuses. (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;tag&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (InstrumentationsResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InstrumentationsResponse>> GetInstrumentationsAsyncWithHttpInfo (int? page = null, int? perPage = null, string include = null, string tag = null, string statusId = null, string typeId = null, string parentId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string criticality = null, string accessibility = null, string nodeId = null, string assetId = null, string systemId = null, string assetStatusId = null, string permission = null, string orderBy = null)
        {

            var localVarPath = "/instrumentations";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (tag != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tag", tag)); // query parameter
            if (statusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_id", statusId)); // query parameter
            if (typeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type_id", typeId)); // query parameter
            if (parentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "parent_id", parentId)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (specificationsKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_key", specificationsKey)); // query parameter
            if (specificationsValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_value", specificationsValue)); // query parameter
            if (criticality != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "criticality", criticality)); // query parameter
            if (accessibility != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "accessibility", accessibility)); // query parameter
            if (nodeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "node_id", nodeId)); // query parameter
            if (assetId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asset_id", assetId)); // query parameter
            if (systemId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "system_id", systemId)); // query parameter
            if (assetStatusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asset_status_id", assetStatusId)); // query parameter
            if (permission != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "permission", permission)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetInstrumentations", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InstrumentationsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InstrumentationsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InstrumentationsResponse)));
        }

        /// <summary>
        /// Get all nodes of one Instrumentation Returns a list of all nodes that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="hidden">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>NodesResponse</returns>
        public NodesResponse GetNodesOfInstrumentation (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string parentId = null, string tenantId = null, bool? hidden = null, string permission = null, string orderBy = null)
        {
             ApiResponse<NodesResponse> localVarResponse = GetNodesOfInstrumentationWithHttpInfo(instrumentationId, page, perPage, include, name, typeId, parentId, tenantId, hidden, permission, orderBy);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get all nodes of one Instrumentation Returns a list of all nodes that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="hidden">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of NodesResponse</returns>
        public ApiResponse< NodesResponse > GetNodesOfInstrumentationWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string parentId = null, string tenantId = null, bool? hidden = null, string permission = null, string orderBy = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetNodesOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/nodes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (typeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type_id", typeId)); // query parameter
            if (parentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "parent_id", parentId)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (hidden != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "hidden", hidden)); // query parameter
            if (permission != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "permission", permission)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetNodesOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<NodesResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (NodesResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(NodesResponse)));
        }

        /// <summary>
        /// Get all nodes of one Instrumentation Returns a list of all nodes that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="hidden">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of NodesResponse</returns>
        public async System.Threading.Tasks.Task<NodesResponse> GetNodesOfInstrumentationAsync (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string parentId = null, string tenantId = null, bool? hidden = null, string permission = null, string orderBy = null)
        {
             ApiResponse<NodesResponse> localVarResponse = await GetNodesOfInstrumentationAsyncWithHttpInfo(instrumentationId, page, perPage, include, name, typeId, parentId, tenantId, hidden, permission, orderBy);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get all nodes of one Instrumentation Returns a list of all nodes that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="hidden">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (NodesResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<NodesResponse>> GetNodesOfInstrumentationAsyncWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string parentId = null, string tenantId = null, bool? hidden = null, string permission = null, string orderBy = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetNodesOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/nodes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (typeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type_id", typeId)); // query parameter
            if (parentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "parent_id", parentId)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (hidden != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "hidden", hidden)); // query parameter
            if (permission != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "permission", permission)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetNodesOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<NodesResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (NodesResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(NodesResponse)));
        }

        /// <summary>
        /// Get the history of one specification attribute of an instrumentation. This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>SpecificationHistoryResponse</returns>
        public SpecificationHistoryResponse GetSpecificationHistoryOfInstrumentation (long? instrumentationId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null)
        {
             ApiResponse<SpecificationHistoryResponse> localVarResponse = GetSpecificationHistoryOfInstrumentationWithHttpInfo(instrumentationId, key, page, perPage, sourceTimestampFrom, sourceTimestampTo, updatedAtFrom, updatedAtTo, orderBy);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get the history of one specification attribute of an instrumentation. This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>ApiResponse of SpecificationHistoryResponse</returns>
        public ApiResponse< SpecificationHistoryResponse > GetSpecificationHistoryOfInstrumentationWithHttpInfo (long? instrumentationId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetSpecificationHistoryOfInstrumentation");
            // verify the required parameter 'key' is set
            if (key == null)
                throw new ApiException(400, "Missing required parameter 'key' when calling InstrumentationApi->GetSpecificationHistoryOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/specifications/{key}/history";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (key != null) localVarPathParams.Add("key", this.Configuration.ApiClient.ParameterToString(key)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (sourceTimestampFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "source_timestamp_from", sourceTimestampFrom)); // query parameter
            if (sourceTimestampTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "source_timestamp_to", sourceTimestampTo)); // query parameter
            if (updatedAtFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_from", updatedAtFrom)); // query parameter
            if (updatedAtTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_to", updatedAtTo)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationHistoryOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationHistoryResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationHistoryResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationHistoryResponse)));
        }

        /// <summary>
        /// Get the history of one specification attribute of an instrumentation. This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>Task of SpecificationHistoryResponse</returns>
        public async System.Threading.Tasks.Task<SpecificationHistoryResponse> GetSpecificationHistoryOfInstrumentationAsync (long? instrumentationId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null)
        {
             ApiResponse<SpecificationHistoryResponse> localVarResponse = await GetSpecificationHistoryOfInstrumentationAsyncWithHttpInfo(instrumentationId, key, page, perPage, sourceTimestampFrom, sourceTimestampTo, updatedAtFrom, updatedAtTo, orderBy);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get the history of one specification attribute of an instrumentation. This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationHistoryResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SpecificationHistoryResponse>> GetSpecificationHistoryOfInstrumentationAsyncWithHttpInfo (long? instrumentationId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetSpecificationHistoryOfInstrumentation");
            // verify the required parameter 'key' is set
            if (key == null)
                throw new ApiException(400, "Missing required parameter 'key' when calling InstrumentationApi->GetSpecificationHistoryOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/specifications/{key}/history";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (key != null) localVarPathParams.Add("key", this.Configuration.ApiClient.ParameterToString(key)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (sourceTimestampFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "source_timestamp_from", sourceTimestampFrom)); // query parameter
            if (sourceTimestampTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "source_timestamp_to", sourceTimestampTo)); // query parameter
            if (updatedAtFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_from", updatedAtFrom)); // query parameter
            if (updatedAtTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_to", updatedAtTo)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationHistoryOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationHistoryResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationHistoryResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationHistoryResponse)));
        }

        /// <summary>
        /// Get existing instrumentation specification keys Returns the existing specification keys in all readable instrumentations.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>SpecificationKeys</returns>
        public SpecificationKeys GetSpecificationKeysOfInstrumentations (string key = null, bool? uiVisible = null)
        {
             ApiResponse<SpecificationKeys> localVarResponse = GetSpecificationKeysOfInstrumentationsWithHttpInfo(key, uiVisible);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get existing instrumentation specification keys Returns the existing specification keys in all readable instrumentations.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>ApiResponse of SpecificationKeys</returns>
        public ApiResponse< SpecificationKeys > GetSpecificationKeysOfInstrumentationsWithHttpInfo (string key = null, bool? uiVisible = null)
        {

            var localVarPath = "/instrumentation/specification_keys";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            if (uiVisible != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ui_visible", uiVisible)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationKeysOfInstrumentations", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationKeys>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationKeys) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationKeys)));
        }

        /// <summary>
        /// Get existing instrumentation specification keys Returns the existing specification keys in all readable instrumentations.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of SpecificationKeys</returns>
        public async System.Threading.Tasks.Task<SpecificationKeys> GetSpecificationKeysOfInstrumentationsAsync (string key = null, bool? uiVisible = null)
        {
             ApiResponse<SpecificationKeys> localVarResponse = await GetSpecificationKeysOfInstrumentationsAsyncWithHttpInfo(key, uiVisible);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get existing instrumentation specification keys Returns the existing specification keys in all readable instrumentations.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationKeys)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SpecificationKeys>> GetSpecificationKeysOfInstrumentationsAsyncWithHttpInfo (string key = null, bool? uiVisible = null)
        {

            var localVarPath = "/instrumentation/specification_keys";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            if (uiVisible != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ui_visible", uiVisible)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationKeysOfInstrumentations", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationKeys>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationKeys) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationKeys)));
        }

        /// <summary>
        /// Get specifications of an instrumentation Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>SpecificationsUIVisibleResponse</returns>
        public SpecificationsUIVisibleResponse GetSpecificationsOfInstrumentation (long? instrumentationId, string key = null, bool? uiVisible = null)
        {
             ApiResponse<SpecificationsUIVisibleResponse> localVarResponse = GetSpecificationsOfInstrumentationWithHttpInfo(instrumentationId, key, uiVisible);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get specifications of an instrumentation Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>ApiResponse of SpecificationsUIVisibleResponse</returns>
        public ApiResponse< SpecificationsUIVisibleResponse > GetSpecificationsOfInstrumentationWithHttpInfo (long? instrumentationId, string key = null, bool? uiVisible = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetSpecificationsOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            if (uiVisible != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ui_visible", uiVisible)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationsOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationsUIVisibleResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationsUIVisibleResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationsUIVisibleResponse)));
        }

        /// <summary>
        /// Get specifications of an instrumentation Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of SpecificationsUIVisibleResponse</returns>
        public async System.Threading.Tasks.Task<SpecificationsUIVisibleResponse> GetSpecificationsOfInstrumentationAsync (long? instrumentationId, string key = null, bool? uiVisible = null)
        {
             ApiResponse<SpecificationsUIVisibleResponse> localVarResponse = await GetSpecificationsOfInstrumentationAsyncWithHttpInfo(instrumentationId, key, uiVisible);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get specifications of an instrumentation Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationsUIVisibleResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SpecificationsUIVisibleResponse>> GetSpecificationsOfInstrumentationAsyncWithHttpInfo (long? instrumentationId, string key = null, bool? uiVisible = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetSpecificationsOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            if (uiVisible != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ui_visible", uiVisible)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationsOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationsUIVisibleResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationsUIVisibleResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationsUIVisibleResponse)));
        }

        /// <summary>
        /// Get all systems of one instrumentation Returns a list of all systems that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;pictures, specifications, specifications[key1,key2], tenant, parent, status, type, type.tenant, type.parent &#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>SystemsResponse</returns>
        public SystemsResponse GetSystemsOfInstrumentation (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string statusId = null, string typeId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string permission = null, string orderBy = null)
        {
             ApiResponse<SystemsResponse> localVarResponse = GetSystemsOfInstrumentationWithHttpInfo(instrumentationId, page, perPage, include, name, statusId, typeId, tenantId, specificationsKey, specificationsValue, permission, orderBy);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get all systems of one instrumentation Returns a list of all systems that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;pictures, specifications, specifications[key1,key2], tenant, parent, status, type, type.tenant, type.parent &#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of SystemsResponse</returns>
        public ApiResponse< SystemsResponse > GetSystemsOfInstrumentationWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string statusId = null, string typeId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string permission = null, string orderBy = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetSystemsOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/systems";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (statusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_id", statusId)); // query parameter
            if (typeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type_id", typeId)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (specificationsKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_key", specificationsKey)); // query parameter
            if (specificationsValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_value", specificationsValue)); // query parameter
            if (permission != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "permission", permission)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSystemsOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SystemsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SystemsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SystemsResponse)));
        }

        /// <summary>
        /// Get all systems of one instrumentation Returns a list of all systems that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;pictures, specifications, specifications[key1,key2], tenant, parent, status, type, type.tenant, type.parent &#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of SystemsResponse</returns>
        public async System.Threading.Tasks.Task<SystemsResponse> GetSystemsOfInstrumentationAsync (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string statusId = null, string typeId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string permission = null, string orderBy = null)
        {
             ApiResponse<SystemsResponse> localVarResponse = await GetSystemsOfInstrumentationAsyncWithHttpInfo(instrumentationId, page, perPage, include, name, statusId, typeId, tenantId, specificationsKey, specificationsValue, permission, orderBy);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get all systems of one instrumentation Returns a list of all systems that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;pictures, specifications, specifications[key1,key2], tenant, parent, status, type, type.tenant, type.parent &#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (SystemsResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SystemsResponse>> GetSystemsOfInstrumentationAsyncWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string statusId = null, string typeId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string permission = null, string orderBy = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->GetSystemsOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/systems";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (statusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_id", statusId)); // query parameter
            if (typeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type_id", typeId)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (specificationsKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_key", specificationsKey)); // query parameter
            if (specificationsValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_value", specificationsValue)); // query parameter
            if (permission != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "permission", permission)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSystemsOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SystemsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SystemsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SystemsResponse)));
        }

        /// <summary>
        /// Remove assets from an instrumentation Remove one or more assets from an instrumentation in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the asset.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the assets will be removed</param>
        /// <returns></returns>
        public void RemoveAssetsFromInstrumentation (AssetIDs body, long? instrumentationId)
        {
             RemoveAssetsFromInstrumentationWithHttpInfo(body, instrumentationId);
        }

        /// <summary>
        /// Remove assets from an instrumentation Remove one or more assets from an instrumentation in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the asset.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the assets will be removed</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RemoveAssetsFromInstrumentationWithHttpInfo (AssetIDs body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->RemoveAssetsFromInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->RemoveAssetsFromInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/assets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveAssetsFromInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Remove assets from an instrumentation Remove one or more assets from an instrumentation in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the asset.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the assets will be removed</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveAssetsFromInstrumentationAsync (AssetIDs body, long? instrumentationId)
        {
             await RemoveAssetsFromInstrumentationAsyncWithHttpInfo(body, instrumentationId);

        }

        /// <summary>
        /// Remove assets from an instrumentation Remove one or more assets from an instrumentation in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the asset.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the assets will be removed</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RemoveAssetsFromInstrumentationAsyncWithHttpInfo (AssetIDs body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->RemoveAssetsFromInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->RemoveAssetsFromInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/assets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveAssetsFromInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Remove bill of materials from an instrumentation Remove one or more bill of materials from an instrumentation in your accessible scope.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the bill of materials will be removed</param>
        /// <returns></returns>
        public void RemoveBillOfMaterialsFromInstrumentation (BillOfMaterialIDs body, long? instrumentationId)
        {
             RemoveBillOfMaterialsFromInstrumentationWithHttpInfo(body, instrumentationId);
        }

        /// <summary>
        /// Remove bill of materials from an instrumentation Remove one or more bill of materials from an instrumentation in your accessible scope.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the bill of materials will be removed</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RemoveBillOfMaterialsFromInstrumentationWithHttpInfo (BillOfMaterialIDs body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->RemoveBillOfMaterialsFromInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->RemoveBillOfMaterialsFromInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/bill_of_materials";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveBillOfMaterialsFromInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Remove bill of materials from an instrumentation Remove one or more bill of materials from an instrumentation in your accessible scope.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the bill of materials will be removed</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveBillOfMaterialsFromInstrumentationAsync (BillOfMaterialIDs body, long? instrumentationId)
        {
             await RemoveBillOfMaterialsFromInstrumentationAsyncWithHttpInfo(body, instrumentationId);

        }

        /// <summary>
        /// Remove bill of materials from an instrumentation Remove one or more bill of materials from an instrumentation in your accessible scope.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the bill of materials will be removed</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RemoveBillOfMaterialsFromInstrumentationAsyncWithHttpInfo (BillOfMaterialIDs body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->RemoveBillOfMaterialsFromInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->RemoveBillOfMaterialsFromInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/bill_of_materials";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveBillOfMaterialsFromInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Remove documents from an instrumentation Remove one or more documents from an instrumentation. This action requires &#x60;can_update&#x60; permission on the instrumentation and &#x60;can_read&#x60; permission on the document.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the documents will be removed</param>
        /// <returns></returns>
        public void RemoveDocumentsFromInstrumentation (DocumentIDs body, long? instrumentationId)
        {
             RemoveDocumentsFromInstrumentationWithHttpInfo(body, instrumentationId);
        }

        /// <summary>
        /// Remove documents from an instrumentation Remove one or more documents from an instrumentation. This action requires &#x60;can_update&#x60; permission on the instrumentation and &#x60;can_read&#x60; permission on the document.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the documents will be removed</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RemoveDocumentsFromInstrumentationWithHttpInfo (DocumentIDs body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->RemoveDocumentsFromInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->RemoveDocumentsFromInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/documents";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveDocumentsFromInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Remove documents from an instrumentation Remove one or more documents from an instrumentation. This action requires &#x60;can_update&#x60; permission on the instrumentation and &#x60;can_read&#x60; permission on the document.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the documents will be removed</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveDocumentsFromInstrumentationAsync (DocumentIDs body, long? instrumentationId)
        {
             await RemoveDocumentsFromInstrumentationAsyncWithHttpInfo(body, instrumentationId);

        }

        /// <summary>
        /// Remove documents from an instrumentation Remove one or more documents from an instrumentation. This action requires &#x60;can_update&#x60; permission on the instrumentation and &#x60;can_read&#x60; permission on the document.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the documents will be removed</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RemoveDocumentsFromInstrumentationAsyncWithHttpInfo (DocumentIDs body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->RemoveDocumentsFromInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->RemoveDocumentsFromInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/documents";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveDocumentsFromInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Remove events from an instrumentation Remove one or more events from an instrumentation in your accessible scope. If the event has no more related instrumentations, the event will be deleted
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the events will removed.</param>
        /// <returns></returns>
        public void RemoveEventFromInstrumentation (Events1 body, long? instrumentationId)
        {
             RemoveEventFromInstrumentationWithHttpInfo(body, instrumentationId);
        }

        /// <summary>
        /// Remove events from an instrumentation Remove one or more events from an instrumentation in your accessible scope. If the event has no more related instrumentations, the event will be deleted
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the events will removed.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RemoveEventFromInstrumentationWithHttpInfo (Events1 body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->RemoveEventFromInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->RemoveEventFromInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/events";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveEventFromInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Remove events from an instrumentation Remove one or more events from an instrumentation in your accessible scope. If the event has no more related instrumentations, the event will be deleted
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the events will removed.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveEventFromInstrumentationAsync (Events1 body, long? instrumentationId)
        {
             await RemoveEventFromInstrumentationAsyncWithHttpInfo(body, instrumentationId);

        }

        /// <summary>
        /// Remove events from an instrumentation Remove one or more events from an instrumentation in your accessible scope. If the event has no more related instrumentations, the event will be deleted
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the events will removed.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RemoveEventFromInstrumentationAsyncWithHttpInfo (Events1 body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->RemoveEventFromInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->RemoveEventFromInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/events";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveEventFromInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Remove nodes from an instrumentation Remove one or more nodes from an instrumentation in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the node.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the nodes will be removed</param>
        /// <returns></returns>
        public void RemoveNodesFromInstrumentation (NodeIDs body, long? instrumentationId)
        {
             RemoveNodesFromInstrumentationWithHttpInfo(body, instrumentationId);
        }

        /// <summary>
        /// Remove nodes from an instrumentation Remove one or more nodes from an instrumentation in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the node.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the nodes will be removed</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RemoveNodesFromInstrumentationWithHttpInfo (NodeIDs body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->RemoveNodesFromInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->RemoveNodesFromInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/nodes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveNodesFromInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Remove nodes from an instrumentation Remove one or more nodes from an instrumentation in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the node.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the nodes will be removed</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveNodesFromInstrumentationAsync (NodeIDs body, long? instrumentationId)
        {
             await RemoveNodesFromInstrumentationAsyncWithHttpInfo(body, instrumentationId);

        }

        /// <summary>
        /// Remove nodes from an instrumentation Remove one or more nodes from an instrumentation in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the node.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the nodes will be removed</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RemoveNodesFromInstrumentationAsyncWithHttpInfo (NodeIDs body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->RemoveNodesFromInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->RemoveNodesFromInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/nodes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveNodesFromInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete specifications of an instrumentation The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns></returns>
        public void RemoveSpecificationsFromInstrumentation (List<string> body, long? instrumentationId)
        {
             RemoveSpecificationsFromInstrumentationWithHttpInfo(body, instrumentationId);
        }

        /// <summary>
        /// Delete specifications of an instrumentation The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RemoveSpecificationsFromInstrumentationWithHttpInfo (List<string> body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->RemoveSpecificationsFromInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->RemoveSpecificationsFromInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveSpecificationsFromInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete specifications of an instrumentation The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveSpecificationsFromInstrumentationAsync (List<string> body, long? instrumentationId)
        {
             await RemoveSpecificationsFromInstrumentationAsyncWithHttpInfo(body, instrumentationId);

        }

        /// <summary>
        /// Delete specifications of an instrumentation The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RemoveSpecificationsFromInstrumentationAsyncWithHttpInfo (List<string> body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->RemoveSpecificationsFromInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->RemoveSpecificationsFromInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveSpecificationsFromInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of an instrumentation in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns></returns>
        public void RenameSpecificationsOfInstrumentation (SpecificationsRename body, long? instrumentationId)
        {
             RenameSpecificationsOfInstrumentationWithHttpInfo(body, instrumentationId);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of an instrumentation in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RenameSpecificationsOfInstrumentationWithHttpInfo (SpecificationsRename body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->RenameSpecificationsOfInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->RenameSpecificationsOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/specifications/rename";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RenameSpecificationsOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of an instrumentation in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RenameSpecificationsOfInstrumentationAsync (SpecificationsRename body, long? instrumentationId)
        {
             await RenameSpecificationsOfInstrumentationAsyncWithHttpInfo(body, instrumentationId);

        }

        /// <summary>
        /// Rename a specification key Rename one specification key of an instrumentation in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RenameSpecificationsOfInstrumentationAsyncWithHttpInfo (SpecificationsRename body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->RenameSpecificationsOfInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->RenameSpecificationsOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/specifications/rename";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RenameSpecificationsOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Replace the assets of an instrumentation Replaces all assets belonging to an instrumentation. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the asset.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="instrumentationId">Id of the instrumentation of which the assets will be replaced</param>
        /// <returns></returns>
        public void ReplaceAssetsOfInstrumentation (AssetIDs body, long? instrumentationId)
        {
             ReplaceAssetsOfInstrumentationWithHttpInfo(body, instrumentationId);
        }

        /// <summary>
        /// Replace the assets of an instrumentation Replaces all assets belonging to an instrumentation. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the asset.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="instrumentationId">Id of the instrumentation of which the assets will be replaced</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReplaceAssetsOfInstrumentationWithHttpInfo (AssetIDs body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->ReplaceAssetsOfInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->ReplaceAssetsOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/assets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceAssetsOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Replace the assets of an instrumentation Replaces all assets belonging to an instrumentation. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the asset.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="instrumentationId">Id of the instrumentation of which the assets will be replaced</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task ReplaceAssetsOfInstrumentationAsync (AssetIDs body, long? instrumentationId)
        {
             await ReplaceAssetsOfInstrumentationAsyncWithHttpInfo(body, instrumentationId);

        }

        /// <summary>
        /// Replace the assets of an instrumentation Replaces all assets belonging to an instrumentation. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the asset.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="instrumentationId">Id of the instrumentation of which the assets will be replaced</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> ReplaceAssetsOfInstrumentationAsyncWithHttpInfo (AssetIDs body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->ReplaceAssetsOfInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->ReplaceAssetsOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/assets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceAssetsOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Replace the bill of materials of an instrumentation Replaces all bill of materials belonging to an instrumentation. You can send a list of resources that will replace all previous values.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="instrumentationId">Id of the instrumentation of which the bill of materials will be replaced</param>
        /// <returns></returns>
        public void ReplaceBillOfMaterialsOfInstrumentation (BillOfMaterialIDs body, long? instrumentationId)
        {
             ReplaceBillOfMaterialsOfInstrumentationWithHttpInfo(body, instrumentationId);
        }

        /// <summary>
        /// Replace the bill of materials of an instrumentation Replaces all bill of materials belonging to an instrumentation. You can send a list of resources that will replace all previous values.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="instrumentationId">Id of the instrumentation of which the bill of materials will be replaced</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReplaceBillOfMaterialsOfInstrumentationWithHttpInfo (BillOfMaterialIDs body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->ReplaceBillOfMaterialsOfInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->ReplaceBillOfMaterialsOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/bill_of_materials";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceBillOfMaterialsOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Replace the bill of materials of an instrumentation Replaces all bill of materials belonging to an instrumentation. You can send a list of resources that will replace all previous values.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="instrumentationId">Id of the instrumentation of which the bill of materials will be replaced</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task ReplaceBillOfMaterialsOfInstrumentationAsync (BillOfMaterialIDs body, long? instrumentationId)
        {
             await ReplaceBillOfMaterialsOfInstrumentationAsyncWithHttpInfo(body, instrumentationId);

        }

        /// <summary>
        /// Replace the bill of materials of an instrumentation Replaces all bill of materials belonging to an instrumentation. You can send a list of resources that will replace all previous values.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="instrumentationId">Id of the instrumentation of which the bill of materials will be replaced</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> ReplaceBillOfMaterialsOfInstrumentationAsyncWithHttpInfo (BillOfMaterialIDs body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->ReplaceBillOfMaterialsOfInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->ReplaceBillOfMaterialsOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/bill_of_materials";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceBillOfMaterialsOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Replace the documents of an instrumentation Replaces all documents belonging to an instrumentation. You can send a list of resources that will replace all previous values. This action requires &#x60;can_udpate&#x60; permission on the instrumentation and &#x60;can_read&#x60; permission on the document.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="instrumentationId">Id of the instrumentation of which the documents will be replaced</param>
        /// <returns></returns>
        public void ReplaceDocumentsOfInstrumentation (DocumentIDs body, long? instrumentationId)
        {
             ReplaceDocumentsOfInstrumentationWithHttpInfo(body, instrumentationId);
        }

        /// <summary>
        /// Replace the documents of an instrumentation Replaces all documents belonging to an instrumentation. You can send a list of resources that will replace all previous values. This action requires &#x60;can_udpate&#x60; permission on the instrumentation and &#x60;can_read&#x60; permission on the document.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="instrumentationId">Id of the instrumentation of which the documents will be replaced</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReplaceDocumentsOfInstrumentationWithHttpInfo (DocumentIDs body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->ReplaceDocumentsOfInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->ReplaceDocumentsOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/documents";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceDocumentsOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Replace the documents of an instrumentation Replaces all documents belonging to an instrumentation. You can send a list of resources that will replace all previous values. This action requires &#x60;can_udpate&#x60; permission on the instrumentation and &#x60;can_read&#x60; permission on the document.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="instrumentationId">Id of the instrumentation of which the documents will be replaced</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task ReplaceDocumentsOfInstrumentationAsync (DocumentIDs body, long? instrumentationId)
        {
             await ReplaceDocumentsOfInstrumentationAsyncWithHttpInfo(body, instrumentationId);

        }

        /// <summary>
        /// Replace the documents of an instrumentation Replaces all documents belonging to an instrumentation. You can send a list of resources that will replace all previous values. This action requires &#x60;can_udpate&#x60; permission on the instrumentation and &#x60;can_read&#x60; permission on the document.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="instrumentationId">Id of the instrumentation of which the documents will be replaced</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> ReplaceDocumentsOfInstrumentationAsyncWithHttpInfo (DocumentIDs body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->ReplaceDocumentsOfInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->ReplaceDocumentsOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/documents";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceDocumentsOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Replace the nodes of an instrumentation Replaces all nodes belonging to an instrumentation in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the node.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="instrumentationId">Id of the instrumentation of which the nodes will be replaced</param>
        /// <returns></returns>
        public void ReplaceNodesOfInstrumentation (NodeIDs body, long? instrumentationId)
        {
             ReplaceNodesOfInstrumentationWithHttpInfo(body, instrumentationId);
        }

        /// <summary>
        /// Replace the nodes of an instrumentation Replaces all nodes belonging to an instrumentation in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the node.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="instrumentationId">Id of the instrumentation of which the nodes will be replaced</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReplaceNodesOfInstrumentationWithHttpInfo (NodeIDs body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->ReplaceNodesOfInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->ReplaceNodesOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/nodes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNodesOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Replace the nodes of an instrumentation Replaces all nodes belonging to an instrumentation in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the node.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="instrumentationId">Id of the instrumentation of which the nodes will be replaced</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task ReplaceNodesOfInstrumentationAsync (NodeIDs body, long? instrumentationId)
        {
             await ReplaceNodesOfInstrumentationAsyncWithHttpInfo(body, instrumentationId);

        }

        /// <summary>
        /// Replace the nodes of an instrumentation Replaces all nodes belonging to an instrumentation in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the instrumentation and on the node.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="instrumentationId">Id of the instrumentation of which the nodes will be replaced</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> ReplaceNodesOfInstrumentationAsyncWithHttpInfo (NodeIDs body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->ReplaceNodesOfInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->ReplaceNodesOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/nodes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceNodesOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update an instrumentation Update accessible parameters of the requested resource in your accessible scope. To assign a parent instrumentation the user needs &#x60;can_permit&#x60; permission on the parent and on the current instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the instrumentation to update</param>
        /// <returns></returns>
        public void UpdateInstrumentation (InstrumentationRequest body, long? id)
        {
             UpdateInstrumentationWithHttpInfo(body, id);
        }

        /// <summary>
        /// Update an instrumentation Update accessible parameters of the requested resource in your accessible scope. To assign a parent instrumentation the user needs &#x60;can_permit&#x60; permission on the parent and on the current instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the instrumentation to update</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateInstrumentationWithHttpInfo (InstrumentationRequest body, long? id)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->UpdateInstrumentation");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling InstrumentationApi->UpdateInstrumentation");

            var localVarPath = "/instrumentations/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update an instrumentation Update accessible parameters of the requested resource in your accessible scope. To assign a parent instrumentation the user needs &#x60;can_permit&#x60; permission on the parent and on the current instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the instrumentation to update</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UpdateInstrumentationAsync (InstrumentationRequest body, long? id)
        {
             await UpdateInstrumentationAsyncWithHttpInfo(body, id);

        }

        /// <summary>
        /// Update an instrumentation Update accessible parameters of the requested resource in your accessible scope. To assign a parent instrumentation the user needs &#x60;can_permit&#x60; permission on the parent and on the current instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the instrumentation to update</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> UpdateInstrumentationAsyncWithHttpInfo (InstrumentationRequest body, long? id)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->UpdateInstrumentation");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling InstrumentationApi->UpdateInstrumentation");

            var localVarPath = "/instrumentations/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update an instrumentation picture Upload a new instrumentation picture. Check the file-storage quota. Allowed content-types are - image/gif - image/jpg - image/jpeg - image/png
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="image"></param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>PictureResponse</returns>
        public PictureResponse UpdateInstrumentationPicture (byte[] image, long? instrumentationId, long? id)
        {
             ApiResponse<PictureResponse> localVarResponse = UpdateInstrumentationPictureWithHttpInfo(image, instrumentationId, id);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Update an instrumentation picture Upload a new instrumentation picture. Check the file-storage quota. Allowed content-types are - image/gif - image/jpg - image/jpeg - image/png
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="image"></param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>ApiResponse of PictureResponse</returns>
        public ApiResponse< PictureResponse > UpdateInstrumentationPictureWithHttpInfo (byte[] image, long? instrumentationId, long? id)
        {
            // verify the required parameter 'image' is set
            if (image == null)
                throw new ApiException(400, "Missing required parameter 'image' when calling InstrumentationApi->UpdateInstrumentationPicture");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->UpdateInstrumentationPicture");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling InstrumentationApi->UpdateInstrumentationPicture");

            var localVarPath = "/instrumentations/{instrumentation_id}/pictures/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "multipart/form-data"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (image != null) localVarFileParams.Add("image", this.Configuration.ApiClient.ParameterToFile("image", image));
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateInstrumentationPicture", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PictureResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (PictureResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(PictureResponse)));
        }

        /// <summary>
        /// Update an instrumentation picture Upload a new instrumentation picture. Check the file-storage quota. Allowed content-types are - image/gif - image/jpg - image/jpeg - image/png
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="image"></param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>Task of PictureResponse</returns>
        public async System.Threading.Tasks.Task<PictureResponse> UpdateInstrumentationPictureAsync (byte[] image, long? instrumentationId, long? id)
        {
             ApiResponse<PictureResponse> localVarResponse = await UpdateInstrumentationPictureAsyncWithHttpInfo(image, instrumentationId, id);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Update an instrumentation picture Upload a new instrumentation picture. Check the file-storage quota. Allowed content-types are - image/gif - image/jpg - image/jpeg - image/png
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="image"></param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>Task of ApiResponse (PictureResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<PictureResponse>> UpdateInstrumentationPictureAsyncWithHttpInfo (byte[] image, long? instrumentationId, long? id)
        {
            // verify the required parameter 'image' is set
            if (image == null)
                throw new ApiException(400, "Missing required parameter 'image' when calling InstrumentationApi->UpdateInstrumentationPicture");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->UpdateInstrumentationPicture");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling InstrumentationApi->UpdateInstrumentationPicture");

            var localVarPath = "/instrumentations/{instrumentation_id}/pictures/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "multipart/form-data"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (image != null) localVarFileParams.Add("image", this.Configuration.ApiClient.ParameterToFile("image", image));
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateInstrumentationPicture", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PictureResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (PictureResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(PictureResponse)));
        }

        /// <summary>
        /// Update an instrumentation picture link Update an instrumentation picture link.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Picture link object to be updated</param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>PictureResponse</returns>
        public PictureResponse UpdateInstrumentationPictureLink (PictureLinkRequest body, long? instrumentationId, long? id)
        {
             ApiResponse<PictureResponse> localVarResponse = UpdateInstrumentationPictureLinkWithHttpInfo(body, instrumentationId, id);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Update an instrumentation picture link Update an instrumentation picture link.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Picture link object to be updated</param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>ApiResponse of PictureResponse</returns>
        public ApiResponse< PictureResponse > UpdateInstrumentationPictureLinkWithHttpInfo (PictureLinkRequest body, long? instrumentationId, long? id)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->UpdateInstrumentationPictureLink");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->UpdateInstrumentationPictureLink");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling InstrumentationApi->UpdateInstrumentationPictureLink");

            var localVarPath = "/instrumentations/{instrumentation_id}/pictures/links/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateInstrumentationPictureLink", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PictureResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (PictureResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(PictureResponse)));
        }

        /// <summary>
        /// Update an instrumentation picture link Update an instrumentation picture link.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Picture link object to be updated</param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>Task of PictureResponse</returns>
        public async System.Threading.Tasks.Task<PictureResponse> UpdateInstrumentationPictureLinkAsync (PictureLinkRequest body, long? instrumentationId, long? id)
        {
             ApiResponse<PictureResponse> localVarResponse = await UpdateInstrumentationPictureLinkAsyncWithHttpInfo(body, instrumentationId, id);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Update an instrumentation picture link Update an instrumentation picture link.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Picture link object to be updated</param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation picture</param>
        /// <returns>Task of ApiResponse (PictureResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<PictureResponse>> UpdateInstrumentationPictureLinkAsyncWithHttpInfo (PictureLinkRequest body, long? instrumentationId, long? id)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->UpdateInstrumentationPictureLink");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->UpdateInstrumentationPictureLink");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling InstrumentationApi->UpdateInstrumentationPictureLink");

            var localVarPath = "/instrumentations/{instrumentation_id}/pictures/links/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateInstrumentationPictureLink", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PictureResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (PictureResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(PictureResponse)));
        }

        /// <summary>
        /// Update an instrumentation threshold Replaces the threshold belonging to an instrumentation. This action requires &#x60;can_update&#x60; permission on the instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object body that will be updated.</param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation threshold</param>
        /// <returns>ThresholdResponse</returns>
        public ThresholdResponse UpdateInstrumentationThreshold (ThresholdRequest body, long? instrumentationId, long? id)
        {
             ApiResponse<ThresholdResponse> localVarResponse = UpdateInstrumentationThresholdWithHttpInfo(body, instrumentationId, id);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Update an instrumentation threshold Replaces the threshold belonging to an instrumentation. This action requires &#x60;can_update&#x60; permission on the instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object body that will be updated.</param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation threshold</param>
        /// <returns>ApiResponse of ThresholdResponse</returns>
        public ApiResponse< ThresholdResponse > UpdateInstrumentationThresholdWithHttpInfo (ThresholdRequest body, long? instrumentationId, long? id)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->UpdateInstrumentationThreshold");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->UpdateInstrumentationThreshold");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling InstrumentationApi->UpdateInstrumentationThreshold");

            var localVarPath = "/instrumentations/{instrumentation_id}/thresholds/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateInstrumentationThreshold", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ThresholdResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (ThresholdResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ThresholdResponse)));
        }

        /// <summary>
        /// Update an instrumentation threshold Replaces the threshold belonging to an instrumentation. This action requires &#x60;can_update&#x60; permission on the instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object body that will be updated.</param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation threshold</param>
        /// <returns>Task of ThresholdResponse</returns>
        public async System.Threading.Tasks.Task<ThresholdResponse> UpdateInstrumentationThresholdAsync (ThresholdRequest body, long? instrumentationId, long? id)
        {
             ApiResponse<ThresholdResponse> localVarResponse = await UpdateInstrumentationThresholdAsyncWithHttpInfo(body, instrumentationId, id);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Update an instrumentation threshold Replaces the threshold belonging to an instrumentation. This action requires &#x60;can_update&#x60; permission on the instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object body that will be updated.</param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <param name="id">Id of the instrumentation threshold</param>
        /// <returns>Task of ApiResponse (ThresholdResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ThresholdResponse>> UpdateInstrumentationThresholdAsyncWithHttpInfo (ThresholdRequest body, long? instrumentationId, long? id)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->UpdateInstrumentationThreshold");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->UpdateInstrumentationThreshold");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling InstrumentationApi->UpdateInstrumentationThreshold");

            var localVarPath = "/instrumentations/{instrumentation_id}/thresholds/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateInstrumentationThreshold", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ThresholdResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (ThresholdResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ThresholdResponse)));
        }

        /// <summary>
        /// Update specifications of an instrumentation Update the specification object of an instrumentation in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns></returns>
        public void UpdateSpecificationsOfInstrumentation (Dictionary<string, SpecificationUIVisibleRequest> body, long? instrumentationId)
        {
             UpdateSpecificationsOfInstrumentationWithHttpInfo(body, instrumentationId);
        }

        /// <summary>
        /// Update specifications of an instrumentation Update the specification object of an instrumentation in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateSpecificationsOfInstrumentationWithHttpInfo (Dictionary<string, SpecificationUIVisibleRequest> body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->UpdateSpecificationsOfInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->UpdateSpecificationsOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSpecificationsOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update specifications of an instrumentation Update the specification object of an instrumentation in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UpdateSpecificationsOfInstrumentationAsync (Dictionary<string, SpecificationUIVisibleRequest> body, long? instrumentationId)
        {
             await UpdateSpecificationsOfInstrumentationAsyncWithHttpInfo(body, instrumentationId);

        }

        /// <summary>
        /// Update specifications of an instrumentation Update the specification object of an instrumentation in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSpecificationsOfInstrumentationAsyncWithHttpInfo (Dictionary<string, SpecificationUIVisibleRequest> body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling InstrumentationApi->UpdateSpecificationsOfInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling InstrumentationApi->UpdateSpecificationsOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSpecificationsOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Upload an instrumentation picture Upload a new instrumentation picture. Checks the file-storage quota. Allowed content-types are - image/gif - image/jpg - image/jpeg - image/png
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="image"></param>
        /// <param name="id">Id of the instrumentation</param>
        /// <returns>PictureResponse</returns>
        public PictureResponse UploadInstrumentationPicture (byte[] image, long? id)
        {
             ApiResponse<PictureResponse> localVarResponse = UploadInstrumentationPictureWithHttpInfo(image, id);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Upload an instrumentation picture Upload a new instrumentation picture. Checks the file-storage quota. Allowed content-types are - image/gif - image/jpg - image/jpeg - image/png
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="image"></param>
        /// <param name="id">Id of the instrumentation</param>
        /// <returns>ApiResponse of PictureResponse</returns>
        public ApiResponse< PictureResponse > UploadInstrumentationPictureWithHttpInfo (byte[] image, long? id)
        {
            // verify the required parameter 'image' is set
            if (image == null)
                throw new ApiException(400, "Missing required parameter 'image' when calling InstrumentationApi->UploadInstrumentationPicture");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling InstrumentationApi->UploadInstrumentationPicture");

            var localVarPath = "/instrumentations/{id}/pictures";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "multipart/form-data"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (image != null) localVarFileParams.Add("image", this.Configuration.ApiClient.ParameterToFile("image", image));
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UploadInstrumentationPicture", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PictureResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (PictureResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(PictureResponse)));
        }

        /// <summary>
        /// Upload an instrumentation picture Upload a new instrumentation picture. Checks the file-storage quota. Allowed content-types are - image/gif - image/jpg - image/jpeg - image/png
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="image"></param>
        /// <param name="id">Id of the instrumentation</param>
        /// <returns>Task of PictureResponse</returns>
        public async System.Threading.Tasks.Task<PictureResponse> UploadInstrumentationPictureAsync (byte[] image, long? id)
        {
             ApiResponse<PictureResponse> localVarResponse = await UploadInstrumentationPictureAsyncWithHttpInfo(image, id);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Upload an instrumentation picture Upload a new instrumentation picture. Checks the file-storage quota. Allowed content-types are - image/gif - image/jpg - image/jpeg - image/png
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="image"></param>
        /// <param name="id">Id of the instrumentation</param>
        /// <returns>Task of ApiResponse (PictureResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<PictureResponse>> UploadInstrumentationPictureAsyncWithHttpInfo (byte[] image, long? id)
        {
            // verify the required parameter 'image' is set
            if (image == null)
                throw new ApiException(400, "Missing required parameter 'image' when calling InstrumentationApi->UploadInstrumentationPicture");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling InstrumentationApi->UploadInstrumentationPicture");

            var localVarPath = "/instrumentations/{id}/pictures";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "multipart/form-data"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (image != null) localVarFileParams.Add("image", this.Configuration.ApiClient.ParameterToFile("image", image));
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UploadInstrumentationPicture", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PictureResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (PictureResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(PictureResponse)));
        }

    }
}
