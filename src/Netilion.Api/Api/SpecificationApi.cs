/* 
 * Netilion API Documentation
 *
 * Welcome to the Netilion API Documentation, which provides interactive access and documentation to our REST API. Please visit our developer portal for further instructions and information: https://developer.netilion.endress.com/ 
 *
 * OpenAPI spec version: 01.00.00
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using Netilion.Api.Client;
using Netilion.Api.Model;

namespace Netilion.Api.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
        public interface ISpecificationApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Delete specifications of an asset
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="assetId">Id of the specified asset</param>
        /// <returns></returns>
        void DeleteSpecificationsOfAsset (List<string> body, long? assetId);

        /// <summary>
        /// Delete specifications of an asset
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="assetId">Id of the specified asset</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteSpecificationsOfAssetWithHttpInfo (List<string> body, long? assetId);
        /// <summary>
        /// Get the history of one specification attribute of an asset.
        /// </summary>
        /// <remarks>
        /// This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetId">Id of the specified asset</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>SpecificationHistoryResponse</returns>
        SpecificationHistoryResponse GetSpecificationHistoryOfAsset (long? assetId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null);

        /// <summary>
        /// Get the history of one specification attribute of an asset.
        /// </summary>
        /// <remarks>
        /// This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetId">Id of the specified asset</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>ApiResponse of SpecificationHistoryResponse</returns>
        ApiResponse<SpecificationHistoryResponse> GetSpecificationHistoryOfAssetWithHttpInfo (long? assetId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null);
        /// <summary>
        /// Get the history of one specification attribute of a batch.
        /// </summary>
        /// <remarks>
        /// This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="batchId">Id of the specified batch</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>SpecificationHistoryResponse</returns>
        SpecificationHistoryResponse GetSpecificationHistoryOfBatch (long? batchId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null);

        /// <summary>
        /// Get the history of one specification attribute of a batch.
        /// </summary>
        /// <remarks>
        /// This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="batchId">Id of the specified batch</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>ApiResponse of SpecificationHistoryResponse</returns>
        ApiResponse<SpecificationHistoryResponse> GetSpecificationHistoryOfBatchWithHttpInfo (long? batchId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null);
        /// <summary>
        /// Get the history of one specification attribute of an instrumentation.
        /// </summary>
        /// <remarks>
        /// This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>SpecificationHistoryResponse</returns>
        SpecificationHistoryResponse GetSpecificationHistoryOfInstrumentation (long? instrumentationId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null);

        /// <summary>
        /// Get the history of one specification attribute of an instrumentation.
        /// </summary>
        /// <remarks>
        /// This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>ApiResponse of SpecificationHistoryResponse</returns>
        ApiResponse<SpecificationHistoryResponse> GetSpecificationHistoryOfInstrumentationWithHttpInfo (long? instrumentationId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null);
        /// <summary>
        /// Get the history of one specification attribute of an recipe.
        /// </summary>
        /// <remarks>
        /// This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>SpecificationHistoryResponse</returns>
        SpecificationHistoryResponse GetSpecificationHistoryOfRecipe (long? recipeId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null);

        /// <summary>
        /// Get the history of one specification attribute of an recipe.
        /// </summary>
        /// <remarks>
        /// This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>ApiResponse of SpecificationHistoryResponse</returns>
        ApiResponse<SpecificationHistoryResponse> GetSpecificationHistoryOfRecipeWithHttpInfo (long? recipeId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null);
        /// <summary>
        /// Get the history of one specification attribute of a system.
        /// </summary>
        /// <remarks>
        /// This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="systemId">Id of the specified system</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>SpecificationHistoryResponse</returns>
        SpecificationHistoryResponse GetSpecificationHistoryOfSystem (long? systemId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null);

        /// <summary>
        /// Get the history of one specification attribute of a system.
        /// </summary>
        /// <remarks>
        /// This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="systemId">Id of the specified system</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>ApiResponse of SpecificationHistoryResponse</returns>
        ApiResponse<SpecificationHistoryResponse> GetSpecificationHistoryOfSystemWithHttpInfo (long? systemId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null);
        /// <summary>
        /// Get existing asset specification keys
        /// </summary>
        /// <remarks>
        /// Returns the existing specification keys in all readable assets.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>SpecificationKeys</returns>
        SpecificationKeys GetSpecificationKeysOfAssets (string key = null, bool? uiVisible = null);

        /// <summary>
        /// Get existing asset specification keys
        /// </summary>
        /// <remarks>
        /// Returns the existing specification keys in all readable assets.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>ApiResponse of SpecificationKeys</returns>
        ApiResponse<SpecificationKeys> GetSpecificationKeysOfAssetsWithHttpInfo (string key = null, bool? uiVisible = null);
        /// <summary>
        /// Get existing instrumentation specification keys
        /// </summary>
        /// <remarks>
        /// Returns the existing specification keys in all readable instrumentations.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>SpecificationKeys</returns>
        SpecificationKeys GetSpecificationKeysOfInstrumentations (string key = null, bool? uiVisible = null);

        /// <summary>
        /// Get existing instrumentation specification keys
        /// </summary>
        /// <remarks>
        /// Returns the existing specification keys in all readable instrumentations.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>ApiResponse of SpecificationKeys</returns>
        ApiResponse<SpecificationKeys> GetSpecificationKeysOfInstrumentationsWithHttpInfo (string key = null, bool? uiVisible = null);
        /// <summary>
        /// Get existing asset specification keys
        /// </summary>
        /// <remarks>
        /// Returns the existing specification keys in all readable nodes.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>SpecificationKeys</returns>
        SpecificationKeys GetSpecificationKeysOfNodes (string key = null, bool? uiVisible = null);

        /// <summary>
        /// Get existing asset specification keys
        /// </summary>
        /// <remarks>
        /// Returns the existing specification keys in all readable nodes.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>ApiResponse of SpecificationKeys</returns>
        ApiResponse<SpecificationKeys> GetSpecificationKeysOfNodesWithHttpInfo (string key = null, bool? uiVisible = null);
        /// <summary>
        /// Get specifications of an api subscription
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the specified api subscription</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>SpecificationsResponse</returns>
        SpecificationsResponse GetSpecificationsOfAPISubscription (long? id, string key = null);

        /// <summary>
        /// Get specifications of an api subscription
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the specified api subscription</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>ApiResponse of SpecificationsResponse</returns>
        ApiResponse<SpecificationsResponse> GetSpecificationsOfAPISubscriptionWithHttpInfo (long? id, string key = null);
        /// <summary>
        /// Get specifications of an asset
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetId">Id of the specified asset</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>SpecificationsUIVisibleResponse</returns>
        SpecificationsUIVisibleResponse GetSpecificationsOfAsset (long? assetId, string key = null, bool? uiVisible = null);

        /// <summary>
        /// Get specifications of an asset
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetId">Id of the specified asset</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>ApiResponse of SpecificationsUIVisibleResponse</returns>
        ApiResponse<SpecificationsUIVisibleResponse> GetSpecificationsOfAssetWithHttpInfo (long? assetId, string key = null, bool? uiVisible = null);
        /// <summary>
        /// Get specifications of a batch
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="batchId">Id of the specified batch</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>SpecificationsResponse</returns>
        SpecificationsResponse GetSpecificationsOfBatch (long? batchId, string key = null);

        /// <summary>
        /// Get specifications of a batch
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="batchId">Id of the specified batch</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>ApiResponse of SpecificationsResponse</returns>
        ApiResponse<SpecificationsResponse> GetSpecificationsOfBatchWithHttpInfo (long? batchId, string key = null);
        /// <summary>
        /// Get specifications of an event
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>SpecificationsResponse</returns>
        SpecificationsResponse GetSpecificationsOfEvent (long? eventId, string key = null);

        /// <summary>
        /// Get specifications of an event
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>ApiResponse of SpecificationsResponse</returns>
        ApiResponse<SpecificationsResponse> GetSpecificationsOfEventWithHttpInfo (long? eventId, string key = null);
        /// <summary>
        /// Get specifications of an instrumentation
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>SpecificationsUIVisibleResponse</returns>
        SpecificationsUIVisibleResponse GetSpecificationsOfInstrumentation (long? instrumentationId, string key = null, bool? uiVisible = null);

        /// <summary>
        /// Get specifications of an instrumentation
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>ApiResponse of SpecificationsUIVisibleResponse</returns>
        ApiResponse<SpecificationsUIVisibleResponse> GetSpecificationsOfInstrumentationWithHttpInfo (long? instrumentationId, string key = null, bool? uiVisible = null);
        /// <summary>
        /// Get specifications of a node
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the specified node</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>SpecificationsUIVisibleResponse</returns>
        SpecificationsUIVisibleResponse GetSpecificationsOfNode (long? nodeId, string key = null, bool? uiVisible = null);

        /// <summary>
        /// Get specifications of a node
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the specified node</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>ApiResponse of SpecificationsUIVisibleResponse</returns>
        ApiResponse<SpecificationsUIVisibleResponse> GetSpecificationsOfNodeWithHttpInfo (long? nodeId, string key = null, bool? uiVisible = null);
        /// <summary>
        /// Get specifications of a product
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object. If no specifications are defined, this is just an empty object.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="productId">Id of the specified product</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>SpecificationsResponse</returns>
        SpecificationsResponse GetSpecificationsOfProduct (long? productId, string key = null);

        /// <summary>
        /// Get specifications of a product
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object. If no specifications are defined, this is just an empty object.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="productId">Id of the specified product</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>ApiResponse of SpecificationsResponse</returns>
        ApiResponse<SpecificationsResponse> GetSpecificationsOfProductWithHttpInfo (long? productId, string key = null);
        /// <summary>
        /// Get specifications of an recipe
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>SpecificationsResponse</returns>
        SpecificationsResponse GetSpecificationsOfRecipe (long? recipeId, string key = null);

        /// <summary>
        /// Get specifications of an recipe
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>ApiResponse of SpecificationsResponse</returns>
        ApiResponse<SpecificationsResponse> GetSpecificationsOfRecipeWithHttpInfo (long? recipeId, string key = null);
        /// <summary>
        /// Get specifications of a subscription
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>SpecificationsResponse</returns>
        SpecificationsResponse GetSpecificationsOfSubscription (long? subscriptionId, string key = null);

        /// <summary>
        /// Get specifications of a subscription
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>ApiResponse of SpecificationsResponse</returns>
        ApiResponse<SpecificationsResponse> GetSpecificationsOfSubscriptionWithHttpInfo (long? subscriptionId, string key = null);
        /// <summary>
        /// Get specifications of a system
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="systemId">Id of the specified system</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>SpecificationsResponse</returns>
        SpecificationsResponse GetSpecificationsOfSystem (long? systemId, string key = null);

        /// <summary>
        /// Get specifications of a system
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="systemId">Id of the specified system</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>ApiResponse of SpecificationsResponse</returns>
        ApiResponse<SpecificationsResponse> GetSpecificationsOfSystemWithHttpInfo (long? systemId, string key = null);
        /// <summary>
        /// Get specifications of a user
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">Id of the specified user</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>SpecificationsResponse</returns>
        SpecificationsResponse GetSpecificationsOfUser (long? userId, string key = null);

        /// <summary>
        /// Get specifications of a user
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">Id of the specified user</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>ApiResponse of SpecificationsResponse</returns>
        ApiResponse<SpecificationsResponse> GetSpecificationsOfUserWithHttpInfo (long? userId, string key = null);
        /// <summary>
        /// Delete specifications of an api subscription
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="id">Id of the specified api subscription</param>
        /// <returns></returns>
        void RemoveSpecificationsFromAPISubscriptions (List<string> body, long? id);

        /// <summary>
        /// Delete specifications of an api subscription
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="id">Id of the specified api subscription</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveSpecificationsFromAPISubscriptionsWithHttpInfo (List<string> body, long? id);
        /// <summary>
        /// Delete specifications of a batch
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="batchId">Id of the specified batch</param>
        /// <returns></returns>
        void RemoveSpecificationsFromBatch (List<string> body, long? batchId);

        /// <summary>
        /// Delete specifications of a batch
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="batchId">Id of the specified batch</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveSpecificationsFromBatchWithHttpInfo (List<string> body, long? batchId);
        /// <summary>
        /// Delete specifications of an event
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="eventId">Id of the specified event</param>
        /// <returns></returns>
        void RemoveSpecificationsFromEvent (List<string> body, long? eventId);

        /// <summary>
        /// Delete specifications of an event
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="eventId">Id of the specified event</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveSpecificationsFromEventWithHttpInfo (List<string> body, long? eventId);
        /// <summary>
        /// Delete specifications of an instrumentation
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns></returns>
        void RemoveSpecificationsFromInstrumentation (List<string> body, long? instrumentationId);

        /// <summary>
        /// Delete specifications of an instrumentation
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveSpecificationsFromInstrumentationWithHttpInfo (List<string> body, long? instrumentationId);
        /// <summary>
        /// Delete specifications of a node
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns></returns>
        void RemoveSpecificationsFromNode (List<string> body, long? nodeId);

        /// <summary>
        /// Delete specifications of a node
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveSpecificationsFromNodeWithHttpInfo (List<string> body, long? nodeId);
        /// <summary>
        /// Delete specifications of a product
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="productId">Id of the specified product</param>
        /// <returns></returns>
        void RemoveSpecificationsFromProduct (List<string> body, long? productId);

        /// <summary>
        /// Delete specifications of a product
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="productId">Id of the specified product</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveSpecificationsFromProductWithHttpInfo (List<string> body, long? productId);
        /// <summary>
        /// Delete specifications of an recipe
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <returns></returns>
        void RemoveSpecificationsFromRecipe (List<string> body, long? recipeId);

        /// <summary>
        /// Delete specifications of an recipe
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveSpecificationsFromRecipeWithHttpInfo (List<string> body, long? recipeId);
        /// <summary>
        /// Delete specifications of a subscription
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns></returns>
        void RemoveSpecificationsFromSubscriptions (List<string> body, long? subscriptionId);

        /// <summary>
        /// Delete specifications of a subscription
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveSpecificationsFromSubscriptionsWithHttpInfo (List<string> body, long? subscriptionId);
        /// <summary>
        /// Delete specifications of a system
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="systemId">Id of the specified system</param>
        /// <returns></returns>
        void RemoveSpecificationsFromSystem (List<string> body, long? systemId);

        /// <summary>
        /// Delete specifications of a system
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="systemId">Id of the specified system</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveSpecificationsFromSystemWithHttpInfo (List<string> body, long? systemId);
        /// <summary>
        /// Delete specifications of a user
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="userId">Id of the specified user</param>
        /// <returns></returns>
        void RemoveSpecificationsFromUsers (List<string> body, long? userId);

        /// <summary>
        /// Delete specifications of a user
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="userId">Id of the specified user</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveSpecificationsFromUsersWithHttpInfo (List<string> body, long? userId);
        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of a subscription in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="id">Id of the specified subscription</param>
        /// <returns></returns>
        void RenameSpecificationsOfAPISubscriptions (SpecificationsRename body, long? id);

        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of a subscription in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="id">Id of the specified subscription</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RenameSpecificationsOfAPISubscriptionsWithHttpInfo (SpecificationsRename body, long? id);
        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of an asset in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ]. All uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="assetId">Id of the specified asset</param>
        /// <returns></returns>
        void RenameSpecificationsOfAsset (SpecificationsRename body, long? assetId);

        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of an asset in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ]. All uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="assetId">Id of the specified asset</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RenameSpecificationsOfAssetWithHttpInfo (SpecificationsRename body, long? assetId);
        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of a batch in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="batchId">Id of the specified batch</param>
        /// <returns></returns>
        void RenameSpecificationsOfBatch (SpecificationsRename body, long? batchId);

        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of a batch in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="batchId">Id of the specified batch</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RenameSpecificationsOfBatchWithHttpInfo (SpecificationsRename body, long? batchId);
        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of an event in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="eventId">Id of the specified node</param>
        /// <returns></returns>
        void RenameSpecificationsOfEvent (SpecificationsRename body, long? eventId);

        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of an event in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="eventId">Id of the specified node</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RenameSpecificationsOfEventWithHttpInfo (SpecificationsRename body, long? eventId);
        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of an instrumentation in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns></returns>
        void RenameSpecificationsOfInstrumentation (SpecificationsRename body, long? instrumentationId);

        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of an instrumentation in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RenameSpecificationsOfInstrumentationWithHttpInfo (SpecificationsRename body, long? instrumentationId);
        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of a node in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns></returns>
        void RenameSpecificationsOfNode (SpecificationsRename body, long? nodeId);

        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of a node in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RenameSpecificationsOfNodeWithHttpInfo (SpecificationsRename body, long? nodeId);
        /// <summary>
        /// rename a key in the specification.
        /// </summary>
        /// <remarks>
        /// Rename a key of the specification object of a product. Instead of delete and recreate again, this is to preserve the key´s value history. Also the new keys can only consist of a-z A-Z 0-9 . - _ all uppercase A-Z are converted to lower-case a-z. Only one key can be changed per request
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="productId">Id of the specified product</param>
        /// <returns></returns>
        void RenameSpecificationsOfProduct (SpecificationsRename body, long? productId);

        /// <summary>
        /// rename a key in the specification.
        /// </summary>
        /// <remarks>
        /// Rename a key of the specification object of a product. Instead of delete and recreate again, this is to preserve the key´s value history. Also the new keys can only consist of a-z A-Z 0-9 . - _ all uppercase A-Z are converted to lower-case a-z. Only one key can be changed per request
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="productId">Id of the specified product</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RenameSpecificationsOfProductWithHttpInfo (SpecificationsRename body, long? productId);
        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of an recipe in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <returns></returns>
        void RenameSpecificationsOfRecipe (SpecificationsRename body, long? recipeId);

        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of an recipe in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RenameSpecificationsOfRecipeWithHttpInfo (SpecificationsRename body, long? recipeId);
        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of a subscription in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns></returns>
        void RenameSpecificationsOfSubscriptions (SpecificationsRename body, long? subscriptionId);

        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of a subscription in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RenameSpecificationsOfSubscriptionsWithHttpInfo (SpecificationsRename body, long? subscriptionId);
        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of a system in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="systemId">Id of the specified system</param>
        /// <returns></returns>
        void RenameSpecificationsOfSystem (SpecificationsRename body, long? systemId);

        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of a system in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="systemId">Id of the specified system</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RenameSpecificationsOfSystemWithHttpInfo (SpecificationsRename body, long? systemId);
        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of a user in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="userId">Id of the specified user</param>
        /// <returns></returns>
        void RenameSpecificationsOfUsers (SpecificationsRename body, long? userId);

        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of a user in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="userId">Id of the specified user</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RenameSpecificationsOfUsersWithHttpInfo (SpecificationsRename body, long? userId);
        /// <summary>
        /// Update specifications of an api subscription
        /// </summary>
        /// <remarks>
        /// Update the specification object of an api subscription in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="id">Id of the specified api subscription</param>
        /// <returns></returns>
        void UpdateSpecificationsOfAPISubscriptions (Dictionary<string, SpecificationRequest> body, long? id);

        /// <summary>
        /// Update specifications of an api subscription
        /// </summary>
        /// <remarks>
        /// Update the specification object of an api subscription in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="id">Id of the specified api subscription</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateSpecificationsOfAPISubscriptionsWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? id);
        /// <summary>
        /// Update specifications of an asset
        /// </summary>
        /// <remarks>
        /// Update the specification object of an asset in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.  It is possible to save complex objects in the value as vector. In this case the unit must be &#x27;vector&#x27; and the value a valid object in the following format: &#x60;&#x60;&#x60;       [           {             \&quot;key\&quot;: {              \&quot;value\&quot;: \&quot;string\&quot;,              \&quot;unit\&quot;: \&quot;string\&quot;            }           },           {             \&quot;second_key\&quot;: {               \&quot;value\&quot;: \&quot;string\&quot;             }           }        ]   &#x60;&#x60;&#x60;  - key can only consist of [a-z A-Z 0-9 . - _ ]. - value is mandatory, max length 6000 chars - unit is optional, max length 50 chars - its impossible to filter for vector values
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="assetId">Id of the specified asset</param>
        /// <returns></returns>
        void UpdateSpecificationsOfAsset (Dictionary<string, SpecificationUIVisibleRequest> body, long? assetId);

        /// <summary>
        /// Update specifications of an asset
        /// </summary>
        /// <remarks>
        /// Update the specification object of an asset in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.  It is possible to save complex objects in the value as vector. In this case the unit must be &#x27;vector&#x27; and the value a valid object in the following format: &#x60;&#x60;&#x60;       [           {             \&quot;key\&quot;: {              \&quot;value\&quot;: \&quot;string\&quot;,              \&quot;unit\&quot;: \&quot;string\&quot;            }           },           {             \&quot;second_key\&quot;: {               \&quot;value\&quot;: \&quot;string\&quot;             }           }        ]   &#x60;&#x60;&#x60;  - key can only consist of [a-z A-Z 0-9 . - _ ]. - value is mandatory, max length 6000 chars - unit is optional, max length 50 chars - its impossible to filter for vector values
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="assetId">Id of the specified asset</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateSpecificationsOfAssetWithHttpInfo (Dictionary<string, SpecificationUIVisibleRequest> body, long? assetId);
        /// <summary>
        /// Update specifications of a batch
        /// </summary>
        /// <remarks>
        /// Update the specification object of a batch in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="batchId">Id of the specified batch</param>
        /// <returns></returns>
        void UpdateSpecificationsOfBatch (Dictionary<string, SpecificationRequest> body, long? batchId);

        /// <summary>
        /// Update specifications of a batch
        /// </summary>
        /// <remarks>
        /// Update the specification object of a batch in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="batchId">Id of the specified batch</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateSpecificationsOfBatchWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? batchId);
        /// <summary>
        /// Update specifications of an event
        /// </summary>
        /// <remarks>
        /// Update the specification object of an event in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of a-z A-Z 0-9 . - _ all uppercase A-Z are converted to lower-case a-z. For a key that is send mutliple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="eventId">Id of the specified event</param>
        /// <returns></returns>
        void UpdateSpecificationsOfEvent (Dictionary<string, SpecificationRequest> body, long? eventId);

        /// <summary>
        /// Update specifications of an event
        /// </summary>
        /// <remarks>
        /// Update the specification object of an event in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of a-z A-Z 0-9 . - _ all uppercase A-Z are converted to lower-case a-z. For a key that is send mutliple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="eventId">Id of the specified event</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateSpecificationsOfEventWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? eventId);
        /// <summary>
        /// Update specifications of an instrumentation
        /// </summary>
        /// <remarks>
        /// Update the specification object of an instrumentation in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns></returns>
        void UpdateSpecificationsOfInstrumentation (Dictionary<string, SpecificationUIVisibleRequest> body, long? instrumentationId);

        /// <summary>
        /// Update specifications of an instrumentation
        /// </summary>
        /// <remarks>
        /// Update the specification object of an instrumentation in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateSpecificationsOfInstrumentationWithHttpInfo (Dictionary<string, SpecificationUIVisibleRequest> body, long? instrumentationId);
        /// <summary>
        /// Update specifications of a node
        /// </summary>
        /// <remarks>
        /// Update the specification object of a node in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns></returns>
        void UpdateSpecificationsOfNode (Dictionary<string, SpecificationUIVisibleRequest> body, long? nodeId);

        /// <summary>
        /// Update specifications of a node
        /// </summary>
        /// <remarks>
        /// Update the specification object of a node in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateSpecificationsOfNodeWithHttpInfo (Dictionary<string, SpecificationUIVisibleRequest> body, long? nodeId);
        /// <summary>
        /// Update specifications of a product
        /// </summary>
        /// <remarks>
        /// Update the specification object of a product. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. If a key occurs more than once in the request body, the last key-value will be saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="productId">Id of the specified product</param>
        /// <returns></returns>
        void UpdateSpecificationsOfProduct (Dictionary<string, SpecificationRequest> body, long? productId);

        /// <summary>
        /// Update specifications of a product
        /// </summary>
        /// <remarks>
        /// Update the specification object of a product. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. If a key occurs more than once in the request body, the last key-value will be saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="productId">Id of the specified product</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateSpecificationsOfProductWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? productId);
        /// <summary>
        /// Update specifications of an recipe
        /// </summary>
        /// <remarks>
        /// Update the specification object of an recipe in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <returns></returns>
        void UpdateSpecificationsOfRecipe (Dictionary<string, SpecificationRequest> body, long? recipeId);

        /// <summary>
        /// Update specifications of an recipe
        /// </summary>
        /// <remarks>
        /// Update the specification object of an recipe in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateSpecificationsOfRecipeWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? recipeId);
        /// <summary>
        /// Update specifications of a subscription
        /// </summary>
        /// <remarks>
        /// Update the specification object of a subscription in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns></returns>
        void UpdateSpecificationsOfSubscriptions (Dictionary<string, SpecificationRequest> body, long? subscriptionId);

        /// <summary>
        /// Update specifications of a subscription
        /// </summary>
        /// <remarks>
        /// Update the specification object of a subscription in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateSpecificationsOfSubscriptionsWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? subscriptionId);
        /// <summary>
        /// Update specifications of a system
        /// </summary>
        /// <remarks>
        /// Update the specification object of a system in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="systemId">Id of the specified system</param>
        /// <returns></returns>
        void UpdateSpecificationsOfSystem (Dictionary<string, SpecificationRequest> body, long? systemId);

        /// <summary>
        /// Update specifications of a system
        /// </summary>
        /// <remarks>
        /// Update the specification object of a system in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="systemId">Id of the specified system</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateSpecificationsOfSystemWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? systemId);
        /// <summary>
        /// Update specifications of a user
        /// </summary>
        /// <remarks>
        /// Update the specification object of a user in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="userId">Id of the specified user</param>
        /// <returns></returns>
        void UpdateSpecificationsOfUsers (Dictionary<string, SpecificationRequest> body, long? userId);

        /// <summary>
        /// Update specifications of a user
        /// </summary>
        /// <remarks>
        /// Update the specification object of a user in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="userId">Id of the specified user</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateSpecificationsOfUsersWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? userId);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Delete specifications of an asset
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="assetId">Id of the specified asset</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteSpecificationsOfAssetAsync (List<string> body, long? assetId);

        /// <summary>
        /// Delete specifications of an asset
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="assetId">Id of the specified asset</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteSpecificationsOfAssetAsyncWithHttpInfo (List<string> body, long? assetId);
        /// <summary>
        /// Get the history of one specification attribute of an asset.
        /// </summary>
        /// <remarks>
        /// This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetId">Id of the specified asset</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>Task of SpecificationHistoryResponse</returns>
        System.Threading.Tasks.Task<SpecificationHistoryResponse> GetSpecificationHistoryOfAssetAsync (long? assetId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null);

        /// <summary>
        /// Get the history of one specification attribute of an asset.
        /// </summary>
        /// <remarks>
        /// This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetId">Id of the specified asset</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationHistoryResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SpecificationHistoryResponse>> GetSpecificationHistoryOfAssetAsyncWithHttpInfo (long? assetId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null);
        /// <summary>
        /// Get the history of one specification attribute of a batch.
        /// </summary>
        /// <remarks>
        /// This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="batchId">Id of the specified batch</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>Task of SpecificationHistoryResponse</returns>
        System.Threading.Tasks.Task<SpecificationHistoryResponse> GetSpecificationHistoryOfBatchAsync (long? batchId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null);

        /// <summary>
        /// Get the history of one specification attribute of a batch.
        /// </summary>
        /// <remarks>
        /// This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="batchId">Id of the specified batch</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationHistoryResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SpecificationHistoryResponse>> GetSpecificationHistoryOfBatchAsyncWithHttpInfo (long? batchId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null);
        /// <summary>
        /// Get the history of one specification attribute of an instrumentation.
        /// </summary>
        /// <remarks>
        /// This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>Task of SpecificationHistoryResponse</returns>
        System.Threading.Tasks.Task<SpecificationHistoryResponse> GetSpecificationHistoryOfInstrumentationAsync (long? instrumentationId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null);

        /// <summary>
        /// Get the history of one specification attribute of an instrumentation.
        /// </summary>
        /// <remarks>
        /// This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationHistoryResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SpecificationHistoryResponse>> GetSpecificationHistoryOfInstrumentationAsyncWithHttpInfo (long? instrumentationId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null);
        /// <summary>
        /// Get the history of one specification attribute of an recipe.
        /// </summary>
        /// <remarks>
        /// This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>Task of SpecificationHistoryResponse</returns>
        System.Threading.Tasks.Task<SpecificationHistoryResponse> GetSpecificationHistoryOfRecipeAsync (long? recipeId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null);

        /// <summary>
        /// Get the history of one specification attribute of an recipe.
        /// </summary>
        /// <remarks>
        /// This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationHistoryResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SpecificationHistoryResponse>> GetSpecificationHistoryOfRecipeAsyncWithHttpInfo (long? recipeId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null);
        /// <summary>
        /// Get the history of one specification attribute of a system.
        /// </summary>
        /// <remarks>
        /// This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="systemId">Id of the specified system</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>Task of SpecificationHistoryResponse</returns>
        System.Threading.Tasks.Task<SpecificationHistoryResponse> GetSpecificationHistoryOfSystemAsync (long? systemId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null);

        /// <summary>
        /// Get the history of one specification attribute of a system.
        /// </summary>
        /// <remarks>
        /// This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="systemId">Id of the specified system</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationHistoryResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SpecificationHistoryResponse>> GetSpecificationHistoryOfSystemAsyncWithHttpInfo (long? systemId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null);
        /// <summary>
        /// Get existing asset specification keys
        /// </summary>
        /// <remarks>
        /// Returns the existing specification keys in all readable assets.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of SpecificationKeys</returns>
        System.Threading.Tasks.Task<SpecificationKeys> GetSpecificationKeysOfAssetsAsync (string key = null, bool? uiVisible = null);

        /// <summary>
        /// Get existing asset specification keys
        /// </summary>
        /// <remarks>
        /// Returns the existing specification keys in all readable assets.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationKeys)</returns>
        System.Threading.Tasks.Task<ApiResponse<SpecificationKeys>> GetSpecificationKeysOfAssetsAsyncWithHttpInfo (string key = null, bool? uiVisible = null);
        /// <summary>
        /// Get existing instrumentation specification keys
        /// </summary>
        /// <remarks>
        /// Returns the existing specification keys in all readable instrumentations.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of SpecificationKeys</returns>
        System.Threading.Tasks.Task<SpecificationKeys> GetSpecificationKeysOfInstrumentationsAsync (string key = null, bool? uiVisible = null);

        /// <summary>
        /// Get existing instrumentation specification keys
        /// </summary>
        /// <remarks>
        /// Returns the existing specification keys in all readable instrumentations.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationKeys)</returns>
        System.Threading.Tasks.Task<ApiResponse<SpecificationKeys>> GetSpecificationKeysOfInstrumentationsAsyncWithHttpInfo (string key = null, bool? uiVisible = null);
        /// <summary>
        /// Get existing asset specification keys
        /// </summary>
        /// <remarks>
        /// Returns the existing specification keys in all readable nodes.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of SpecificationKeys</returns>
        System.Threading.Tasks.Task<SpecificationKeys> GetSpecificationKeysOfNodesAsync (string key = null, bool? uiVisible = null);

        /// <summary>
        /// Get existing asset specification keys
        /// </summary>
        /// <remarks>
        /// Returns the existing specification keys in all readable nodes.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationKeys)</returns>
        System.Threading.Tasks.Task<ApiResponse<SpecificationKeys>> GetSpecificationKeysOfNodesAsyncWithHttpInfo (string key = null, bool? uiVisible = null);
        /// <summary>
        /// Get specifications of an api subscription
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the specified api subscription</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of SpecificationsResponse</returns>
        System.Threading.Tasks.Task<SpecificationsResponse> GetSpecificationsOfAPISubscriptionAsync (long? id, string key = null);

        /// <summary>
        /// Get specifications of an api subscription
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the specified api subscription</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SpecificationsResponse>> GetSpecificationsOfAPISubscriptionAsyncWithHttpInfo (long? id, string key = null);
        /// <summary>
        /// Get specifications of an asset
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetId">Id of the specified asset</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of SpecificationsUIVisibleResponse</returns>
        System.Threading.Tasks.Task<SpecificationsUIVisibleResponse> GetSpecificationsOfAssetAsync (long? assetId, string key = null, bool? uiVisible = null);

        /// <summary>
        /// Get specifications of an asset
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetId">Id of the specified asset</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationsUIVisibleResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SpecificationsUIVisibleResponse>> GetSpecificationsOfAssetAsyncWithHttpInfo (long? assetId, string key = null, bool? uiVisible = null);
        /// <summary>
        /// Get specifications of a batch
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="batchId">Id of the specified batch</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of SpecificationsResponse</returns>
        System.Threading.Tasks.Task<SpecificationsResponse> GetSpecificationsOfBatchAsync (long? batchId, string key = null);

        /// <summary>
        /// Get specifications of a batch
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="batchId">Id of the specified batch</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SpecificationsResponse>> GetSpecificationsOfBatchAsyncWithHttpInfo (long? batchId, string key = null);
        /// <summary>
        /// Get specifications of an event
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of SpecificationsResponse</returns>
        System.Threading.Tasks.Task<SpecificationsResponse> GetSpecificationsOfEventAsync (long? eventId, string key = null);

        /// <summary>
        /// Get specifications of an event
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SpecificationsResponse>> GetSpecificationsOfEventAsyncWithHttpInfo (long? eventId, string key = null);
        /// <summary>
        /// Get specifications of an instrumentation
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of SpecificationsUIVisibleResponse</returns>
        System.Threading.Tasks.Task<SpecificationsUIVisibleResponse> GetSpecificationsOfInstrumentationAsync (long? instrumentationId, string key = null, bool? uiVisible = null);

        /// <summary>
        /// Get specifications of an instrumentation
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationsUIVisibleResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SpecificationsUIVisibleResponse>> GetSpecificationsOfInstrumentationAsyncWithHttpInfo (long? instrumentationId, string key = null, bool? uiVisible = null);
        /// <summary>
        /// Get specifications of a node
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the specified node</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of SpecificationsUIVisibleResponse</returns>
        System.Threading.Tasks.Task<SpecificationsUIVisibleResponse> GetSpecificationsOfNodeAsync (long? nodeId, string key = null, bool? uiVisible = null);

        /// <summary>
        /// Get specifications of a node
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the specified node</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationsUIVisibleResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SpecificationsUIVisibleResponse>> GetSpecificationsOfNodeAsyncWithHttpInfo (long? nodeId, string key = null, bool? uiVisible = null);
        /// <summary>
        /// Get specifications of a product
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object. If no specifications are defined, this is just an empty object.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="productId">Id of the specified product</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of SpecificationsResponse</returns>
        System.Threading.Tasks.Task<SpecificationsResponse> GetSpecificationsOfProductAsync (long? productId, string key = null);

        /// <summary>
        /// Get specifications of a product
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object. If no specifications are defined, this is just an empty object.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="productId">Id of the specified product</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SpecificationsResponse>> GetSpecificationsOfProductAsyncWithHttpInfo (long? productId, string key = null);
        /// <summary>
        /// Get specifications of an recipe
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of SpecificationsResponse</returns>
        System.Threading.Tasks.Task<SpecificationsResponse> GetSpecificationsOfRecipeAsync (long? recipeId, string key = null);

        /// <summary>
        /// Get specifications of an recipe
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SpecificationsResponse>> GetSpecificationsOfRecipeAsyncWithHttpInfo (long? recipeId, string key = null);
        /// <summary>
        /// Get specifications of a subscription
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of SpecificationsResponse</returns>
        System.Threading.Tasks.Task<SpecificationsResponse> GetSpecificationsOfSubscriptionAsync (long? subscriptionId, string key = null);

        /// <summary>
        /// Get specifications of a subscription
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SpecificationsResponse>> GetSpecificationsOfSubscriptionAsyncWithHttpInfo (long? subscriptionId, string key = null);
        /// <summary>
        /// Get specifications of a system
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="systemId">Id of the specified system</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of SpecificationsResponse</returns>
        System.Threading.Tasks.Task<SpecificationsResponse> GetSpecificationsOfSystemAsync (long? systemId, string key = null);

        /// <summary>
        /// Get specifications of a system
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="systemId">Id of the specified system</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SpecificationsResponse>> GetSpecificationsOfSystemAsyncWithHttpInfo (long? systemId, string key = null);
        /// <summary>
        /// Get specifications of a user
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">Id of the specified user</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of SpecificationsResponse</returns>
        System.Threading.Tasks.Task<SpecificationsResponse> GetSpecificationsOfUserAsync (long? userId, string key = null);

        /// <summary>
        /// Get specifications of a user
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">Id of the specified user</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SpecificationsResponse>> GetSpecificationsOfUserAsyncWithHttpInfo (long? userId, string key = null);
        /// <summary>
        /// Delete specifications of an api subscription
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="id">Id of the specified api subscription</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveSpecificationsFromAPISubscriptionsAsync (List<string> body, long? id);

        /// <summary>
        /// Delete specifications of an api subscription
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="id">Id of the specified api subscription</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveSpecificationsFromAPISubscriptionsAsyncWithHttpInfo (List<string> body, long? id);
        /// <summary>
        /// Delete specifications of a batch
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="batchId">Id of the specified batch</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveSpecificationsFromBatchAsync (List<string> body, long? batchId);

        /// <summary>
        /// Delete specifications of a batch
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="batchId">Id of the specified batch</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveSpecificationsFromBatchAsyncWithHttpInfo (List<string> body, long? batchId);
        /// <summary>
        /// Delete specifications of an event
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="eventId">Id of the specified event</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveSpecificationsFromEventAsync (List<string> body, long? eventId);

        /// <summary>
        /// Delete specifications of an event
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="eventId">Id of the specified event</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveSpecificationsFromEventAsyncWithHttpInfo (List<string> body, long? eventId);
        /// <summary>
        /// Delete specifications of an instrumentation
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveSpecificationsFromInstrumentationAsync (List<string> body, long? instrumentationId);

        /// <summary>
        /// Delete specifications of an instrumentation
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveSpecificationsFromInstrumentationAsyncWithHttpInfo (List<string> body, long? instrumentationId);
        /// <summary>
        /// Delete specifications of a node
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveSpecificationsFromNodeAsync (List<string> body, long? nodeId);

        /// <summary>
        /// Delete specifications of a node
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveSpecificationsFromNodeAsyncWithHttpInfo (List<string> body, long? nodeId);
        /// <summary>
        /// Delete specifications of a product
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="productId">Id of the specified product</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveSpecificationsFromProductAsync (List<string> body, long? productId);

        /// <summary>
        /// Delete specifications of a product
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="productId">Id of the specified product</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveSpecificationsFromProductAsyncWithHttpInfo (List<string> body, long? productId);
        /// <summary>
        /// Delete specifications of an recipe
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveSpecificationsFromRecipeAsync (List<string> body, long? recipeId);

        /// <summary>
        /// Delete specifications of an recipe
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveSpecificationsFromRecipeAsyncWithHttpInfo (List<string> body, long? recipeId);
        /// <summary>
        /// Delete specifications of a subscription
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveSpecificationsFromSubscriptionsAsync (List<string> body, long? subscriptionId);

        /// <summary>
        /// Delete specifications of a subscription
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveSpecificationsFromSubscriptionsAsyncWithHttpInfo (List<string> body, long? subscriptionId);
        /// <summary>
        /// Delete specifications of a system
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="systemId">Id of the specified system</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveSpecificationsFromSystemAsync (List<string> body, long? systemId);

        /// <summary>
        /// Delete specifications of a system
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="systemId">Id of the specified system</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveSpecificationsFromSystemAsyncWithHttpInfo (List<string> body, long? systemId);
        /// <summary>
        /// Delete specifications of a user
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="userId">Id of the specified user</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveSpecificationsFromUsersAsync (List<string> body, long? userId);

        /// <summary>
        /// Delete specifications of a user
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="userId">Id of the specified user</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveSpecificationsFromUsersAsyncWithHttpInfo (List<string> body, long? userId);
        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of a subscription in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="id">Id of the specified subscription</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RenameSpecificationsOfAPISubscriptionsAsync (SpecificationsRename body, long? id);

        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of a subscription in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="id">Id of the specified subscription</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RenameSpecificationsOfAPISubscriptionsAsyncWithHttpInfo (SpecificationsRename body, long? id);
        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of an asset in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ]. All uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="assetId">Id of the specified asset</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RenameSpecificationsOfAssetAsync (SpecificationsRename body, long? assetId);

        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of an asset in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ]. All uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="assetId">Id of the specified asset</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RenameSpecificationsOfAssetAsyncWithHttpInfo (SpecificationsRename body, long? assetId);
        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of a batch in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="batchId">Id of the specified batch</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RenameSpecificationsOfBatchAsync (SpecificationsRename body, long? batchId);

        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of a batch in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="batchId">Id of the specified batch</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RenameSpecificationsOfBatchAsyncWithHttpInfo (SpecificationsRename body, long? batchId);
        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of an event in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="eventId">Id of the specified node</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RenameSpecificationsOfEventAsync (SpecificationsRename body, long? eventId);

        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of an event in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="eventId">Id of the specified node</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RenameSpecificationsOfEventAsyncWithHttpInfo (SpecificationsRename body, long? eventId);
        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of an instrumentation in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RenameSpecificationsOfInstrumentationAsync (SpecificationsRename body, long? instrumentationId);

        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of an instrumentation in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RenameSpecificationsOfInstrumentationAsyncWithHttpInfo (SpecificationsRename body, long? instrumentationId);
        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of a node in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RenameSpecificationsOfNodeAsync (SpecificationsRename body, long? nodeId);

        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of a node in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RenameSpecificationsOfNodeAsyncWithHttpInfo (SpecificationsRename body, long? nodeId);
        /// <summary>
        /// rename a key in the specification.
        /// </summary>
        /// <remarks>
        /// Rename a key of the specification object of a product. Instead of delete and recreate again, this is to preserve the key´s value history. Also the new keys can only consist of a-z A-Z 0-9 . - _ all uppercase A-Z are converted to lower-case a-z. Only one key can be changed per request
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="productId">Id of the specified product</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RenameSpecificationsOfProductAsync (SpecificationsRename body, long? productId);

        /// <summary>
        /// rename a key in the specification.
        /// </summary>
        /// <remarks>
        /// Rename a key of the specification object of a product. Instead of delete and recreate again, this is to preserve the key´s value history. Also the new keys can only consist of a-z A-Z 0-9 . - _ all uppercase A-Z are converted to lower-case a-z. Only one key can be changed per request
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="productId">Id of the specified product</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RenameSpecificationsOfProductAsyncWithHttpInfo (SpecificationsRename body, long? productId);
        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of an recipe in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RenameSpecificationsOfRecipeAsync (SpecificationsRename body, long? recipeId);

        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of an recipe in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RenameSpecificationsOfRecipeAsyncWithHttpInfo (SpecificationsRename body, long? recipeId);
        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of a subscription in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RenameSpecificationsOfSubscriptionsAsync (SpecificationsRename body, long? subscriptionId);

        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of a subscription in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RenameSpecificationsOfSubscriptionsAsyncWithHttpInfo (SpecificationsRename body, long? subscriptionId);
        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of a system in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="systemId">Id of the specified system</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RenameSpecificationsOfSystemAsync (SpecificationsRename body, long? systemId);

        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of a system in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="systemId">Id of the specified system</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RenameSpecificationsOfSystemAsyncWithHttpInfo (SpecificationsRename body, long? systemId);
        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of a user in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="userId">Id of the specified user</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RenameSpecificationsOfUsersAsync (SpecificationsRename body, long? userId);

        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of a user in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="userId">Id of the specified user</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RenameSpecificationsOfUsersAsyncWithHttpInfo (SpecificationsRename body, long? userId);
        /// <summary>
        /// Update specifications of an api subscription
        /// </summary>
        /// <remarks>
        /// Update the specification object of an api subscription in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="id">Id of the specified api subscription</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UpdateSpecificationsOfAPISubscriptionsAsync (Dictionary<string, SpecificationRequest> body, long? id);

        /// <summary>
        /// Update specifications of an api subscription
        /// </summary>
        /// <remarks>
        /// Update the specification object of an api subscription in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="id">Id of the specified api subscription</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSpecificationsOfAPISubscriptionsAsyncWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? id);
        /// <summary>
        /// Update specifications of an asset
        /// </summary>
        /// <remarks>
        /// Update the specification object of an asset in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.  It is possible to save complex objects in the value as vector. In this case the unit must be &#x27;vector&#x27; and the value a valid object in the following format: &#x60;&#x60;&#x60;       [           {             \&quot;key\&quot;: {              \&quot;value\&quot;: \&quot;string\&quot;,              \&quot;unit\&quot;: \&quot;string\&quot;            }           },           {             \&quot;second_key\&quot;: {               \&quot;value\&quot;: \&quot;string\&quot;             }           }        ]   &#x60;&#x60;&#x60;  - key can only consist of [a-z A-Z 0-9 . - _ ]. - value is mandatory, max length 6000 chars - unit is optional, max length 50 chars - its impossible to filter for vector values
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="assetId">Id of the specified asset</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UpdateSpecificationsOfAssetAsync (Dictionary<string, SpecificationUIVisibleRequest> body, long? assetId);

        /// <summary>
        /// Update specifications of an asset
        /// </summary>
        /// <remarks>
        /// Update the specification object of an asset in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.  It is possible to save complex objects in the value as vector. In this case the unit must be &#x27;vector&#x27; and the value a valid object in the following format: &#x60;&#x60;&#x60;       [           {             \&quot;key\&quot;: {              \&quot;value\&quot;: \&quot;string\&quot;,              \&quot;unit\&quot;: \&quot;string\&quot;            }           },           {             \&quot;second_key\&quot;: {               \&quot;value\&quot;: \&quot;string\&quot;             }           }        ]   &#x60;&#x60;&#x60;  - key can only consist of [a-z A-Z 0-9 . - _ ]. - value is mandatory, max length 6000 chars - unit is optional, max length 50 chars - its impossible to filter for vector values
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="assetId">Id of the specified asset</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSpecificationsOfAssetAsyncWithHttpInfo (Dictionary<string, SpecificationUIVisibleRequest> body, long? assetId);
        /// <summary>
        /// Update specifications of a batch
        /// </summary>
        /// <remarks>
        /// Update the specification object of a batch in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="batchId">Id of the specified batch</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UpdateSpecificationsOfBatchAsync (Dictionary<string, SpecificationRequest> body, long? batchId);

        /// <summary>
        /// Update specifications of a batch
        /// </summary>
        /// <remarks>
        /// Update the specification object of a batch in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="batchId">Id of the specified batch</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSpecificationsOfBatchAsyncWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? batchId);
        /// <summary>
        /// Update specifications of an event
        /// </summary>
        /// <remarks>
        /// Update the specification object of an event in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of a-z A-Z 0-9 . - _ all uppercase A-Z are converted to lower-case a-z. For a key that is send mutliple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="eventId">Id of the specified event</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UpdateSpecificationsOfEventAsync (Dictionary<string, SpecificationRequest> body, long? eventId);

        /// <summary>
        /// Update specifications of an event
        /// </summary>
        /// <remarks>
        /// Update the specification object of an event in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of a-z A-Z 0-9 . - _ all uppercase A-Z are converted to lower-case a-z. For a key that is send mutliple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="eventId">Id of the specified event</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSpecificationsOfEventAsyncWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? eventId);
        /// <summary>
        /// Update specifications of an instrumentation
        /// </summary>
        /// <remarks>
        /// Update the specification object of an instrumentation in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UpdateSpecificationsOfInstrumentationAsync (Dictionary<string, SpecificationUIVisibleRequest> body, long? instrumentationId);

        /// <summary>
        /// Update specifications of an instrumentation
        /// </summary>
        /// <remarks>
        /// Update the specification object of an instrumentation in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSpecificationsOfInstrumentationAsyncWithHttpInfo (Dictionary<string, SpecificationUIVisibleRequest> body, long? instrumentationId);
        /// <summary>
        /// Update specifications of a node
        /// </summary>
        /// <remarks>
        /// Update the specification object of a node in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UpdateSpecificationsOfNodeAsync (Dictionary<string, SpecificationUIVisibleRequest> body, long? nodeId);

        /// <summary>
        /// Update specifications of a node
        /// </summary>
        /// <remarks>
        /// Update the specification object of a node in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSpecificationsOfNodeAsyncWithHttpInfo (Dictionary<string, SpecificationUIVisibleRequest> body, long? nodeId);
        /// <summary>
        /// Update specifications of a product
        /// </summary>
        /// <remarks>
        /// Update the specification object of a product. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. If a key occurs more than once in the request body, the last key-value will be saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="productId">Id of the specified product</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UpdateSpecificationsOfProductAsync (Dictionary<string, SpecificationRequest> body, long? productId);

        /// <summary>
        /// Update specifications of a product
        /// </summary>
        /// <remarks>
        /// Update the specification object of a product. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. If a key occurs more than once in the request body, the last key-value will be saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="productId">Id of the specified product</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSpecificationsOfProductAsyncWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? productId);
        /// <summary>
        /// Update specifications of an recipe
        /// </summary>
        /// <remarks>
        /// Update the specification object of an recipe in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UpdateSpecificationsOfRecipeAsync (Dictionary<string, SpecificationRequest> body, long? recipeId);

        /// <summary>
        /// Update specifications of an recipe
        /// </summary>
        /// <remarks>
        /// Update the specification object of an recipe in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSpecificationsOfRecipeAsyncWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? recipeId);
        /// <summary>
        /// Update specifications of a subscription
        /// </summary>
        /// <remarks>
        /// Update the specification object of a subscription in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UpdateSpecificationsOfSubscriptionsAsync (Dictionary<string, SpecificationRequest> body, long? subscriptionId);

        /// <summary>
        /// Update specifications of a subscription
        /// </summary>
        /// <remarks>
        /// Update the specification object of a subscription in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSpecificationsOfSubscriptionsAsyncWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? subscriptionId);
        /// <summary>
        /// Update specifications of a system
        /// </summary>
        /// <remarks>
        /// Update the specification object of a system in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="systemId">Id of the specified system</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UpdateSpecificationsOfSystemAsync (Dictionary<string, SpecificationRequest> body, long? systemId);

        /// <summary>
        /// Update specifications of a system
        /// </summary>
        /// <remarks>
        /// Update the specification object of a system in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="systemId">Id of the specified system</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSpecificationsOfSystemAsyncWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? systemId);
        /// <summary>
        /// Update specifications of a user
        /// </summary>
        /// <remarks>
        /// Update the specification object of a user in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="userId">Id of the specified user</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UpdateSpecificationsOfUsersAsync (Dictionary<string, SpecificationRequest> body, long? userId);

        /// <summary>
        /// Update specifications of a user
        /// </summary>
        /// <remarks>
        /// Update the specification object of a user in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="userId">Id of the specified user</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSpecificationsOfUsersAsyncWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? userId);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
        public partial class SpecificationApi : ISpecificationApi
    {
        private Netilion.Api.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="SpecificationApi"/> class.
        /// </summary>
        /// <returns></returns>
        public SpecificationApi(String basePath)
        {
            this.Configuration = new Netilion.Api.Client.Configuration { BasePath = basePath };

            ExceptionFactory = Netilion.Api.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SpecificationApi"/> class
        /// </summary>
        /// <returns></returns>
        public SpecificationApi()
        {
            this.Configuration = Netilion.Api.Client.Configuration.Default;

            ExceptionFactory = Netilion.Api.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SpecificationApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public SpecificationApi(Netilion.Api.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = Netilion.Api.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = Netilion.Api.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Netilion.Api.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Netilion.Api.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Delete specifications of an asset The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="assetId">Id of the specified asset</param>
        /// <returns></returns>
        public void DeleteSpecificationsOfAsset (List<string> body, long? assetId)
        {
             DeleteSpecificationsOfAssetWithHttpInfo(body, assetId);
        }

        /// <summary>
        /// Delete specifications of an asset The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="assetId">Id of the specified asset</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteSpecificationsOfAssetWithHttpInfo (List<string> body, long? assetId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->DeleteSpecificationsOfAsset");
            // verify the required parameter 'assetId' is set
            if (assetId == null)
                throw new ApiException(400, "Missing required parameter 'assetId' when calling SpecificationApi->DeleteSpecificationsOfAsset");

            var localVarPath = "/assets/{asset_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (assetId != null) localVarPathParams.Add("asset_id", this.Configuration.ApiClient.ParameterToString(assetId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteSpecificationsOfAsset", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete specifications of an asset The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="assetId">Id of the specified asset</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteSpecificationsOfAssetAsync (List<string> body, long? assetId)
        {
             await DeleteSpecificationsOfAssetAsyncWithHttpInfo(body, assetId);

        }

        /// <summary>
        /// Delete specifications of an asset The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="assetId">Id of the specified asset</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> DeleteSpecificationsOfAssetAsyncWithHttpInfo (List<string> body, long? assetId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->DeleteSpecificationsOfAsset");
            // verify the required parameter 'assetId' is set
            if (assetId == null)
                throw new ApiException(400, "Missing required parameter 'assetId' when calling SpecificationApi->DeleteSpecificationsOfAsset");

            var localVarPath = "/assets/{asset_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (assetId != null) localVarPathParams.Add("asset_id", this.Configuration.ApiClient.ParameterToString(assetId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteSpecificationsOfAsset", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Get the history of one specification attribute of an asset. This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetId">Id of the specified asset</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>SpecificationHistoryResponse</returns>
        public SpecificationHistoryResponse GetSpecificationHistoryOfAsset (long? assetId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null)
        {
             ApiResponse<SpecificationHistoryResponse> localVarResponse = GetSpecificationHistoryOfAssetWithHttpInfo(assetId, key, page, perPage, sourceTimestampFrom, sourceTimestampTo, updatedAtFrom, updatedAtTo, orderBy);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get the history of one specification attribute of an asset. This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetId">Id of the specified asset</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>ApiResponse of SpecificationHistoryResponse</returns>
        public ApiResponse< SpecificationHistoryResponse > GetSpecificationHistoryOfAssetWithHttpInfo (long? assetId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null)
        {
            // verify the required parameter 'assetId' is set
            if (assetId == null)
                throw new ApiException(400, "Missing required parameter 'assetId' when calling SpecificationApi->GetSpecificationHistoryOfAsset");
            // verify the required parameter 'key' is set
            if (key == null)
                throw new ApiException(400, "Missing required parameter 'key' when calling SpecificationApi->GetSpecificationHistoryOfAsset");

            var localVarPath = "/assets/{asset_id}/specifications/{key}/history";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (assetId != null) localVarPathParams.Add("asset_id", this.Configuration.ApiClient.ParameterToString(assetId)); // path parameter
            if (key != null) localVarPathParams.Add("key", this.Configuration.ApiClient.ParameterToString(key)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (sourceTimestampFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "source_timestamp_from", sourceTimestampFrom)); // query parameter
            if (sourceTimestampTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "source_timestamp_to", sourceTimestampTo)); // query parameter
            if (updatedAtFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_from", updatedAtFrom)); // query parameter
            if (updatedAtTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_to", updatedAtTo)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationHistoryOfAsset", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationHistoryResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationHistoryResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationHistoryResponse)));
        }

        /// <summary>
        /// Get the history of one specification attribute of an asset. This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetId">Id of the specified asset</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>Task of SpecificationHistoryResponse</returns>
        public async System.Threading.Tasks.Task<SpecificationHistoryResponse> GetSpecificationHistoryOfAssetAsync (long? assetId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null)
        {
             ApiResponse<SpecificationHistoryResponse> localVarResponse = await GetSpecificationHistoryOfAssetAsyncWithHttpInfo(assetId, key, page, perPage, sourceTimestampFrom, sourceTimestampTo, updatedAtFrom, updatedAtTo, orderBy);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get the history of one specification attribute of an asset. This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetId">Id of the specified asset</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationHistoryResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SpecificationHistoryResponse>> GetSpecificationHistoryOfAssetAsyncWithHttpInfo (long? assetId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null)
        {
            // verify the required parameter 'assetId' is set
            if (assetId == null)
                throw new ApiException(400, "Missing required parameter 'assetId' when calling SpecificationApi->GetSpecificationHistoryOfAsset");
            // verify the required parameter 'key' is set
            if (key == null)
                throw new ApiException(400, "Missing required parameter 'key' when calling SpecificationApi->GetSpecificationHistoryOfAsset");

            var localVarPath = "/assets/{asset_id}/specifications/{key}/history";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (assetId != null) localVarPathParams.Add("asset_id", this.Configuration.ApiClient.ParameterToString(assetId)); // path parameter
            if (key != null) localVarPathParams.Add("key", this.Configuration.ApiClient.ParameterToString(key)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (sourceTimestampFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "source_timestamp_from", sourceTimestampFrom)); // query parameter
            if (sourceTimestampTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "source_timestamp_to", sourceTimestampTo)); // query parameter
            if (updatedAtFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_from", updatedAtFrom)); // query parameter
            if (updatedAtTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_to", updatedAtTo)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationHistoryOfAsset", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationHistoryResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationHistoryResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationHistoryResponse)));
        }

        /// <summary>
        /// Get the history of one specification attribute of a batch. This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="batchId">Id of the specified batch</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>SpecificationHistoryResponse</returns>
        public SpecificationHistoryResponse GetSpecificationHistoryOfBatch (long? batchId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null)
        {
             ApiResponse<SpecificationHistoryResponse> localVarResponse = GetSpecificationHistoryOfBatchWithHttpInfo(batchId, key, page, perPage, sourceTimestampFrom, sourceTimestampTo, updatedAtFrom, updatedAtTo, orderBy);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get the history of one specification attribute of a batch. This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="batchId">Id of the specified batch</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>ApiResponse of SpecificationHistoryResponse</returns>
        public ApiResponse< SpecificationHistoryResponse > GetSpecificationHistoryOfBatchWithHttpInfo (long? batchId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null)
        {
            // verify the required parameter 'batchId' is set
            if (batchId == null)
                throw new ApiException(400, "Missing required parameter 'batchId' when calling SpecificationApi->GetSpecificationHistoryOfBatch");
            // verify the required parameter 'key' is set
            if (key == null)
                throw new ApiException(400, "Missing required parameter 'key' when calling SpecificationApi->GetSpecificationHistoryOfBatch");

            var localVarPath = "/batches/{batch_id}/specifications/{key}/history";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (batchId != null) localVarPathParams.Add("batch_id", this.Configuration.ApiClient.ParameterToString(batchId)); // path parameter
            if (key != null) localVarPathParams.Add("key", this.Configuration.ApiClient.ParameterToString(key)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (sourceTimestampFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "source_timestamp_from", sourceTimestampFrom)); // query parameter
            if (sourceTimestampTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "source_timestamp_to", sourceTimestampTo)); // query parameter
            if (updatedAtFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_from", updatedAtFrom)); // query parameter
            if (updatedAtTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_to", updatedAtTo)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationHistoryOfBatch", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationHistoryResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationHistoryResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationHistoryResponse)));
        }

        /// <summary>
        /// Get the history of one specification attribute of a batch. This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="batchId">Id of the specified batch</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>Task of SpecificationHistoryResponse</returns>
        public async System.Threading.Tasks.Task<SpecificationHistoryResponse> GetSpecificationHistoryOfBatchAsync (long? batchId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null)
        {
             ApiResponse<SpecificationHistoryResponse> localVarResponse = await GetSpecificationHistoryOfBatchAsyncWithHttpInfo(batchId, key, page, perPage, sourceTimestampFrom, sourceTimestampTo, updatedAtFrom, updatedAtTo, orderBy);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get the history of one specification attribute of a batch. This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="batchId">Id of the specified batch</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationHistoryResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SpecificationHistoryResponse>> GetSpecificationHistoryOfBatchAsyncWithHttpInfo (long? batchId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null)
        {
            // verify the required parameter 'batchId' is set
            if (batchId == null)
                throw new ApiException(400, "Missing required parameter 'batchId' when calling SpecificationApi->GetSpecificationHistoryOfBatch");
            // verify the required parameter 'key' is set
            if (key == null)
                throw new ApiException(400, "Missing required parameter 'key' when calling SpecificationApi->GetSpecificationHistoryOfBatch");

            var localVarPath = "/batches/{batch_id}/specifications/{key}/history";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (batchId != null) localVarPathParams.Add("batch_id", this.Configuration.ApiClient.ParameterToString(batchId)); // path parameter
            if (key != null) localVarPathParams.Add("key", this.Configuration.ApiClient.ParameterToString(key)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (sourceTimestampFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "source_timestamp_from", sourceTimestampFrom)); // query parameter
            if (sourceTimestampTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "source_timestamp_to", sourceTimestampTo)); // query parameter
            if (updatedAtFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_from", updatedAtFrom)); // query parameter
            if (updatedAtTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_to", updatedAtTo)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationHistoryOfBatch", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationHistoryResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationHistoryResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationHistoryResponse)));
        }

        /// <summary>
        /// Get the history of one specification attribute of an instrumentation. This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>SpecificationHistoryResponse</returns>
        public SpecificationHistoryResponse GetSpecificationHistoryOfInstrumentation (long? instrumentationId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null)
        {
             ApiResponse<SpecificationHistoryResponse> localVarResponse = GetSpecificationHistoryOfInstrumentationWithHttpInfo(instrumentationId, key, page, perPage, sourceTimestampFrom, sourceTimestampTo, updatedAtFrom, updatedAtTo, orderBy);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get the history of one specification attribute of an instrumentation. This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>ApiResponse of SpecificationHistoryResponse</returns>
        public ApiResponse< SpecificationHistoryResponse > GetSpecificationHistoryOfInstrumentationWithHttpInfo (long? instrumentationId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling SpecificationApi->GetSpecificationHistoryOfInstrumentation");
            // verify the required parameter 'key' is set
            if (key == null)
                throw new ApiException(400, "Missing required parameter 'key' when calling SpecificationApi->GetSpecificationHistoryOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/specifications/{key}/history";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (key != null) localVarPathParams.Add("key", this.Configuration.ApiClient.ParameterToString(key)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (sourceTimestampFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "source_timestamp_from", sourceTimestampFrom)); // query parameter
            if (sourceTimestampTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "source_timestamp_to", sourceTimestampTo)); // query parameter
            if (updatedAtFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_from", updatedAtFrom)); // query parameter
            if (updatedAtTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_to", updatedAtTo)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationHistoryOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationHistoryResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationHistoryResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationHistoryResponse)));
        }

        /// <summary>
        /// Get the history of one specification attribute of an instrumentation. This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>Task of SpecificationHistoryResponse</returns>
        public async System.Threading.Tasks.Task<SpecificationHistoryResponse> GetSpecificationHistoryOfInstrumentationAsync (long? instrumentationId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null)
        {
             ApiResponse<SpecificationHistoryResponse> localVarResponse = await GetSpecificationHistoryOfInstrumentationAsyncWithHttpInfo(instrumentationId, key, page, perPage, sourceTimestampFrom, sourceTimestampTo, updatedAtFrom, updatedAtTo, orderBy);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get the history of one specification attribute of an instrumentation. This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationHistoryResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SpecificationHistoryResponse>> GetSpecificationHistoryOfInstrumentationAsyncWithHttpInfo (long? instrumentationId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling SpecificationApi->GetSpecificationHistoryOfInstrumentation");
            // verify the required parameter 'key' is set
            if (key == null)
                throw new ApiException(400, "Missing required parameter 'key' when calling SpecificationApi->GetSpecificationHistoryOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/specifications/{key}/history";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (key != null) localVarPathParams.Add("key", this.Configuration.ApiClient.ParameterToString(key)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (sourceTimestampFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "source_timestamp_from", sourceTimestampFrom)); // query parameter
            if (sourceTimestampTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "source_timestamp_to", sourceTimestampTo)); // query parameter
            if (updatedAtFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_from", updatedAtFrom)); // query parameter
            if (updatedAtTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_to", updatedAtTo)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationHistoryOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationHistoryResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationHistoryResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationHistoryResponse)));
        }

        /// <summary>
        /// Get the history of one specification attribute of an recipe. This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>SpecificationHistoryResponse</returns>
        public SpecificationHistoryResponse GetSpecificationHistoryOfRecipe (long? recipeId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null)
        {
             ApiResponse<SpecificationHistoryResponse> localVarResponse = GetSpecificationHistoryOfRecipeWithHttpInfo(recipeId, key, page, perPage, sourceTimestampFrom, sourceTimestampTo, updatedAtFrom, updatedAtTo, orderBy);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get the history of one specification attribute of an recipe. This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>ApiResponse of SpecificationHistoryResponse</returns>
        public ApiResponse< SpecificationHistoryResponse > GetSpecificationHistoryOfRecipeWithHttpInfo (long? recipeId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null)
        {
            // verify the required parameter 'recipeId' is set
            if (recipeId == null)
                throw new ApiException(400, "Missing required parameter 'recipeId' when calling SpecificationApi->GetSpecificationHistoryOfRecipe");
            // verify the required parameter 'key' is set
            if (key == null)
                throw new ApiException(400, "Missing required parameter 'key' when calling SpecificationApi->GetSpecificationHistoryOfRecipe");

            var localVarPath = "/recipes/{recipe_id}/specifications/{key}/history";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (recipeId != null) localVarPathParams.Add("recipe_id", this.Configuration.ApiClient.ParameterToString(recipeId)); // path parameter
            if (key != null) localVarPathParams.Add("key", this.Configuration.ApiClient.ParameterToString(key)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (sourceTimestampFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "source_timestamp_from", sourceTimestampFrom)); // query parameter
            if (sourceTimestampTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "source_timestamp_to", sourceTimestampTo)); // query parameter
            if (updatedAtFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_from", updatedAtFrom)); // query parameter
            if (updatedAtTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_to", updatedAtTo)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationHistoryOfRecipe", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationHistoryResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationHistoryResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationHistoryResponse)));
        }

        /// <summary>
        /// Get the history of one specification attribute of an recipe. This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>Task of SpecificationHistoryResponse</returns>
        public async System.Threading.Tasks.Task<SpecificationHistoryResponse> GetSpecificationHistoryOfRecipeAsync (long? recipeId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null)
        {
             ApiResponse<SpecificationHistoryResponse> localVarResponse = await GetSpecificationHistoryOfRecipeAsyncWithHttpInfo(recipeId, key, page, perPage, sourceTimestampFrom, sourceTimestampTo, updatedAtFrom, updatedAtTo, orderBy);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get the history of one specification attribute of an recipe. This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationHistoryResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SpecificationHistoryResponse>> GetSpecificationHistoryOfRecipeAsyncWithHttpInfo (long? recipeId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null)
        {
            // verify the required parameter 'recipeId' is set
            if (recipeId == null)
                throw new ApiException(400, "Missing required parameter 'recipeId' when calling SpecificationApi->GetSpecificationHistoryOfRecipe");
            // verify the required parameter 'key' is set
            if (key == null)
                throw new ApiException(400, "Missing required parameter 'key' when calling SpecificationApi->GetSpecificationHistoryOfRecipe");

            var localVarPath = "/recipes/{recipe_id}/specifications/{key}/history";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (recipeId != null) localVarPathParams.Add("recipe_id", this.Configuration.ApiClient.ParameterToString(recipeId)); // path parameter
            if (key != null) localVarPathParams.Add("key", this.Configuration.ApiClient.ParameterToString(key)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (sourceTimestampFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "source_timestamp_from", sourceTimestampFrom)); // query parameter
            if (sourceTimestampTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "source_timestamp_to", sourceTimestampTo)); // query parameter
            if (updatedAtFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_from", updatedAtFrom)); // query parameter
            if (updatedAtTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_to", updatedAtTo)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationHistoryOfRecipe", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationHistoryResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationHistoryResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationHistoryResponse)));
        }

        /// <summary>
        /// Get the history of one specification attribute of a system. This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="systemId">Id of the specified system</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>SpecificationHistoryResponse</returns>
        public SpecificationHistoryResponse GetSpecificationHistoryOfSystem (long? systemId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null)
        {
             ApiResponse<SpecificationHistoryResponse> localVarResponse = GetSpecificationHistoryOfSystemWithHttpInfo(systemId, key, page, perPage, sourceTimestampFrom, sourceTimestampTo, updatedAtFrom, updatedAtTo, orderBy);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get the history of one specification attribute of a system. This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="systemId">Id of the specified system</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>ApiResponse of SpecificationHistoryResponse</returns>
        public ApiResponse< SpecificationHistoryResponse > GetSpecificationHistoryOfSystemWithHttpInfo (long? systemId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null)
        {
            // verify the required parameter 'systemId' is set
            if (systemId == null)
                throw new ApiException(400, "Missing required parameter 'systemId' when calling SpecificationApi->GetSpecificationHistoryOfSystem");
            // verify the required parameter 'key' is set
            if (key == null)
                throw new ApiException(400, "Missing required parameter 'key' when calling SpecificationApi->GetSpecificationHistoryOfSystem");

            var localVarPath = "/systems/{system_id}/specifications/{key}/history";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (systemId != null) localVarPathParams.Add("system_id", this.Configuration.ApiClient.ParameterToString(systemId)); // path parameter
            if (key != null) localVarPathParams.Add("key", this.Configuration.ApiClient.ParameterToString(key)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (sourceTimestampFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "source_timestamp_from", sourceTimestampFrom)); // query parameter
            if (sourceTimestampTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "source_timestamp_to", sourceTimestampTo)); // query parameter
            if (updatedAtFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_from", updatedAtFrom)); // query parameter
            if (updatedAtTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_to", updatedAtTo)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationHistoryOfSystem", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationHistoryResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationHistoryResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationHistoryResponse)));
        }

        /// <summary>
        /// Get the history of one specification attribute of a system. This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="systemId">Id of the specified system</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>Task of SpecificationHistoryResponse</returns>
        public async System.Threading.Tasks.Task<SpecificationHistoryResponse> GetSpecificationHistoryOfSystemAsync (long? systemId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null)
        {
             ApiResponse<SpecificationHistoryResponse> localVarResponse = await GetSpecificationHistoryOfSystemAsyncWithHttpInfo(systemId, key, page, perPage, sourceTimestampFrom, sourceTimestampTo, updatedAtFrom, updatedAtTo, orderBy);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get the history of one specification attribute of a system. This might be useful for history data. The response contains a collection of historic values and when they&#x60;ve been updated. Since this can be a lot of data the service uses pagination. The history can be filtered by using a date range of source_timestamp and/or updated_at. Please consider that source_timestamp is not required and update on the attribute without giving a source_timestamp wont be included in the resulting response
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="systemId">Id of the specified system</param>
        /// <param name="key">the exact key</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="sourceTimestampFrom">source_timestamp filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="sourceTimestampTo">source_timestamp filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtFrom">updated_at filter from. Starting with + will include the previous value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">updated_at filter to. Ending with + will include the next value as well. Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;source_timestamp&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationHistoryResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SpecificationHistoryResponse>> GetSpecificationHistoryOfSystemAsyncWithHttpInfo (long? systemId, string key, int? page = null, int? perPage = null, DateTime? sourceTimestampFrom = null, DateTime? sourceTimestampTo = null, DateTime? updatedAtFrom = null, DateTime? updatedAtTo = null, string orderBy = null)
        {
            // verify the required parameter 'systemId' is set
            if (systemId == null)
                throw new ApiException(400, "Missing required parameter 'systemId' when calling SpecificationApi->GetSpecificationHistoryOfSystem");
            // verify the required parameter 'key' is set
            if (key == null)
                throw new ApiException(400, "Missing required parameter 'key' when calling SpecificationApi->GetSpecificationHistoryOfSystem");

            var localVarPath = "/systems/{system_id}/specifications/{key}/history";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (systemId != null) localVarPathParams.Add("system_id", this.Configuration.ApiClient.ParameterToString(systemId)); // path parameter
            if (key != null) localVarPathParams.Add("key", this.Configuration.ApiClient.ParameterToString(key)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (sourceTimestampFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "source_timestamp_from", sourceTimestampFrom)); // query parameter
            if (sourceTimestampTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "source_timestamp_to", sourceTimestampTo)); // query parameter
            if (updatedAtFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_from", updatedAtFrom)); // query parameter
            if (updatedAtTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_to", updatedAtTo)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationHistoryOfSystem", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationHistoryResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationHistoryResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationHistoryResponse)));
        }

        /// <summary>
        /// Get existing asset specification keys Returns the existing specification keys in all readable assets.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>SpecificationKeys</returns>
        public SpecificationKeys GetSpecificationKeysOfAssets (string key = null, bool? uiVisible = null)
        {
             ApiResponse<SpecificationKeys> localVarResponse = GetSpecificationKeysOfAssetsWithHttpInfo(key, uiVisible);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get existing asset specification keys Returns the existing specification keys in all readable assets.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>ApiResponse of SpecificationKeys</returns>
        public ApiResponse< SpecificationKeys > GetSpecificationKeysOfAssetsWithHttpInfo (string key = null, bool? uiVisible = null)
        {

            var localVarPath = "/asset/specification_keys";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            if (uiVisible != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ui_visible", uiVisible)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationKeysOfAssets", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationKeys>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationKeys) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationKeys)));
        }

        /// <summary>
        /// Get existing asset specification keys Returns the existing specification keys in all readable assets.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of SpecificationKeys</returns>
        public async System.Threading.Tasks.Task<SpecificationKeys> GetSpecificationKeysOfAssetsAsync (string key = null, bool? uiVisible = null)
        {
             ApiResponse<SpecificationKeys> localVarResponse = await GetSpecificationKeysOfAssetsAsyncWithHttpInfo(key, uiVisible);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get existing asset specification keys Returns the existing specification keys in all readable assets.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationKeys)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SpecificationKeys>> GetSpecificationKeysOfAssetsAsyncWithHttpInfo (string key = null, bool? uiVisible = null)
        {

            var localVarPath = "/asset/specification_keys";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            if (uiVisible != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ui_visible", uiVisible)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationKeysOfAssets", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationKeys>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationKeys) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationKeys)));
        }

        /// <summary>
        /// Get existing instrumentation specification keys Returns the existing specification keys in all readable instrumentations.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>SpecificationKeys</returns>
        public SpecificationKeys GetSpecificationKeysOfInstrumentations (string key = null, bool? uiVisible = null)
        {
             ApiResponse<SpecificationKeys> localVarResponse = GetSpecificationKeysOfInstrumentationsWithHttpInfo(key, uiVisible);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get existing instrumentation specification keys Returns the existing specification keys in all readable instrumentations.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>ApiResponse of SpecificationKeys</returns>
        public ApiResponse< SpecificationKeys > GetSpecificationKeysOfInstrumentationsWithHttpInfo (string key = null, bool? uiVisible = null)
        {

            var localVarPath = "/instrumentation/specification_keys";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            if (uiVisible != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ui_visible", uiVisible)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationKeysOfInstrumentations", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationKeys>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationKeys) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationKeys)));
        }

        /// <summary>
        /// Get existing instrumentation specification keys Returns the existing specification keys in all readable instrumentations.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of SpecificationKeys</returns>
        public async System.Threading.Tasks.Task<SpecificationKeys> GetSpecificationKeysOfInstrumentationsAsync (string key = null, bool? uiVisible = null)
        {
             ApiResponse<SpecificationKeys> localVarResponse = await GetSpecificationKeysOfInstrumentationsAsyncWithHttpInfo(key, uiVisible);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get existing instrumentation specification keys Returns the existing specification keys in all readable instrumentations.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationKeys)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SpecificationKeys>> GetSpecificationKeysOfInstrumentationsAsyncWithHttpInfo (string key = null, bool? uiVisible = null)
        {

            var localVarPath = "/instrumentation/specification_keys";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            if (uiVisible != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ui_visible", uiVisible)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationKeysOfInstrumentations", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationKeys>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationKeys) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationKeys)));
        }

        /// <summary>
        /// Get existing asset specification keys Returns the existing specification keys in all readable nodes.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>SpecificationKeys</returns>
        public SpecificationKeys GetSpecificationKeysOfNodes (string key = null, bool? uiVisible = null)
        {
             ApiResponse<SpecificationKeys> localVarResponse = GetSpecificationKeysOfNodesWithHttpInfo(key, uiVisible);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get existing asset specification keys Returns the existing specification keys in all readable nodes.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>ApiResponse of SpecificationKeys</returns>
        public ApiResponse< SpecificationKeys > GetSpecificationKeysOfNodesWithHttpInfo (string key = null, bool? uiVisible = null)
        {

            var localVarPath = "/node/specification_keys";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            if (uiVisible != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ui_visible", uiVisible)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationKeysOfNodes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationKeys>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationKeys) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationKeys)));
        }

        /// <summary>
        /// Get existing asset specification keys Returns the existing specification keys in all readable nodes.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of SpecificationKeys</returns>
        public async System.Threading.Tasks.Task<SpecificationKeys> GetSpecificationKeysOfNodesAsync (string key = null, bool? uiVisible = null)
        {
             ApiResponse<SpecificationKeys> localVarResponse = await GetSpecificationKeysOfNodesAsyncWithHttpInfo(key, uiVisible);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get existing asset specification keys Returns the existing specification keys in all readable nodes.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationKeys)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SpecificationKeys>> GetSpecificationKeysOfNodesAsyncWithHttpInfo (string key = null, bool? uiVisible = null)
        {

            var localVarPath = "/node/specification_keys";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            if (uiVisible != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ui_visible", uiVisible)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationKeysOfNodes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationKeys>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationKeys) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationKeys)));
        }

        /// <summary>
        /// Get specifications of an api subscription Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the specified api subscription</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>SpecificationsResponse</returns>
        public SpecificationsResponse GetSpecificationsOfAPISubscription (long? id, string key = null)
        {
             ApiResponse<SpecificationsResponse> localVarResponse = GetSpecificationsOfAPISubscriptionWithHttpInfo(id, key);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get specifications of an api subscription Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the specified api subscription</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>ApiResponse of SpecificationsResponse</returns>
        public ApiResponse< SpecificationsResponse > GetSpecificationsOfAPISubscriptionWithHttpInfo (long? id, string key = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling SpecificationApi->GetSpecificationsOfAPISubscription");

            var localVarPath = "/api_subscriptions/{id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationsOfAPISubscription", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationsResponse)));
        }

        /// <summary>
        /// Get specifications of an api subscription Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the specified api subscription</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of SpecificationsResponse</returns>
        public async System.Threading.Tasks.Task<SpecificationsResponse> GetSpecificationsOfAPISubscriptionAsync (long? id, string key = null)
        {
             ApiResponse<SpecificationsResponse> localVarResponse = await GetSpecificationsOfAPISubscriptionAsyncWithHttpInfo(id, key);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get specifications of an api subscription Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the specified api subscription</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationsResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SpecificationsResponse>> GetSpecificationsOfAPISubscriptionAsyncWithHttpInfo (long? id, string key = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling SpecificationApi->GetSpecificationsOfAPISubscription");

            var localVarPath = "/api_subscriptions/{id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationsOfAPISubscription", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationsResponse)));
        }

        /// <summary>
        /// Get specifications of an asset Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetId">Id of the specified asset</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>SpecificationsUIVisibleResponse</returns>
        public SpecificationsUIVisibleResponse GetSpecificationsOfAsset (long? assetId, string key = null, bool? uiVisible = null)
        {
             ApiResponse<SpecificationsUIVisibleResponse> localVarResponse = GetSpecificationsOfAssetWithHttpInfo(assetId, key, uiVisible);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get specifications of an asset Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetId">Id of the specified asset</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>ApiResponse of SpecificationsUIVisibleResponse</returns>
        public ApiResponse< SpecificationsUIVisibleResponse > GetSpecificationsOfAssetWithHttpInfo (long? assetId, string key = null, bool? uiVisible = null)
        {
            // verify the required parameter 'assetId' is set
            if (assetId == null)
                throw new ApiException(400, "Missing required parameter 'assetId' when calling SpecificationApi->GetSpecificationsOfAsset");

            var localVarPath = "/assets/{asset_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (assetId != null) localVarPathParams.Add("asset_id", this.Configuration.ApiClient.ParameterToString(assetId)); // path parameter
            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            if (uiVisible != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ui_visible", uiVisible)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationsOfAsset", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationsUIVisibleResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationsUIVisibleResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationsUIVisibleResponse)));
        }

        /// <summary>
        /// Get specifications of an asset Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetId">Id of the specified asset</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of SpecificationsUIVisibleResponse</returns>
        public async System.Threading.Tasks.Task<SpecificationsUIVisibleResponse> GetSpecificationsOfAssetAsync (long? assetId, string key = null, bool? uiVisible = null)
        {
             ApiResponse<SpecificationsUIVisibleResponse> localVarResponse = await GetSpecificationsOfAssetAsyncWithHttpInfo(assetId, key, uiVisible);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get specifications of an asset Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetId">Id of the specified asset</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationsUIVisibleResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SpecificationsUIVisibleResponse>> GetSpecificationsOfAssetAsyncWithHttpInfo (long? assetId, string key = null, bool? uiVisible = null)
        {
            // verify the required parameter 'assetId' is set
            if (assetId == null)
                throw new ApiException(400, "Missing required parameter 'assetId' when calling SpecificationApi->GetSpecificationsOfAsset");

            var localVarPath = "/assets/{asset_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (assetId != null) localVarPathParams.Add("asset_id", this.Configuration.ApiClient.ParameterToString(assetId)); // path parameter
            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            if (uiVisible != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ui_visible", uiVisible)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationsOfAsset", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationsUIVisibleResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationsUIVisibleResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationsUIVisibleResponse)));
        }

        /// <summary>
        /// Get specifications of a batch Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="batchId">Id of the specified batch</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>SpecificationsResponse</returns>
        public SpecificationsResponse GetSpecificationsOfBatch (long? batchId, string key = null)
        {
             ApiResponse<SpecificationsResponse> localVarResponse = GetSpecificationsOfBatchWithHttpInfo(batchId, key);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get specifications of a batch Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="batchId">Id of the specified batch</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>ApiResponse of SpecificationsResponse</returns>
        public ApiResponse< SpecificationsResponse > GetSpecificationsOfBatchWithHttpInfo (long? batchId, string key = null)
        {
            // verify the required parameter 'batchId' is set
            if (batchId == null)
                throw new ApiException(400, "Missing required parameter 'batchId' when calling SpecificationApi->GetSpecificationsOfBatch");

            var localVarPath = "/batches/{batch_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (batchId != null) localVarPathParams.Add("batch_id", this.Configuration.ApiClient.ParameterToString(batchId)); // path parameter
            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationsOfBatch", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationsResponse)));
        }

        /// <summary>
        /// Get specifications of a batch Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="batchId">Id of the specified batch</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of SpecificationsResponse</returns>
        public async System.Threading.Tasks.Task<SpecificationsResponse> GetSpecificationsOfBatchAsync (long? batchId, string key = null)
        {
             ApiResponse<SpecificationsResponse> localVarResponse = await GetSpecificationsOfBatchAsyncWithHttpInfo(batchId, key);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get specifications of a batch Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="batchId">Id of the specified batch</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationsResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SpecificationsResponse>> GetSpecificationsOfBatchAsyncWithHttpInfo (long? batchId, string key = null)
        {
            // verify the required parameter 'batchId' is set
            if (batchId == null)
                throw new ApiException(400, "Missing required parameter 'batchId' when calling SpecificationApi->GetSpecificationsOfBatch");

            var localVarPath = "/batches/{batch_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (batchId != null) localVarPathParams.Add("batch_id", this.Configuration.ApiClient.ParameterToString(batchId)); // path parameter
            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationsOfBatch", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationsResponse)));
        }

        /// <summary>
        /// Get specifications of an event Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>SpecificationsResponse</returns>
        public SpecificationsResponse GetSpecificationsOfEvent (long? eventId, string key = null)
        {
             ApiResponse<SpecificationsResponse> localVarResponse = GetSpecificationsOfEventWithHttpInfo(eventId, key);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get specifications of an event Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>ApiResponse of SpecificationsResponse</returns>
        public ApiResponse< SpecificationsResponse > GetSpecificationsOfEventWithHttpInfo (long? eventId, string key = null)
        {
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling SpecificationApi->GetSpecificationsOfEvent");

            var localVarPath = "/events/{event_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationsOfEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationsResponse)));
        }

        /// <summary>
        /// Get specifications of an event Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of SpecificationsResponse</returns>
        public async System.Threading.Tasks.Task<SpecificationsResponse> GetSpecificationsOfEventAsync (long? eventId, string key = null)
        {
             ApiResponse<SpecificationsResponse> localVarResponse = await GetSpecificationsOfEventAsyncWithHttpInfo(eventId, key);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get specifications of an event Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationsResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SpecificationsResponse>> GetSpecificationsOfEventAsyncWithHttpInfo (long? eventId, string key = null)
        {
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling SpecificationApi->GetSpecificationsOfEvent");

            var localVarPath = "/events/{event_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationsOfEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationsResponse)));
        }

        /// <summary>
        /// Get specifications of an instrumentation Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>SpecificationsUIVisibleResponse</returns>
        public SpecificationsUIVisibleResponse GetSpecificationsOfInstrumentation (long? instrumentationId, string key = null, bool? uiVisible = null)
        {
             ApiResponse<SpecificationsUIVisibleResponse> localVarResponse = GetSpecificationsOfInstrumentationWithHttpInfo(instrumentationId, key, uiVisible);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get specifications of an instrumentation Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>ApiResponse of SpecificationsUIVisibleResponse</returns>
        public ApiResponse< SpecificationsUIVisibleResponse > GetSpecificationsOfInstrumentationWithHttpInfo (long? instrumentationId, string key = null, bool? uiVisible = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling SpecificationApi->GetSpecificationsOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            if (uiVisible != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ui_visible", uiVisible)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationsOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationsUIVisibleResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationsUIVisibleResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationsUIVisibleResponse)));
        }

        /// <summary>
        /// Get specifications of an instrumentation Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of SpecificationsUIVisibleResponse</returns>
        public async System.Threading.Tasks.Task<SpecificationsUIVisibleResponse> GetSpecificationsOfInstrumentationAsync (long? instrumentationId, string key = null, bool? uiVisible = null)
        {
             ApiResponse<SpecificationsUIVisibleResponse> localVarResponse = await GetSpecificationsOfInstrumentationAsyncWithHttpInfo(instrumentationId, key, uiVisible);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get specifications of an instrumentation Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationsUIVisibleResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SpecificationsUIVisibleResponse>> GetSpecificationsOfInstrumentationAsyncWithHttpInfo (long? instrumentationId, string key = null, bool? uiVisible = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling SpecificationApi->GetSpecificationsOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            if (uiVisible != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ui_visible", uiVisible)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationsOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationsUIVisibleResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationsUIVisibleResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationsUIVisibleResponse)));
        }

        /// <summary>
        /// Get specifications of a node Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the specified node</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>SpecificationsUIVisibleResponse</returns>
        public SpecificationsUIVisibleResponse GetSpecificationsOfNode (long? nodeId, string key = null, bool? uiVisible = null)
        {
             ApiResponse<SpecificationsUIVisibleResponse> localVarResponse = GetSpecificationsOfNodeWithHttpInfo(nodeId, key, uiVisible);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get specifications of a node Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the specified node</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>ApiResponse of SpecificationsUIVisibleResponse</returns>
        public ApiResponse< SpecificationsUIVisibleResponse > GetSpecificationsOfNodeWithHttpInfo (long? nodeId, string key = null, bool? uiVisible = null)
        {
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling SpecificationApi->GetSpecificationsOfNode");

            var localVarPath = "/nodes/{node_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            if (uiVisible != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ui_visible", uiVisible)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationsOfNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationsUIVisibleResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationsUIVisibleResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationsUIVisibleResponse)));
        }

        /// <summary>
        /// Get specifications of a node Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the specified node</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of SpecificationsUIVisibleResponse</returns>
        public async System.Threading.Tasks.Task<SpecificationsUIVisibleResponse> GetSpecificationsOfNodeAsync (long? nodeId, string key = null, bool? uiVisible = null)
        {
             ApiResponse<SpecificationsUIVisibleResponse> localVarResponse = await GetSpecificationsOfNodeAsyncWithHttpInfo(nodeId, key, uiVisible);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get specifications of a node Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the specified node</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationsUIVisibleResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SpecificationsUIVisibleResponse>> GetSpecificationsOfNodeAsyncWithHttpInfo (long? nodeId, string key = null, bool? uiVisible = null)
        {
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling SpecificationApi->GetSpecificationsOfNode");

            var localVarPath = "/nodes/{node_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            if (uiVisible != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ui_visible", uiVisible)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationsOfNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationsUIVisibleResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationsUIVisibleResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationsUIVisibleResponse)));
        }

        /// <summary>
        /// Get specifications of a product Returns the specification of an object. If no specifications are defined, this is just an empty object.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="productId">Id of the specified product</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>SpecificationsResponse</returns>
        public SpecificationsResponse GetSpecificationsOfProduct (long? productId, string key = null)
        {
             ApiResponse<SpecificationsResponse> localVarResponse = GetSpecificationsOfProductWithHttpInfo(productId, key);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get specifications of a product Returns the specification of an object. If no specifications are defined, this is just an empty object.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="productId">Id of the specified product</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>ApiResponse of SpecificationsResponse</returns>
        public ApiResponse< SpecificationsResponse > GetSpecificationsOfProductWithHttpInfo (long? productId, string key = null)
        {
            // verify the required parameter 'productId' is set
            if (productId == null)
                throw new ApiException(400, "Missing required parameter 'productId' when calling SpecificationApi->GetSpecificationsOfProduct");

            var localVarPath = "/products/{product_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (productId != null) localVarPathParams.Add("product_id", this.Configuration.ApiClient.ParameterToString(productId)); // path parameter
            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationsOfProduct", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationsResponse)));
        }

        /// <summary>
        /// Get specifications of a product Returns the specification of an object. If no specifications are defined, this is just an empty object.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="productId">Id of the specified product</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of SpecificationsResponse</returns>
        public async System.Threading.Tasks.Task<SpecificationsResponse> GetSpecificationsOfProductAsync (long? productId, string key = null)
        {
             ApiResponse<SpecificationsResponse> localVarResponse = await GetSpecificationsOfProductAsyncWithHttpInfo(productId, key);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get specifications of a product Returns the specification of an object. If no specifications are defined, this is just an empty object.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="productId">Id of the specified product</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationsResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SpecificationsResponse>> GetSpecificationsOfProductAsyncWithHttpInfo (long? productId, string key = null)
        {
            // verify the required parameter 'productId' is set
            if (productId == null)
                throw new ApiException(400, "Missing required parameter 'productId' when calling SpecificationApi->GetSpecificationsOfProduct");

            var localVarPath = "/products/{product_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (productId != null) localVarPathParams.Add("product_id", this.Configuration.ApiClient.ParameterToString(productId)); // path parameter
            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationsOfProduct", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationsResponse)));
        }

        /// <summary>
        /// Get specifications of an recipe Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>SpecificationsResponse</returns>
        public SpecificationsResponse GetSpecificationsOfRecipe (long? recipeId, string key = null)
        {
             ApiResponse<SpecificationsResponse> localVarResponse = GetSpecificationsOfRecipeWithHttpInfo(recipeId, key);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get specifications of an recipe Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>ApiResponse of SpecificationsResponse</returns>
        public ApiResponse< SpecificationsResponse > GetSpecificationsOfRecipeWithHttpInfo (long? recipeId, string key = null)
        {
            // verify the required parameter 'recipeId' is set
            if (recipeId == null)
                throw new ApiException(400, "Missing required parameter 'recipeId' when calling SpecificationApi->GetSpecificationsOfRecipe");

            var localVarPath = "/recipes/{recipe_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (recipeId != null) localVarPathParams.Add("recipe_id", this.Configuration.ApiClient.ParameterToString(recipeId)); // path parameter
            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationsOfRecipe", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationsResponse)));
        }

        /// <summary>
        /// Get specifications of an recipe Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of SpecificationsResponse</returns>
        public async System.Threading.Tasks.Task<SpecificationsResponse> GetSpecificationsOfRecipeAsync (long? recipeId, string key = null)
        {
             ApiResponse<SpecificationsResponse> localVarResponse = await GetSpecificationsOfRecipeAsyncWithHttpInfo(recipeId, key);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get specifications of an recipe Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationsResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SpecificationsResponse>> GetSpecificationsOfRecipeAsyncWithHttpInfo (long? recipeId, string key = null)
        {
            // verify the required parameter 'recipeId' is set
            if (recipeId == null)
                throw new ApiException(400, "Missing required parameter 'recipeId' when calling SpecificationApi->GetSpecificationsOfRecipe");

            var localVarPath = "/recipes/{recipe_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (recipeId != null) localVarPathParams.Add("recipe_id", this.Configuration.ApiClient.ParameterToString(recipeId)); // path parameter
            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationsOfRecipe", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationsResponse)));
        }

        /// <summary>
        /// Get specifications of a subscription Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>SpecificationsResponse</returns>
        public SpecificationsResponse GetSpecificationsOfSubscription (long? subscriptionId, string key = null)
        {
             ApiResponse<SpecificationsResponse> localVarResponse = GetSpecificationsOfSubscriptionWithHttpInfo(subscriptionId, key);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get specifications of a subscription Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>ApiResponse of SpecificationsResponse</returns>
        public ApiResponse< SpecificationsResponse > GetSpecificationsOfSubscriptionWithHttpInfo (long? subscriptionId, string key = null)
        {
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionId' when calling SpecificationApi->GetSpecificationsOfSubscription");

            var localVarPath = "/subscriptions/{subscription_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionId != null) localVarPathParams.Add("subscription_id", this.Configuration.ApiClient.ParameterToString(subscriptionId)); // path parameter
            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationsOfSubscription", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationsResponse)));
        }

        /// <summary>
        /// Get specifications of a subscription Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of SpecificationsResponse</returns>
        public async System.Threading.Tasks.Task<SpecificationsResponse> GetSpecificationsOfSubscriptionAsync (long? subscriptionId, string key = null)
        {
             ApiResponse<SpecificationsResponse> localVarResponse = await GetSpecificationsOfSubscriptionAsyncWithHttpInfo(subscriptionId, key);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get specifications of a subscription Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationsResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SpecificationsResponse>> GetSpecificationsOfSubscriptionAsyncWithHttpInfo (long? subscriptionId, string key = null)
        {
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionId' when calling SpecificationApi->GetSpecificationsOfSubscription");

            var localVarPath = "/subscriptions/{subscription_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionId != null) localVarPathParams.Add("subscription_id", this.Configuration.ApiClient.ParameterToString(subscriptionId)); // path parameter
            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationsOfSubscription", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationsResponse)));
        }

        /// <summary>
        /// Get specifications of a system Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="systemId">Id of the specified system</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>SpecificationsResponse</returns>
        public SpecificationsResponse GetSpecificationsOfSystem (long? systemId, string key = null)
        {
             ApiResponse<SpecificationsResponse> localVarResponse = GetSpecificationsOfSystemWithHttpInfo(systemId, key);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get specifications of a system Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="systemId">Id of the specified system</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>ApiResponse of SpecificationsResponse</returns>
        public ApiResponse< SpecificationsResponse > GetSpecificationsOfSystemWithHttpInfo (long? systemId, string key = null)
        {
            // verify the required parameter 'systemId' is set
            if (systemId == null)
                throw new ApiException(400, "Missing required parameter 'systemId' when calling SpecificationApi->GetSpecificationsOfSystem");

            var localVarPath = "/systems/{system_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (systemId != null) localVarPathParams.Add("system_id", this.Configuration.ApiClient.ParameterToString(systemId)); // path parameter
            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationsOfSystem", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationsResponse)));
        }

        /// <summary>
        /// Get specifications of a system Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="systemId">Id of the specified system</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of SpecificationsResponse</returns>
        public async System.Threading.Tasks.Task<SpecificationsResponse> GetSpecificationsOfSystemAsync (long? systemId, string key = null)
        {
             ApiResponse<SpecificationsResponse> localVarResponse = await GetSpecificationsOfSystemAsyncWithHttpInfo(systemId, key);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get specifications of a system Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="systemId">Id of the specified system</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationsResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SpecificationsResponse>> GetSpecificationsOfSystemAsyncWithHttpInfo (long? systemId, string key = null)
        {
            // verify the required parameter 'systemId' is set
            if (systemId == null)
                throw new ApiException(400, "Missing required parameter 'systemId' when calling SpecificationApi->GetSpecificationsOfSystem");

            var localVarPath = "/systems/{system_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (systemId != null) localVarPathParams.Add("system_id", this.Configuration.ApiClient.ParameterToString(systemId)); // path parameter
            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationsOfSystem", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationsResponse)));
        }

        /// <summary>
        /// Get specifications of a user Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">Id of the specified user</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>SpecificationsResponse</returns>
        public SpecificationsResponse GetSpecificationsOfUser (long? userId, string key = null)
        {
             ApiResponse<SpecificationsResponse> localVarResponse = GetSpecificationsOfUserWithHttpInfo(userId, key);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get specifications of a user Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">Id of the specified user</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>ApiResponse of SpecificationsResponse</returns>
        public ApiResponse< SpecificationsResponse > GetSpecificationsOfUserWithHttpInfo (long? userId, string key = null)
        {
            // verify the required parameter 'userId' is set
            if (userId == null)
                throw new ApiException(400, "Missing required parameter 'userId' when calling SpecificationApi->GetSpecificationsOfUser");

            var localVarPath = "/users/{user_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (userId != null) localVarPathParams.Add("user_id", this.Configuration.ApiClient.ParameterToString(userId)); // path parameter
            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationsOfUser", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationsResponse)));
        }

        /// <summary>
        /// Get specifications of a user Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">Id of the specified user</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of SpecificationsResponse</returns>
        public async System.Threading.Tasks.Task<SpecificationsResponse> GetSpecificationsOfUserAsync (long? userId, string key = null)
        {
             ApiResponse<SpecificationsResponse> localVarResponse = await GetSpecificationsOfUserAsyncWithHttpInfo(userId, key);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get specifications of a user Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">Id of the specified user</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationsResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SpecificationsResponse>> GetSpecificationsOfUserAsyncWithHttpInfo (long? userId, string key = null)
        {
            // verify the required parameter 'userId' is set
            if (userId == null)
                throw new ApiException(400, "Missing required parameter 'userId' when calling SpecificationApi->GetSpecificationsOfUser");

            var localVarPath = "/users/{user_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (userId != null) localVarPathParams.Add("user_id", this.Configuration.ApiClient.ParameterToString(userId)); // path parameter
            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationsOfUser", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationsResponse)));
        }

        /// <summary>
        /// Delete specifications of an api subscription The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="id">Id of the specified api subscription</param>
        /// <returns></returns>
        public void RemoveSpecificationsFromAPISubscriptions (List<string> body, long? id)
        {
             RemoveSpecificationsFromAPISubscriptionsWithHttpInfo(body, id);
        }

        /// <summary>
        /// Delete specifications of an api subscription The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="id">Id of the specified api subscription</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RemoveSpecificationsFromAPISubscriptionsWithHttpInfo (List<string> body, long? id)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RemoveSpecificationsFromAPISubscriptions");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling SpecificationApi->RemoveSpecificationsFromAPISubscriptions");

            var localVarPath = "/api_subscriptions/{id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveSpecificationsFromAPISubscriptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete specifications of an api subscription The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="id">Id of the specified api subscription</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveSpecificationsFromAPISubscriptionsAsync (List<string> body, long? id)
        {
             await RemoveSpecificationsFromAPISubscriptionsAsyncWithHttpInfo(body, id);

        }

        /// <summary>
        /// Delete specifications of an api subscription The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="id">Id of the specified api subscription</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RemoveSpecificationsFromAPISubscriptionsAsyncWithHttpInfo (List<string> body, long? id)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RemoveSpecificationsFromAPISubscriptions");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling SpecificationApi->RemoveSpecificationsFromAPISubscriptions");

            var localVarPath = "/api_subscriptions/{id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveSpecificationsFromAPISubscriptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete specifications of a batch The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="batchId">Id of the specified batch</param>
        /// <returns></returns>
        public void RemoveSpecificationsFromBatch (List<string> body, long? batchId)
        {
             RemoveSpecificationsFromBatchWithHttpInfo(body, batchId);
        }

        /// <summary>
        /// Delete specifications of a batch The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="batchId">Id of the specified batch</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RemoveSpecificationsFromBatchWithHttpInfo (List<string> body, long? batchId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RemoveSpecificationsFromBatch");
            // verify the required parameter 'batchId' is set
            if (batchId == null)
                throw new ApiException(400, "Missing required parameter 'batchId' when calling SpecificationApi->RemoveSpecificationsFromBatch");

            var localVarPath = "/batches/{batch_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (batchId != null) localVarPathParams.Add("batch_id", this.Configuration.ApiClient.ParameterToString(batchId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveSpecificationsFromBatch", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete specifications of a batch The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="batchId">Id of the specified batch</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveSpecificationsFromBatchAsync (List<string> body, long? batchId)
        {
             await RemoveSpecificationsFromBatchAsyncWithHttpInfo(body, batchId);

        }

        /// <summary>
        /// Delete specifications of a batch The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="batchId">Id of the specified batch</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RemoveSpecificationsFromBatchAsyncWithHttpInfo (List<string> body, long? batchId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RemoveSpecificationsFromBatch");
            // verify the required parameter 'batchId' is set
            if (batchId == null)
                throw new ApiException(400, "Missing required parameter 'batchId' when calling SpecificationApi->RemoveSpecificationsFromBatch");

            var localVarPath = "/batches/{batch_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (batchId != null) localVarPathParams.Add("batch_id", this.Configuration.ApiClient.ParameterToString(batchId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveSpecificationsFromBatch", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete specifications of an event The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="eventId">Id of the specified event</param>
        /// <returns></returns>
        public void RemoveSpecificationsFromEvent (List<string> body, long? eventId)
        {
             RemoveSpecificationsFromEventWithHttpInfo(body, eventId);
        }

        /// <summary>
        /// Delete specifications of an event The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="eventId">Id of the specified event</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RemoveSpecificationsFromEventWithHttpInfo (List<string> body, long? eventId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RemoveSpecificationsFromEvent");
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling SpecificationApi->RemoveSpecificationsFromEvent");

            var localVarPath = "/events/{event_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveSpecificationsFromEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete specifications of an event The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="eventId">Id of the specified event</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveSpecificationsFromEventAsync (List<string> body, long? eventId)
        {
             await RemoveSpecificationsFromEventAsyncWithHttpInfo(body, eventId);

        }

        /// <summary>
        /// Delete specifications of an event The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="eventId">Id of the specified event</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RemoveSpecificationsFromEventAsyncWithHttpInfo (List<string> body, long? eventId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RemoveSpecificationsFromEvent");
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling SpecificationApi->RemoveSpecificationsFromEvent");

            var localVarPath = "/events/{event_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveSpecificationsFromEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete specifications of an instrumentation The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns></returns>
        public void RemoveSpecificationsFromInstrumentation (List<string> body, long? instrumentationId)
        {
             RemoveSpecificationsFromInstrumentationWithHttpInfo(body, instrumentationId);
        }

        /// <summary>
        /// Delete specifications of an instrumentation The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RemoveSpecificationsFromInstrumentationWithHttpInfo (List<string> body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RemoveSpecificationsFromInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling SpecificationApi->RemoveSpecificationsFromInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveSpecificationsFromInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete specifications of an instrumentation The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveSpecificationsFromInstrumentationAsync (List<string> body, long? instrumentationId)
        {
             await RemoveSpecificationsFromInstrumentationAsyncWithHttpInfo(body, instrumentationId);

        }

        /// <summary>
        /// Delete specifications of an instrumentation The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RemoveSpecificationsFromInstrumentationAsyncWithHttpInfo (List<string> body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RemoveSpecificationsFromInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling SpecificationApi->RemoveSpecificationsFromInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveSpecificationsFromInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete specifications of a node The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns></returns>
        public void RemoveSpecificationsFromNode (List<string> body, long? nodeId)
        {
             RemoveSpecificationsFromNodeWithHttpInfo(body, nodeId);
        }

        /// <summary>
        /// Delete specifications of a node The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RemoveSpecificationsFromNodeWithHttpInfo (List<string> body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RemoveSpecificationsFromNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling SpecificationApi->RemoveSpecificationsFromNode");

            var localVarPath = "/nodes/{node_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveSpecificationsFromNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete specifications of a node The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveSpecificationsFromNodeAsync (List<string> body, long? nodeId)
        {
             await RemoveSpecificationsFromNodeAsyncWithHttpInfo(body, nodeId);

        }

        /// <summary>
        /// Delete specifications of a node The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RemoveSpecificationsFromNodeAsyncWithHttpInfo (List<string> body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RemoveSpecificationsFromNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling SpecificationApi->RemoveSpecificationsFromNode");

            var localVarPath = "/nodes/{node_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveSpecificationsFromNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete specifications of a product The specification keys in the body will be removed. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="productId">Id of the specified product</param>
        /// <returns></returns>
        public void RemoveSpecificationsFromProduct (List<string> body, long? productId)
        {
             RemoveSpecificationsFromProductWithHttpInfo(body, productId);
        }

        /// <summary>
        /// Delete specifications of a product The specification keys in the body will be removed. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="productId">Id of the specified product</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RemoveSpecificationsFromProductWithHttpInfo (List<string> body, long? productId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RemoveSpecificationsFromProduct");
            // verify the required parameter 'productId' is set
            if (productId == null)
                throw new ApiException(400, "Missing required parameter 'productId' when calling SpecificationApi->RemoveSpecificationsFromProduct");

            var localVarPath = "/products/{product_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (productId != null) localVarPathParams.Add("product_id", this.Configuration.ApiClient.ParameterToString(productId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveSpecificationsFromProduct", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete specifications of a product The specification keys in the body will be removed. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="productId">Id of the specified product</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveSpecificationsFromProductAsync (List<string> body, long? productId)
        {
             await RemoveSpecificationsFromProductAsyncWithHttpInfo(body, productId);

        }

        /// <summary>
        /// Delete specifications of a product The specification keys in the body will be removed. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="productId">Id of the specified product</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RemoveSpecificationsFromProductAsyncWithHttpInfo (List<string> body, long? productId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RemoveSpecificationsFromProduct");
            // verify the required parameter 'productId' is set
            if (productId == null)
                throw new ApiException(400, "Missing required parameter 'productId' when calling SpecificationApi->RemoveSpecificationsFromProduct");

            var localVarPath = "/products/{product_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (productId != null) localVarPathParams.Add("product_id", this.Configuration.ApiClient.ParameterToString(productId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveSpecificationsFromProduct", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete specifications of an recipe The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <returns></returns>
        public void RemoveSpecificationsFromRecipe (List<string> body, long? recipeId)
        {
             RemoveSpecificationsFromRecipeWithHttpInfo(body, recipeId);
        }

        /// <summary>
        /// Delete specifications of an recipe The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RemoveSpecificationsFromRecipeWithHttpInfo (List<string> body, long? recipeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RemoveSpecificationsFromRecipe");
            // verify the required parameter 'recipeId' is set
            if (recipeId == null)
                throw new ApiException(400, "Missing required parameter 'recipeId' when calling SpecificationApi->RemoveSpecificationsFromRecipe");

            var localVarPath = "/recipes/{recipe_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (recipeId != null) localVarPathParams.Add("recipe_id", this.Configuration.ApiClient.ParameterToString(recipeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveSpecificationsFromRecipe", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete specifications of an recipe The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveSpecificationsFromRecipeAsync (List<string> body, long? recipeId)
        {
             await RemoveSpecificationsFromRecipeAsyncWithHttpInfo(body, recipeId);

        }

        /// <summary>
        /// Delete specifications of an recipe The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RemoveSpecificationsFromRecipeAsyncWithHttpInfo (List<string> body, long? recipeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RemoveSpecificationsFromRecipe");
            // verify the required parameter 'recipeId' is set
            if (recipeId == null)
                throw new ApiException(400, "Missing required parameter 'recipeId' when calling SpecificationApi->RemoveSpecificationsFromRecipe");

            var localVarPath = "/recipes/{recipe_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (recipeId != null) localVarPathParams.Add("recipe_id", this.Configuration.ApiClient.ParameterToString(recipeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveSpecificationsFromRecipe", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete specifications of a subscription The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns></returns>
        public void RemoveSpecificationsFromSubscriptions (List<string> body, long? subscriptionId)
        {
             RemoveSpecificationsFromSubscriptionsWithHttpInfo(body, subscriptionId);
        }

        /// <summary>
        /// Delete specifications of a subscription The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RemoveSpecificationsFromSubscriptionsWithHttpInfo (List<string> body, long? subscriptionId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RemoveSpecificationsFromSubscriptions");
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionId' when calling SpecificationApi->RemoveSpecificationsFromSubscriptions");

            var localVarPath = "/subscriptions/{subscription_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionId != null) localVarPathParams.Add("subscription_id", this.Configuration.ApiClient.ParameterToString(subscriptionId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveSpecificationsFromSubscriptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete specifications of a subscription The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveSpecificationsFromSubscriptionsAsync (List<string> body, long? subscriptionId)
        {
             await RemoveSpecificationsFromSubscriptionsAsyncWithHttpInfo(body, subscriptionId);

        }

        /// <summary>
        /// Delete specifications of a subscription The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RemoveSpecificationsFromSubscriptionsAsyncWithHttpInfo (List<string> body, long? subscriptionId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RemoveSpecificationsFromSubscriptions");
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionId' when calling SpecificationApi->RemoveSpecificationsFromSubscriptions");

            var localVarPath = "/subscriptions/{subscription_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionId != null) localVarPathParams.Add("subscription_id", this.Configuration.ApiClient.ParameterToString(subscriptionId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveSpecificationsFromSubscriptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete specifications of a system The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="systemId">Id of the specified system</param>
        /// <returns></returns>
        public void RemoveSpecificationsFromSystem (List<string> body, long? systemId)
        {
             RemoveSpecificationsFromSystemWithHttpInfo(body, systemId);
        }

        /// <summary>
        /// Delete specifications of a system The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="systemId">Id of the specified system</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RemoveSpecificationsFromSystemWithHttpInfo (List<string> body, long? systemId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RemoveSpecificationsFromSystem");
            // verify the required parameter 'systemId' is set
            if (systemId == null)
                throw new ApiException(400, "Missing required parameter 'systemId' when calling SpecificationApi->RemoveSpecificationsFromSystem");

            var localVarPath = "/systems/{system_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (systemId != null) localVarPathParams.Add("system_id", this.Configuration.ApiClient.ParameterToString(systemId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveSpecificationsFromSystem", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete specifications of a system The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="systemId">Id of the specified system</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveSpecificationsFromSystemAsync (List<string> body, long? systemId)
        {
             await RemoveSpecificationsFromSystemAsyncWithHttpInfo(body, systemId);

        }

        /// <summary>
        /// Delete specifications of a system The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="systemId">Id of the specified system</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RemoveSpecificationsFromSystemAsyncWithHttpInfo (List<string> body, long? systemId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RemoveSpecificationsFromSystem");
            // verify the required parameter 'systemId' is set
            if (systemId == null)
                throw new ApiException(400, "Missing required parameter 'systemId' when calling SpecificationApi->RemoveSpecificationsFromSystem");

            var localVarPath = "/systems/{system_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (systemId != null) localVarPathParams.Add("system_id", this.Configuration.ApiClient.ParameterToString(systemId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveSpecificationsFromSystem", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete specifications of a user The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="userId">Id of the specified user</param>
        /// <returns></returns>
        public void RemoveSpecificationsFromUsers (List<string> body, long? userId)
        {
             RemoveSpecificationsFromUsersWithHttpInfo(body, userId);
        }

        /// <summary>
        /// Delete specifications of a user The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="userId">Id of the specified user</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RemoveSpecificationsFromUsersWithHttpInfo (List<string> body, long? userId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RemoveSpecificationsFromUsers");
            // verify the required parameter 'userId' is set
            if (userId == null)
                throw new ApiException(400, "Missing required parameter 'userId' when calling SpecificationApi->RemoveSpecificationsFromUsers");

            var localVarPath = "/users/{user_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (userId != null) localVarPathParams.Add("user_id", this.Configuration.ApiClient.ParameterToString(userId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveSpecificationsFromUsers", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete specifications of a user The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="userId">Id of the specified user</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveSpecificationsFromUsersAsync (List<string> body, long? userId)
        {
             await RemoveSpecificationsFromUsersAsyncWithHttpInfo(body, userId);

        }

        /// <summary>
        /// Delete specifications of a user The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="userId">Id of the specified user</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RemoveSpecificationsFromUsersAsyncWithHttpInfo (List<string> body, long? userId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RemoveSpecificationsFromUsers");
            // verify the required parameter 'userId' is set
            if (userId == null)
                throw new ApiException(400, "Missing required parameter 'userId' when calling SpecificationApi->RemoveSpecificationsFromUsers");

            var localVarPath = "/users/{user_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (userId != null) localVarPathParams.Add("user_id", this.Configuration.ApiClient.ParameterToString(userId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveSpecificationsFromUsers", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of a subscription in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="id">Id of the specified subscription</param>
        /// <returns></returns>
        public void RenameSpecificationsOfAPISubscriptions (SpecificationsRename body, long? id)
        {
             RenameSpecificationsOfAPISubscriptionsWithHttpInfo(body, id);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of a subscription in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="id">Id of the specified subscription</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RenameSpecificationsOfAPISubscriptionsWithHttpInfo (SpecificationsRename body, long? id)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RenameSpecificationsOfAPISubscriptions");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling SpecificationApi->RenameSpecificationsOfAPISubscriptions");

            var localVarPath = "/api_subscriptions/{id}/specifications/rename";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RenameSpecificationsOfAPISubscriptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of a subscription in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="id">Id of the specified subscription</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RenameSpecificationsOfAPISubscriptionsAsync (SpecificationsRename body, long? id)
        {
             await RenameSpecificationsOfAPISubscriptionsAsyncWithHttpInfo(body, id);

        }

        /// <summary>
        /// Rename a specification key Rename one specification key of a subscription in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="id">Id of the specified subscription</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RenameSpecificationsOfAPISubscriptionsAsyncWithHttpInfo (SpecificationsRename body, long? id)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RenameSpecificationsOfAPISubscriptions");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling SpecificationApi->RenameSpecificationsOfAPISubscriptions");

            var localVarPath = "/api_subscriptions/{id}/specifications/rename";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RenameSpecificationsOfAPISubscriptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of an asset in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ]. All uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="assetId">Id of the specified asset</param>
        /// <returns></returns>
        public void RenameSpecificationsOfAsset (SpecificationsRename body, long? assetId)
        {
             RenameSpecificationsOfAssetWithHttpInfo(body, assetId);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of an asset in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ]. All uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="assetId">Id of the specified asset</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RenameSpecificationsOfAssetWithHttpInfo (SpecificationsRename body, long? assetId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RenameSpecificationsOfAsset");
            // verify the required parameter 'assetId' is set
            if (assetId == null)
                throw new ApiException(400, "Missing required parameter 'assetId' when calling SpecificationApi->RenameSpecificationsOfAsset");

            var localVarPath = "/assets/{asset_id}/specifications/rename";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (assetId != null) localVarPathParams.Add("asset_id", this.Configuration.ApiClient.ParameterToString(assetId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RenameSpecificationsOfAsset", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of an asset in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ]. All uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="assetId">Id of the specified asset</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RenameSpecificationsOfAssetAsync (SpecificationsRename body, long? assetId)
        {
             await RenameSpecificationsOfAssetAsyncWithHttpInfo(body, assetId);

        }

        /// <summary>
        /// Rename a specification key Rename one specification key of an asset in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ]. All uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="assetId">Id of the specified asset</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RenameSpecificationsOfAssetAsyncWithHttpInfo (SpecificationsRename body, long? assetId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RenameSpecificationsOfAsset");
            // verify the required parameter 'assetId' is set
            if (assetId == null)
                throw new ApiException(400, "Missing required parameter 'assetId' when calling SpecificationApi->RenameSpecificationsOfAsset");

            var localVarPath = "/assets/{asset_id}/specifications/rename";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (assetId != null) localVarPathParams.Add("asset_id", this.Configuration.ApiClient.ParameterToString(assetId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RenameSpecificationsOfAsset", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of a batch in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="batchId">Id of the specified batch</param>
        /// <returns></returns>
        public void RenameSpecificationsOfBatch (SpecificationsRename body, long? batchId)
        {
             RenameSpecificationsOfBatchWithHttpInfo(body, batchId);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of a batch in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="batchId">Id of the specified batch</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RenameSpecificationsOfBatchWithHttpInfo (SpecificationsRename body, long? batchId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RenameSpecificationsOfBatch");
            // verify the required parameter 'batchId' is set
            if (batchId == null)
                throw new ApiException(400, "Missing required parameter 'batchId' when calling SpecificationApi->RenameSpecificationsOfBatch");

            var localVarPath = "/batches/{batch_id}/specifications/rename";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (batchId != null) localVarPathParams.Add("batch_id", this.Configuration.ApiClient.ParameterToString(batchId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RenameSpecificationsOfBatch", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of a batch in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="batchId">Id of the specified batch</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RenameSpecificationsOfBatchAsync (SpecificationsRename body, long? batchId)
        {
             await RenameSpecificationsOfBatchAsyncWithHttpInfo(body, batchId);

        }

        /// <summary>
        /// Rename a specification key Rename one specification key of a batch in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="batchId">Id of the specified batch</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RenameSpecificationsOfBatchAsyncWithHttpInfo (SpecificationsRename body, long? batchId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RenameSpecificationsOfBatch");
            // verify the required parameter 'batchId' is set
            if (batchId == null)
                throw new ApiException(400, "Missing required parameter 'batchId' when calling SpecificationApi->RenameSpecificationsOfBatch");

            var localVarPath = "/batches/{batch_id}/specifications/rename";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (batchId != null) localVarPathParams.Add("batch_id", this.Configuration.ApiClient.ParameterToString(batchId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RenameSpecificationsOfBatch", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of an event in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="eventId">Id of the specified node</param>
        /// <returns></returns>
        public void RenameSpecificationsOfEvent (SpecificationsRename body, long? eventId)
        {
             RenameSpecificationsOfEventWithHttpInfo(body, eventId);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of an event in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="eventId">Id of the specified node</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RenameSpecificationsOfEventWithHttpInfo (SpecificationsRename body, long? eventId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RenameSpecificationsOfEvent");
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling SpecificationApi->RenameSpecificationsOfEvent");

            var localVarPath = "/events/{event_id}/specifications/rename";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RenameSpecificationsOfEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of an event in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="eventId">Id of the specified node</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RenameSpecificationsOfEventAsync (SpecificationsRename body, long? eventId)
        {
             await RenameSpecificationsOfEventAsyncWithHttpInfo(body, eventId);

        }

        /// <summary>
        /// Rename a specification key Rename one specification key of an event in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="eventId">Id of the specified node</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RenameSpecificationsOfEventAsyncWithHttpInfo (SpecificationsRename body, long? eventId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RenameSpecificationsOfEvent");
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling SpecificationApi->RenameSpecificationsOfEvent");

            var localVarPath = "/events/{event_id}/specifications/rename";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RenameSpecificationsOfEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of an instrumentation in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns></returns>
        public void RenameSpecificationsOfInstrumentation (SpecificationsRename body, long? instrumentationId)
        {
             RenameSpecificationsOfInstrumentationWithHttpInfo(body, instrumentationId);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of an instrumentation in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RenameSpecificationsOfInstrumentationWithHttpInfo (SpecificationsRename body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RenameSpecificationsOfInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling SpecificationApi->RenameSpecificationsOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/specifications/rename";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RenameSpecificationsOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of an instrumentation in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RenameSpecificationsOfInstrumentationAsync (SpecificationsRename body, long? instrumentationId)
        {
             await RenameSpecificationsOfInstrumentationAsyncWithHttpInfo(body, instrumentationId);

        }

        /// <summary>
        /// Rename a specification key Rename one specification key of an instrumentation in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RenameSpecificationsOfInstrumentationAsyncWithHttpInfo (SpecificationsRename body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RenameSpecificationsOfInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling SpecificationApi->RenameSpecificationsOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/specifications/rename";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RenameSpecificationsOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of a node in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns></returns>
        public void RenameSpecificationsOfNode (SpecificationsRename body, long? nodeId)
        {
             RenameSpecificationsOfNodeWithHttpInfo(body, nodeId);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of a node in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RenameSpecificationsOfNodeWithHttpInfo (SpecificationsRename body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RenameSpecificationsOfNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling SpecificationApi->RenameSpecificationsOfNode");

            var localVarPath = "/nodes/{node_id}/specifications/rename";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RenameSpecificationsOfNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of a node in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RenameSpecificationsOfNodeAsync (SpecificationsRename body, long? nodeId)
        {
             await RenameSpecificationsOfNodeAsyncWithHttpInfo(body, nodeId);

        }

        /// <summary>
        /// Rename a specification key Rename one specification key of a node in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RenameSpecificationsOfNodeAsyncWithHttpInfo (SpecificationsRename body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RenameSpecificationsOfNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling SpecificationApi->RenameSpecificationsOfNode");

            var localVarPath = "/nodes/{node_id}/specifications/rename";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RenameSpecificationsOfNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// rename a key in the specification. Rename a key of the specification object of a product. Instead of delete and recreate again, this is to preserve the key´s value history. Also the new keys can only consist of a-z A-Z 0-9 . - _ all uppercase A-Z are converted to lower-case a-z. Only one key can be changed per request
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="productId">Id of the specified product</param>
        /// <returns></returns>
        public void RenameSpecificationsOfProduct (SpecificationsRename body, long? productId)
        {
             RenameSpecificationsOfProductWithHttpInfo(body, productId);
        }

        /// <summary>
        /// rename a key in the specification. Rename a key of the specification object of a product. Instead of delete and recreate again, this is to preserve the key´s value history. Also the new keys can only consist of a-z A-Z 0-9 . - _ all uppercase A-Z are converted to lower-case a-z. Only one key can be changed per request
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="productId">Id of the specified product</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RenameSpecificationsOfProductWithHttpInfo (SpecificationsRename body, long? productId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RenameSpecificationsOfProduct");
            // verify the required parameter 'productId' is set
            if (productId == null)
                throw new ApiException(400, "Missing required parameter 'productId' when calling SpecificationApi->RenameSpecificationsOfProduct");

            var localVarPath = "/products/{product_id}/specifications/rename";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (productId != null) localVarPathParams.Add("product_id", this.Configuration.ApiClient.ParameterToString(productId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RenameSpecificationsOfProduct", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// rename a key in the specification. Rename a key of the specification object of a product. Instead of delete and recreate again, this is to preserve the key´s value history. Also the new keys can only consist of a-z A-Z 0-9 . - _ all uppercase A-Z are converted to lower-case a-z. Only one key can be changed per request
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="productId">Id of the specified product</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RenameSpecificationsOfProductAsync (SpecificationsRename body, long? productId)
        {
             await RenameSpecificationsOfProductAsyncWithHttpInfo(body, productId);

        }

        /// <summary>
        /// rename a key in the specification. Rename a key of the specification object of a product. Instead of delete and recreate again, this is to preserve the key´s value history. Also the new keys can only consist of a-z A-Z 0-9 . - _ all uppercase A-Z are converted to lower-case a-z. Only one key can be changed per request
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="productId">Id of the specified product</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RenameSpecificationsOfProductAsyncWithHttpInfo (SpecificationsRename body, long? productId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RenameSpecificationsOfProduct");
            // verify the required parameter 'productId' is set
            if (productId == null)
                throw new ApiException(400, "Missing required parameter 'productId' when calling SpecificationApi->RenameSpecificationsOfProduct");

            var localVarPath = "/products/{product_id}/specifications/rename";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (productId != null) localVarPathParams.Add("product_id", this.Configuration.ApiClient.ParameterToString(productId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RenameSpecificationsOfProduct", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of an recipe in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <returns></returns>
        public void RenameSpecificationsOfRecipe (SpecificationsRename body, long? recipeId)
        {
             RenameSpecificationsOfRecipeWithHttpInfo(body, recipeId);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of an recipe in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RenameSpecificationsOfRecipeWithHttpInfo (SpecificationsRename body, long? recipeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RenameSpecificationsOfRecipe");
            // verify the required parameter 'recipeId' is set
            if (recipeId == null)
                throw new ApiException(400, "Missing required parameter 'recipeId' when calling SpecificationApi->RenameSpecificationsOfRecipe");

            var localVarPath = "/recipes/{recipe_id}/specifications/rename";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (recipeId != null) localVarPathParams.Add("recipe_id", this.Configuration.ApiClient.ParameterToString(recipeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RenameSpecificationsOfRecipe", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of an recipe in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RenameSpecificationsOfRecipeAsync (SpecificationsRename body, long? recipeId)
        {
             await RenameSpecificationsOfRecipeAsyncWithHttpInfo(body, recipeId);

        }

        /// <summary>
        /// Rename a specification key Rename one specification key of an recipe in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RenameSpecificationsOfRecipeAsyncWithHttpInfo (SpecificationsRename body, long? recipeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RenameSpecificationsOfRecipe");
            // verify the required parameter 'recipeId' is set
            if (recipeId == null)
                throw new ApiException(400, "Missing required parameter 'recipeId' when calling SpecificationApi->RenameSpecificationsOfRecipe");

            var localVarPath = "/recipes/{recipe_id}/specifications/rename";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (recipeId != null) localVarPathParams.Add("recipe_id", this.Configuration.ApiClient.ParameterToString(recipeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RenameSpecificationsOfRecipe", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of a subscription in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns></returns>
        public void RenameSpecificationsOfSubscriptions (SpecificationsRename body, long? subscriptionId)
        {
             RenameSpecificationsOfSubscriptionsWithHttpInfo(body, subscriptionId);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of a subscription in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RenameSpecificationsOfSubscriptionsWithHttpInfo (SpecificationsRename body, long? subscriptionId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RenameSpecificationsOfSubscriptions");
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionId' when calling SpecificationApi->RenameSpecificationsOfSubscriptions");

            var localVarPath = "/subscriptions/{subscription_id}/specifications/rename";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionId != null) localVarPathParams.Add("subscription_id", this.Configuration.ApiClient.ParameterToString(subscriptionId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RenameSpecificationsOfSubscriptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of a subscription in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RenameSpecificationsOfSubscriptionsAsync (SpecificationsRename body, long? subscriptionId)
        {
             await RenameSpecificationsOfSubscriptionsAsyncWithHttpInfo(body, subscriptionId);

        }

        /// <summary>
        /// Rename a specification key Rename one specification key of a subscription in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RenameSpecificationsOfSubscriptionsAsyncWithHttpInfo (SpecificationsRename body, long? subscriptionId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RenameSpecificationsOfSubscriptions");
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionId' when calling SpecificationApi->RenameSpecificationsOfSubscriptions");

            var localVarPath = "/subscriptions/{subscription_id}/specifications/rename";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionId != null) localVarPathParams.Add("subscription_id", this.Configuration.ApiClient.ParameterToString(subscriptionId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RenameSpecificationsOfSubscriptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of a system in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="systemId">Id of the specified system</param>
        /// <returns></returns>
        public void RenameSpecificationsOfSystem (SpecificationsRename body, long? systemId)
        {
             RenameSpecificationsOfSystemWithHttpInfo(body, systemId);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of a system in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="systemId">Id of the specified system</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RenameSpecificationsOfSystemWithHttpInfo (SpecificationsRename body, long? systemId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RenameSpecificationsOfSystem");
            // verify the required parameter 'systemId' is set
            if (systemId == null)
                throw new ApiException(400, "Missing required parameter 'systemId' when calling SpecificationApi->RenameSpecificationsOfSystem");

            var localVarPath = "/systems/{system_id}/specifications/rename";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (systemId != null) localVarPathParams.Add("system_id", this.Configuration.ApiClient.ParameterToString(systemId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RenameSpecificationsOfSystem", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of a system in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="systemId">Id of the specified system</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RenameSpecificationsOfSystemAsync (SpecificationsRename body, long? systemId)
        {
             await RenameSpecificationsOfSystemAsyncWithHttpInfo(body, systemId);

        }

        /// <summary>
        /// Rename a specification key Rename one specification key of a system in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="systemId">Id of the specified system</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RenameSpecificationsOfSystemAsyncWithHttpInfo (SpecificationsRename body, long? systemId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RenameSpecificationsOfSystem");
            // verify the required parameter 'systemId' is set
            if (systemId == null)
                throw new ApiException(400, "Missing required parameter 'systemId' when calling SpecificationApi->RenameSpecificationsOfSystem");

            var localVarPath = "/systems/{system_id}/specifications/rename";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (systemId != null) localVarPathParams.Add("system_id", this.Configuration.ApiClient.ParameterToString(systemId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RenameSpecificationsOfSystem", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of a user in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="userId">Id of the specified user</param>
        /// <returns></returns>
        public void RenameSpecificationsOfUsers (SpecificationsRename body, long? userId)
        {
             RenameSpecificationsOfUsersWithHttpInfo(body, userId);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of a user in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="userId">Id of the specified user</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RenameSpecificationsOfUsersWithHttpInfo (SpecificationsRename body, long? userId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RenameSpecificationsOfUsers");
            // verify the required parameter 'userId' is set
            if (userId == null)
                throw new ApiException(400, "Missing required parameter 'userId' when calling SpecificationApi->RenameSpecificationsOfUsers");

            var localVarPath = "/users/{user_id}/specifications/rename";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (userId != null) localVarPathParams.Add("user_id", this.Configuration.ApiClient.ParameterToString(userId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RenameSpecificationsOfUsers", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of a user in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="userId">Id of the specified user</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RenameSpecificationsOfUsersAsync (SpecificationsRename body, long? userId)
        {
             await RenameSpecificationsOfUsersAsyncWithHttpInfo(body, userId);

        }

        /// <summary>
        /// Rename a specification key Rename one specification key of a user in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="userId">Id of the specified user</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RenameSpecificationsOfUsersAsyncWithHttpInfo (SpecificationsRename body, long? userId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->RenameSpecificationsOfUsers");
            // verify the required parameter 'userId' is set
            if (userId == null)
                throw new ApiException(400, "Missing required parameter 'userId' when calling SpecificationApi->RenameSpecificationsOfUsers");

            var localVarPath = "/users/{user_id}/specifications/rename";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (userId != null) localVarPathParams.Add("user_id", this.Configuration.ApiClient.ParameterToString(userId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RenameSpecificationsOfUsers", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update specifications of an api subscription Update the specification object of an api subscription in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="id">Id of the specified api subscription</param>
        /// <returns></returns>
        public void UpdateSpecificationsOfAPISubscriptions (Dictionary<string, SpecificationRequest> body, long? id)
        {
             UpdateSpecificationsOfAPISubscriptionsWithHttpInfo(body, id);
        }

        /// <summary>
        /// Update specifications of an api subscription Update the specification object of an api subscription in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="id">Id of the specified api subscription</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateSpecificationsOfAPISubscriptionsWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? id)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->UpdateSpecificationsOfAPISubscriptions");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling SpecificationApi->UpdateSpecificationsOfAPISubscriptions");

            var localVarPath = "/api_subscriptions/{id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSpecificationsOfAPISubscriptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update specifications of an api subscription Update the specification object of an api subscription in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="id">Id of the specified api subscription</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UpdateSpecificationsOfAPISubscriptionsAsync (Dictionary<string, SpecificationRequest> body, long? id)
        {
             await UpdateSpecificationsOfAPISubscriptionsAsyncWithHttpInfo(body, id);

        }

        /// <summary>
        /// Update specifications of an api subscription Update the specification object of an api subscription in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="id">Id of the specified api subscription</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSpecificationsOfAPISubscriptionsAsyncWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? id)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->UpdateSpecificationsOfAPISubscriptions");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling SpecificationApi->UpdateSpecificationsOfAPISubscriptions");

            var localVarPath = "/api_subscriptions/{id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSpecificationsOfAPISubscriptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update specifications of an asset Update the specification object of an asset in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.  It is possible to save complex objects in the value as vector. In this case the unit must be &#x27;vector&#x27; and the value a valid object in the following format: &#x60;&#x60;&#x60;       [           {             \&quot;key\&quot;: {              \&quot;value\&quot;: \&quot;string\&quot;,              \&quot;unit\&quot;: \&quot;string\&quot;            }           },           {             \&quot;second_key\&quot;: {               \&quot;value\&quot;: \&quot;string\&quot;             }           }        ]   &#x60;&#x60;&#x60;  - key can only consist of [a-z A-Z 0-9 . - _ ]. - value is mandatory, max length 6000 chars - unit is optional, max length 50 chars - its impossible to filter for vector values
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="assetId">Id of the specified asset</param>
        /// <returns></returns>
        public void UpdateSpecificationsOfAsset (Dictionary<string, SpecificationUIVisibleRequest> body, long? assetId)
        {
             UpdateSpecificationsOfAssetWithHttpInfo(body, assetId);
        }

        /// <summary>
        /// Update specifications of an asset Update the specification object of an asset in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.  It is possible to save complex objects in the value as vector. In this case the unit must be &#x27;vector&#x27; and the value a valid object in the following format: &#x60;&#x60;&#x60;       [           {             \&quot;key\&quot;: {              \&quot;value\&quot;: \&quot;string\&quot;,              \&quot;unit\&quot;: \&quot;string\&quot;            }           },           {             \&quot;second_key\&quot;: {               \&quot;value\&quot;: \&quot;string\&quot;             }           }        ]   &#x60;&#x60;&#x60;  - key can only consist of [a-z A-Z 0-9 . - _ ]. - value is mandatory, max length 6000 chars - unit is optional, max length 50 chars - its impossible to filter for vector values
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="assetId">Id of the specified asset</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateSpecificationsOfAssetWithHttpInfo (Dictionary<string, SpecificationUIVisibleRequest> body, long? assetId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->UpdateSpecificationsOfAsset");
            // verify the required parameter 'assetId' is set
            if (assetId == null)
                throw new ApiException(400, "Missing required parameter 'assetId' when calling SpecificationApi->UpdateSpecificationsOfAsset");

            var localVarPath = "/assets/{asset_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (assetId != null) localVarPathParams.Add("asset_id", this.Configuration.ApiClient.ParameterToString(assetId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSpecificationsOfAsset", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update specifications of an asset Update the specification object of an asset in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.  It is possible to save complex objects in the value as vector. In this case the unit must be &#x27;vector&#x27; and the value a valid object in the following format: &#x60;&#x60;&#x60;       [           {             \&quot;key\&quot;: {              \&quot;value\&quot;: \&quot;string\&quot;,              \&quot;unit\&quot;: \&quot;string\&quot;            }           },           {             \&quot;second_key\&quot;: {               \&quot;value\&quot;: \&quot;string\&quot;             }           }        ]   &#x60;&#x60;&#x60;  - key can only consist of [a-z A-Z 0-9 . - _ ]. - value is mandatory, max length 6000 chars - unit is optional, max length 50 chars - its impossible to filter for vector values
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="assetId">Id of the specified asset</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UpdateSpecificationsOfAssetAsync (Dictionary<string, SpecificationUIVisibleRequest> body, long? assetId)
        {
             await UpdateSpecificationsOfAssetAsyncWithHttpInfo(body, assetId);

        }

        /// <summary>
        /// Update specifications of an asset Update the specification object of an asset in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.  It is possible to save complex objects in the value as vector. In this case the unit must be &#x27;vector&#x27; and the value a valid object in the following format: &#x60;&#x60;&#x60;       [           {             \&quot;key\&quot;: {              \&quot;value\&quot;: \&quot;string\&quot;,              \&quot;unit\&quot;: \&quot;string\&quot;            }           },           {             \&quot;second_key\&quot;: {               \&quot;value\&quot;: \&quot;string\&quot;             }           }        ]   &#x60;&#x60;&#x60;  - key can only consist of [a-z A-Z 0-9 . - _ ]. - value is mandatory, max length 6000 chars - unit is optional, max length 50 chars - its impossible to filter for vector values
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="assetId">Id of the specified asset</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSpecificationsOfAssetAsyncWithHttpInfo (Dictionary<string, SpecificationUIVisibleRequest> body, long? assetId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->UpdateSpecificationsOfAsset");
            // verify the required parameter 'assetId' is set
            if (assetId == null)
                throw new ApiException(400, "Missing required parameter 'assetId' when calling SpecificationApi->UpdateSpecificationsOfAsset");

            var localVarPath = "/assets/{asset_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (assetId != null) localVarPathParams.Add("asset_id", this.Configuration.ApiClient.ParameterToString(assetId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSpecificationsOfAsset", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update specifications of a batch Update the specification object of a batch in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="batchId">Id of the specified batch</param>
        /// <returns></returns>
        public void UpdateSpecificationsOfBatch (Dictionary<string, SpecificationRequest> body, long? batchId)
        {
             UpdateSpecificationsOfBatchWithHttpInfo(body, batchId);
        }

        /// <summary>
        /// Update specifications of a batch Update the specification object of a batch in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="batchId">Id of the specified batch</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateSpecificationsOfBatchWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? batchId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->UpdateSpecificationsOfBatch");
            // verify the required parameter 'batchId' is set
            if (batchId == null)
                throw new ApiException(400, "Missing required parameter 'batchId' when calling SpecificationApi->UpdateSpecificationsOfBatch");

            var localVarPath = "/batches/{batch_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (batchId != null) localVarPathParams.Add("batch_id", this.Configuration.ApiClient.ParameterToString(batchId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSpecificationsOfBatch", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update specifications of a batch Update the specification object of a batch in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="batchId">Id of the specified batch</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UpdateSpecificationsOfBatchAsync (Dictionary<string, SpecificationRequest> body, long? batchId)
        {
             await UpdateSpecificationsOfBatchAsyncWithHttpInfo(body, batchId);

        }

        /// <summary>
        /// Update specifications of a batch Update the specification object of a batch in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="batchId">Id of the specified batch</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSpecificationsOfBatchAsyncWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? batchId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->UpdateSpecificationsOfBatch");
            // verify the required parameter 'batchId' is set
            if (batchId == null)
                throw new ApiException(400, "Missing required parameter 'batchId' when calling SpecificationApi->UpdateSpecificationsOfBatch");

            var localVarPath = "/batches/{batch_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (batchId != null) localVarPathParams.Add("batch_id", this.Configuration.ApiClient.ParameterToString(batchId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSpecificationsOfBatch", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update specifications of an event Update the specification object of an event in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of a-z A-Z 0-9 . - _ all uppercase A-Z are converted to lower-case a-z. For a key that is send mutliple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="eventId">Id of the specified event</param>
        /// <returns></returns>
        public void UpdateSpecificationsOfEvent (Dictionary<string, SpecificationRequest> body, long? eventId)
        {
             UpdateSpecificationsOfEventWithHttpInfo(body, eventId);
        }

        /// <summary>
        /// Update specifications of an event Update the specification object of an event in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of a-z A-Z 0-9 . - _ all uppercase A-Z are converted to lower-case a-z. For a key that is send mutliple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="eventId">Id of the specified event</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateSpecificationsOfEventWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? eventId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->UpdateSpecificationsOfEvent");
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling SpecificationApi->UpdateSpecificationsOfEvent");

            var localVarPath = "/events/{event_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSpecificationsOfEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update specifications of an event Update the specification object of an event in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of a-z A-Z 0-9 . - _ all uppercase A-Z are converted to lower-case a-z. For a key that is send mutliple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="eventId">Id of the specified event</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UpdateSpecificationsOfEventAsync (Dictionary<string, SpecificationRequest> body, long? eventId)
        {
             await UpdateSpecificationsOfEventAsyncWithHttpInfo(body, eventId);

        }

        /// <summary>
        /// Update specifications of an event Update the specification object of an event in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of a-z A-Z 0-9 . - _ all uppercase A-Z are converted to lower-case a-z. For a key that is send mutliple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="eventId">Id of the specified event</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSpecificationsOfEventAsyncWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? eventId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->UpdateSpecificationsOfEvent");
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling SpecificationApi->UpdateSpecificationsOfEvent");

            var localVarPath = "/events/{event_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSpecificationsOfEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update specifications of an instrumentation Update the specification object of an instrumentation in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns></returns>
        public void UpdateSpecificationsOfInstrumentation (Dictionary<string, SpecificationUIVisibleRequest> body, long? instrumentationId)
        {
             UpdateSpecificationsOfInstrumentationWithHttpInfo(body, instrumentationId);
        }

        /// <summary>
        /// Update specifications of an instrumentation Update the specification object of an instrumentation in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateSpecificationsOfInstrumentationWithHttpInfo (Dictionary<string, SpecificationUIVisibleRequest> body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->UpdateSpecificationsOfInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling SpecificationApi->UpdateSpecificationsOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSpecificationsOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update specifications of an instrumentation Update the specification object of an instrumentation in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UpdateSpecificationsOfInstrumentationAsync (Dictionary<string, SpecificationUIVisibleRequest> body, long? instrumentationId)
        {
             await UpdateSpecificationsOfInstrumentationAsyncWithHttpInfo(body, instrumentationId);

        }

        /// <summary>
        /// Update specifications of an instrumentation Update the specification object of an instrumentation in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="instrumentationId">Id of the specified instrumentation</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSpecificationsOfInstrumentationAsyncWithHttpInfo (Dictionary<string, SpecificationUIVisibleRequest> body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->UpdateSpecificationsOfInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling SpecificationApi->UpdateSpecificationsOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSpecificationsOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update specifications of a node Update the specification object of a node in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns></returns>
        public void UpdateSpecificationsOfNode (Dictionary<string, SpecificationUIVisibleRequest> body, long? nodeId)
        {
             UpdateSpecificationsOfNodeWithHttpInfo(body, nodeId);
        }

        /// <summary>
        /// Update specifications of a node Update the specification object of a node in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateSpecificationsOfNodeWithHttpInfo (Dictionary<string, SpecificationUIVisibleRequest> body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->UpdateSpecificationsOfNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling SpecificationApi->UpdateSpecificationsOfNode");

            var localVarPath = "/nodes/{node_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSpecificationsOfNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update specifications of a node Update the specification object of a node in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UpdateSpecificationsOfNodeAsync (Dictionary<string, SpecificationUIVisibleRequest> body, long? nodeId)
        {
             await UpdateSpecificationsOfNodeAsyncWithHttpInfo(body, nodeId);

        }

        /// <summary>
        /// Update specifications of a node Update the specification object of a node in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSpecificationsOfNodeAsyncWithHttpInfo (Dictionary<string, SpecificationUIVisibleRequest> body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->UpdateSpecificationsOfNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling SpecificationApi->UpdateSpecificationsOfNode");

            var localVarPath = "/nodes/{node_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSpecificationsOfNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update specifications of a product Update the specification object of a product. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. If a key occurs more than once in the request body, the last key-value will be saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="productId">Id of the specified product</param>
        /// <returns></returns>
        public void UpdateSpecificationsOfProduct (Dictionary<string, SpecificationRequest> body, long? productId)
        {
             UpdateSpecificationsOfProductWithHttpInfo(body, productId);
        }

        /// <summary>
        /// Update specifications of a product Update the specification object of a product. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. If a key occurs more than once in the request body, the last key-value will be saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="productId">Id of the specified product</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateSpecificationsOfProductWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? productId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->UpdateSpecificationsOfProduct");
            // verify the required parameter 'productId' is set
            if (productId == null)
                throw new ApiException(400, "Missing required parameter 'productId' when calling SpecificationApi->UpdateSpecificationsOfProduct");

            var localVarPath = "/products/{product_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (productId != null) localVarPathParams.Add("product_id", this.Configuration.ApiClient.ParameterToString(productId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSpecificationsOfProduct", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update specifications of a product Update the specification object of a product. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. If a key occurs more than once in the request body, the last key-value will be saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="productId">Id of the specified product</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UpdateSpecificationsOfProductAsync (Dictionary<string, SpecificationRequest> body, long? productId)
        {
             await UpdateSpecificationsOfProductAsyncWithHttpInfo(body, productId);

        }

        /// <summary>
        /// Update specifications of a product Update the specification object of a product. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. If a key occurs more than once in the request body, the last key-value will be saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="productId">Id of the specified product</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSpecificationsOfProductAsyncWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? productId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->UpdateSpecificationsOfProduct");
            // verify the required parameter 'productId' is set
            if (productId == null)
                throw new ApiException(400, "Missing required parameter 'productId' when calling SpecificationApi->UpdateSpecificationsOfProduct");

            var localVarPath = "/products/{product_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (productId != null) localVarPathParams.Add("product_id", this.Configuration.ApiClient.ParameterToString(productId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSpecificationsOfProduct", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update specifications of an recipe Update the specification object of an recipe in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <returns></returns>
        public void UpdateSpecificationsOfRecipe (Dictionary<string, SpecificationRequest> body, long? recipeId)
        {
             UpdateSpecificationsOfRecipeWithHttpInfo(body, recipeId);
        }

        /// <summary>
        /// Update specifications of an recipe Update the specification object of an recipe in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateSpecificationsOfRecipeWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? recipeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->UpdateSpecificationsOfRecipe");
            // verify the required parameter 'recipeId' is set
            if (recipeId == null)
                throw new ApiException(400, "Missing required parameter 'recipeId' when calling SpecificationApi->UpdateSpecificationsOfRecipe");

            var localVarPath = "/recipes/{recipe_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (recipeId != null) localVarPathParams.Add("recipe_id", this.Configuration.ApiClient.ParameterToString(recipeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSpecificationsOfRecipe", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update specifications of an recipe Update the specification object of an recipe in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UpdateSpecificationsOfRecipeAsync (Dictionary<string, SpecificationRequest> body, long? recipeId)
        {
             await UpdateSpecificationsOfRecipeAsyncWithHttpInfo(body, recipeId);

        }

        /// <summary>
        /// Update specifications of an recipe Update the specification object of an recipe in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="recipeId">Id of the specified recipe</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSpecificationsOfRecipeAsyncWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? recipeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->UpdateSpecificationsOfRecipe");
            // verify the required parameter 'recipeId' is set
            if (recipeId == null)
                throw new ApiException(400, "Missing required parameter 'recipeId' when calling SpecificationApi->UpdateSpecificationsOfRecipe");

            var localVarPath = "/recipes/{recipe_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (recipeId != null) localVarPathParams.Add("recipe_id", this.Configuration.ApiClient.ParameterToString(recipeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSpecificationsOfRecipe", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update specifications of a subscription Update the specification object of a subscription in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns></returns>
        public void UpdateSpecificationsOfSubscriptions (Dictionary<string, SpecificationRequest> body, long? subscriptionId)
        {
             UpdateSpecificationsOfSubscriptionsWithHttpInfo(body, subscriptionId);
        }

        /// <summary>
        /// Update specifications of a subscription Update the specification object of a subscription in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateSpecificationsOfSubscriptionsWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? subscriptionId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->UpdateSpecificationsOfSubscriptions");
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionId' when calling SpecificationApi->UpdateSpecificationsOfSubscriptions");

            var localVarPath = "/subscriptions/{subscription_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionId != null) localVarPathParams.Add("subscription_id", this.Configuration.ApiClient.ParameterToString(subscriptionId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSpecificationsOfSubscriptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update specifications of a subscription Update the specification object of a subscription in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UpdateSpecificationsOfSubscriptionsAsync (Dictionary<string, SpecificationRequest> body, long? subscriptionId)
        {
             await UpdateSpecificationsOfSubscriptionsAsyncWithHttpInfo(body, subscriptionId);

        }

        /// <summary>
        /// Update specifications of a subscription Update the specification object of a subscription in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSpecificationsOfSubscriptionsAsyncWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? subscriptionId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->UpdateSpecificationsOfSubscriptions");
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionId' when calling SpecificationApi->UpdateSpecificationsOfSubscriptions");

            var localVarPath = "/subscriptions/{subscription_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionId != null) localVarPathParams.Add("subscription_id", this.Configuration.ApiClient.ParameterToString(subscriptionId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSpecificationsOfSubscriptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update specifications of a system Update the specification object of a system in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="systemId">Id of the specified system</param>
        /// <returns></returns>
        public void UpdateSpecificationsOfSystem (Dictionary<string, SpecificationRequest> body, long? systemId)
        {
             UpdateSpecificationsOfSystemWithHttpInfo(body, systemId);
        }

        /// <summary>
        /// Update specifications of a system Update the specification object of a system in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="systemId">Id of the specified system</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateSpecificationsOfSystemWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? systemId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->UpdateSpecificationsOfSystem");
            // verify the required parameter 'systemId' is set
            if (systemId == null)
                throw new ApiException(400, "Missing required parameter 'systemId' when calling SpecificationApi->UpdateSpecificationsOfSystem");

            var localVarPath = "/systems/{system_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (systemId != null) localVarPathParams.Add("system_id", this.Configuration.ApiClient.ParameterToString(systemId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSpecificationsOfSystem", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update specifications of a system Update the specification object of a system in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="systemId">Id of the specified system</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UpdateSpecificationsOfSystemAsync (Dictionary<string, SpecificationRequest> body, long? systemId)
        {
             await UpdateSpecificationsOfSystemAsyncWithHttpInfo(body, systemId);

        }

        /// <summary>
        /// Update specifications of a system Update the specification object of a system in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="systemId">Id of the specified system</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSpecificationsOfSystemAsyncWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? systemId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->UpdateSpecificationsOfSystem");
            // verify the required parameter 'systemId' is set
            if (systemId == null)
                throw new ApiException(400, "Missing required parameter 'systemId' when calling SpecificationApi->UpdateSpecificationsOfSystem");

            var localVarPath = "/systems/{system_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (systemId != null) localVarPathParams.Add("system_id", this.Configuration.ApiClient.ParameterToString(systemId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSpecificationsOfSystem", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update specifications of a user Update the specification object of a user in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="userId">Id of the specified user</param>
        /// <returns></returns>
        public void UpdateSpecificationsOfUsers (Dictionary<string, SpecificationRequest> body, long? userId)
        {
             UpdateSpecificationsOfUsersWithHttpInfo(body, userId);
        }

        /// <summary>
        /// Update specifications of a user Update the specification object of a user in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="userId">Id of the specified user</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateSpecificationsOfUsersWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? userId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->UpdateSpecificationsOfUsers");
            // verify the required parameter 'userId' is set
            if (userId == null)
                throw new ApiException(400, "Missing required parameter 'userId' when calling SpecificationApi->UpdateSpecificationsOfUsers");

            var localVarPath = "/users/{user_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (userId != null) localVarPathParams.Add("user_id", this.Configuration.ApiClient.ParameterToString(userId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSpecificationsOfUsers", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update specifications of a user Update the specification object of a user in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="userId">Id of the specified user</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UpdateSpecificationsOfUsersAsync (Dictionary<string, SpecificationRequest> body, long? userId)
        {
             await UpdateSpecificationsOfUsersAsyncWithHttpInfo(body, userId);

        }

        /// <summary>
        /// Update specifications of a user Update the specification object of a user in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="userId">Id of the specified user</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSpecificationsOfUsersAsyncWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? userId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SpecificationApi->UpdateSpecificationsOfUsers");
            // verify the required parameter 'userId' is set
            if (userId == null)
                throw new ApiException(400, "Missing required parameter 'userId' when calling SpecificationApi->UpdateSpecificationsOfUsers");

            var localVarPath = "/users/{user_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (userId != null) localVarPathParams.Add("user_id", this.Configuration.ApiClient.ParameterToString(userId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSpecificationsOfUsers", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

    }
}
