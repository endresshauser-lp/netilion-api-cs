/* 
 * Netilion API Documentation
 *
 * Welcome to the Netilion API Documentation, which provides interactive access and documentation to our REST API. Please visit our developer portal for further instructions and information: https://developer.netilion.endress.com/ 
 *
 * OpenAPI spec version: 01.00.00
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using Netilion.Api.Client;
using Netilion.Api.Model;

namespace Netilion.Api.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
        public interface ISubscriptionApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Add assets to a subscription
        /// </summary>
        /// <remarks>
        /// Add one or more assets to a subscription.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="subscriptionId">Id of the subscription to which the assets will be added</param>
        /// <returns></returns>
        void AddAssetsToSubscription (AssetIDs body, long? subscriptionId);

        /// <summary>
        /// Add assets to a subscription
        /// </summary>
        /// <remarks>
        /// Add one or more assets to a subscription.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="subscriptionId">Id of the subscription to which the assets will be added</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> AddAssetsToSubscriptionWithHttpInfo (AssetIDs body, long? subscriptionId);
        /// <summary>
        /// Add users (existing users) or emails (new users) to a seat in subscription
        /// </summary>
        /// <remarks>
        /// Add one or more users to a seat in subscription. User can only have one subscription per service (as seat user or as owner), the amount of available seats is defined in seat_quota of subscription. One or more emails can also be sent for users that do not yet exist in Netilion, the users emails will then be invited to join Netilion. &#x60;&#x60;&#x60;Either id or email pro entry should be provided (not both).&#x60;&#x60;&#x60; If an email is provided for existing user, then given user will be used.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="subscriptionId">Id of the subscription to which the user will be added</param>
        /// <returns></returns>
        void AddSeatUsersToSubscription (UserIDorEmails body, long? subscriptionId);

        /// <summary>
        /// Add users (existing users) or emails (new users) to a seat in subscription
        /// </summary>
        /// <remarks>
        /// Add one or more users to a seat in subscription. User can only have one subscription per service (as seat user or as owner), the amount of available seats is defined in seat_quota of subscription. One or more emails can also be sent for users that do not yet exist in Netilion, the users emails will then be invited to join Netilion. &#x60;&#x60;&#x60;Either id or email pro entry should be provided (not both).&#x60;&#x60;&#x60; If an email is provided for existing user, then given user will be used.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="subscriptionId">Id of the subscription to which the user will be added</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> AddSeatUsersToSubscriptionWithHttpInfo (UserIDorEmails body, long? subscriptionId);
        /// <summary>
        /// Assign assets to a subscription based on a filter
        /// </summary>
        /// <remarks>
        /// Assign one or more assets to a subscription based on a filter. Body may contain an object id and type which then will return all assets assigned to that object directly or indirectly (through other objects). Body may contain an index search query to search assets based on a set of fields (like in the /search endpoint), only assets matching that search will be returned. Body may combine these conditions or even may contain none of them (in the latter case all readable assets is used). The assets returned from the filter are then assigned to the subscription. An error is raised if the filter given, does not contain any asset. If an asset is already assigned, it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="subscriptionId">Id of the subscription to which the assets will be added</param>
        /// <returns></returns>
        void AssignAssetSetToSubscription (SubscriptionAssetAssignmentRequest body, long? subscriptionId);

        /// <summary>
        /// Assign assets to a subscription based on a filter
        /// </summary>
        /// <remarks>
        /// Assign one or more assets to a subscription based on a filter. Body may contain an object id and type which then will return all assets assigned to that object directly or indirectly (through other objects). Body may contain an index search query to search assets based on a set of fields (like in the /search endpoint), only assets matching that search will be returned. Body may combine these conditions or even may contain none of them (in the latter case all readable assets is used). The assets returned from the filter are then assigned to the subscription. An error is raised if the filter given, does not contain any asset. If an asset is already assigned, it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="subscriptionId">Id of the subscription to which the assets will be added</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> AssignAssetSetToSubscriptionWithHttpInfo (SubscriptionAssetAssignmentRequest body, long? subscriptionId);
        /// <summary>
        /// Create a new subscription
        /// </summary>
        /// <remarks>
        /// Creates a new subscription. Only available for technical_users of the client_application and admins. Setting a successor or predecessor is possible. The client_application and user of the given Subscription and the reference Subscription have to match to do so.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">subscription body</param>
        /// <returns>SubscriptionResponse</returns>
        SubscriptionResponse CreateSubscription (SubscriptionRequest body);

        /// <summary>
        /// Create a new subscription
        /// </summary>
        /// <remarks>
        /// Creates a new subscription. Only available for technical_users of the client_application and admins. Setting a successor or predecessor is possible. The client_application and user of the given Subscription and the reference Subscription have to match to do so.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">subscription body</param>
        /// <returns>ApiResponse of SubscriptionResponse</returns>
        ApiResponse<SubscriptionResponse> CreateSubscriptionWithHttpInfo (SubscriptionRequest body);
        /// <summary>
        /// Delete a subscription
        /// </summary>
        /// <remarks>
        /// Delete a specific subscription identified by the id in the URL.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the subscription</param>
        /// <returns></returns>
        void DeleteSubscription (long? id);

        /// <summary>
        /// Delete a subscription
        /// </summary>
        /// <remarks>
        /// Delete a specific subscription identified by the id in the URL.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the subscription</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteSubscriptionWithHttpInfo (long? id);
        /// <summary>
        /// Delete a subscription seat
        /// </summary>
        /// <remarks>
        /// Delete a specific subscription seat identified by the id in the URL. This operation does send notification emails to the subscription owner, so it should be used by the invited user.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the subscription seat</param>
        /// <returns></returns>
        void DeleteSubscriptionSeat (long? id);

        /// <summary>
        /// Delete a subscription seat
        /// </summary>
        /// <remarks>
        /// Delete a specific subscription seat identified by the id in the URL. This operation does send notification emails to the subscription owner, so it should be used by the invited user.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the subscription seat</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteSubscriptionSeatWithHttpInfo (long? id);
        /// <summary>
        /// Get all assets of one subscription
        /// </summary>
        /// <remarks>
        /// Returns a list of all assets that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;status, tenant, parent, pictures, product, product.manufacturer, product.pictures, product.status, product.categories, product.categories.parent, specifications, specifications[key1,key2], product.tenant,                             product.manufacturer.tenant, status.tenant, instrumentations &#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="serialNumber">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productCategoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="manufacturerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusCode">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productionDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="nodeId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all assets with no nodes assigned or \&quot;!null\&quot; for any assigned node.  By adding &#x60;+&#x60; after the id, the filter considers the given node and all its sub components (nodes, instrumentations and systems), but this is not usable in combination with a comma list. (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="ownershipClaimed">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;serial_number&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, &#x60;last_seen_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>AssetsResponse</returns>
        AssetsResponse GetAssetsOfSubscription (long? subscriptionId, int? page = null, int? perPage = null, string include = null, string serialNumber = null, string productId = null, string productCategoryId = null, string parentId = null, string manufacturerId = null, string statusId = null, string statusCode = null, DateTime? productionDate = null, DateTime? productionDateFrom = null, DateTime? productionDateTo = null, string specificationsKey = null, string specificationsValue = null, string nodeId = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, bool? ownershipClaimed = null, string permission = null, string orderBy = null);

        /// <summary>
        /// Get all assets of one subscription
        /// </summary>
        /// <remarks>
        /// Returns a list of all assets that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;status, tenant, parent, pictures, product, product.manufacturer, product.pictures, product.status, product.categories, product.categories.parent, specifications, specifications[key1,key2], product.tenant,                             product.manufacturer.tenant, status.tenant, instrumentations &#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="serialNumber">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productCategoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="manufacturerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusCode">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productionDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="nodeId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all assets with no nodes assigned or \&quot;!null\&quot; for any assigned node.  By adding &#x60;+&#x60; after the id, the filter considers the given node and all its sub components (nodes, instrumentations and systems), but this is not usable in combination with a comma list. (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="ownershipClaimed">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;serial_number&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, &#x60;last_seen_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of AssetsResponse</returns>
        ApiResponse<AssetsResponse> GetAssetsOfSubscriptionWithHttpInfo (long? subscriptionId, int? page = null, int? perPage = null, string include = null, string serialNumber = null, string productId = null, string productCategoryId = null, string parentId = null, string manufacturerId = null, string statusId = null, string statusCode = null, DateTime? productionDate = null, DateTime? productionDateFrom = null, DateTime? productionDateTo = null, string specificationsKey = null, string specificationsValue = null, string nodeId = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, bool? ownershipClaimed = null, string permission = null, string orderBy = null);
        /// <summary>
        /// Get all users or invited emails having a seat in subscription
        /// </summary>
        /// <remarks>
        /// Returns a list of all users or emails.  Possible include values: &#x60;&#x60;&#x60;subscription&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="email">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="userId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="status">one or multiple statuses (comma list). Allowed values are &#x60;pending&#x60;, &#x60;invited&#x60;, &#x60;accepted&#x60; (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>SubscriptionSeatsResponse</returns>
        SubscriptionSeatsResponse GetSeatUsersOfSubscription (long? subscriptionId, int? page = null, int? perPage = null, string include = null, string email = null, long? userId = null, string status = null, string orderBy = null);

        /// <summary>
        /// Get all users or invited emails having a seat in subscription
        /// </summary>
        /// <remarks>
        /// Returns a list of all users or emails.  Possible include values: &#x60;&#x60;&#x60;subscription&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="email">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="userId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="status">one or multiple statuses (comma list). Allowed values are &#x60;pending&#x60;, &#x60;invited&#x60;, &#x60;accepted&#x60; (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of SubscriptionSeatsResponse</returns>
        ApiResponse<SubscriptionSeatsResponse> GetSeatUsersOfSubscriptionWithHttpInfo (long? subscriptionId, int? page = null, int? perPage = null, string include = null, string email = null, long? userId = null, string status = null, string orderBy = null);
        /// <summary>
        /// Get specifications of a subscription
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>SpecificationsResponse</returns>
        SpecificationsResponse GetSpecificationsOfSubscription (long? subscriptionId, string key = null);

        /// <summary>
        /// Get specifications of a subscription
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>ApiResponse of SpecificationsResponse</returns>
        ApiResponse<SpecificationsResponse> GetSpecificationsOfSubscriptionWithHttpInfo (long? subscriptionId, string key = null);
        /// <summary>
        /// Get a single subscription
        /// </summary>
        /// <remarks>
        /// Get a specific subscription identified by the id in the URL.  Possible include values: &#x60;&#x60;&#x60;user, user.usage, specifications, specifications[key1,key2], customer&#x60;&#x60;&#x60; 
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the subscription to fetch</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <returns>SubscriptionResponse</returns>
        SubscriptionResponse GetSubscriptionById (long? id, string include = null);

        /// <summary>
        /// Get a single subscription
        /// </summary>
        /// <remarks>
        /// Get a specific subscription identified by the id in the URL.  Possible include values: &#x60;&#x60;&#x60;user, user.usage, specifications, specifications[key1,key2], customer&#x60;&#x60;&#x60; 
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the subscription to fetch</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <returns>ApiResponse of SubscriptionResponse</returns>
        ApiResponse<SubscriptionResponse> GetSubscriptionByIdWithHttpInfo (long? id, string include = null);
        /// <summary>
        /// Get a range of subscription seats
        /// </summary>
        /// <remarks>
        /// Returns a list of subscriptions seats.  Possible include values: &#x60;&#x60;&#x60;subscription, subscription.user&#x60;&#x60;&#x60; 
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="email">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="userId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="status">one or multiple statuses (comma list). Allowed values are &#x60;pending&#x60;, &#x60;invited&#x60;, &#x60;accepted&#x60; (optional)</param>
        /// <param name="clientApplicationId">Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>SubscriptionSeatsResponse</returns>
        SubscriptionSeatsResponse GetSubscriptionSeats (int? page = null, int? perPage = null, string include = null, string email = null, long? userId = null, string status = null, long? clientApplicationId = null, string orderBy = null);

        /// <summary>
        /// Get a range of subscription seats
        /// </summary>
        /// <remarks>
        /// Returns a list of subscriptions seats.  Possible include values: &#x60;&#x60;&#x60;subscription, subscription.user&#x60;&#x60;&#x60; 
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="email">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="userId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="status">one or multiple statuses (comma list). Allowed values are &#x60;pending&#x60;, &#x60;invited&#x60;, &#x60;accepted&#x60; (optional)</param>
        /// <param name="clientApplicationId">Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of SubscriptionSeatsResponse</returns>
        ApiResponse<SubscriptionSeatsResponse> GetSubscriptionSeatsWithHttpInfo (int? page = null, int? perPage = null, string include = null, string email = null, long? userId = null, string status = null, long? clientApplicationId = null, string orderBy = null);
        /// <summary>
        /// Get a range of subscriptions
        /// </summary>
        /// <remarks>
        /// Returns a list of subscriptions.  Possible include values: &#x60;&#x60;&#x60;user, user.usage, specifications, specifications[key1,key2], customer&#x60;&#x60;&#x60; 
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="userId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="clientApplicationId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="externalReference">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="status">one or multiple statuses (comma list). Allowed values are &#x60;open&#x60;, &#x60;payment_required&#x60;, &#x60;confirmed&#x60;, &#x60;scheduled_update&#x60;, &#x60;non_renewing&#x60; and &#x60;cancelled&#x60; (optional)</param>
        /// <param name="notificationStatus">Filter by notification status - no wildcard support (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="startDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="endDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="scope">Filter accepts &#x60;RESELLER&#x60;, &#x60;USER&#x60; or &#x60;USABLE&#x60;.&#x60;RESELLER&#x60; can be used for reseller users to get subscriptions that they sold to other users. &#x60;USER&#x60; returns all subscriptions where the user is the owner, is a seat user or has can_read permissions to access the subscription, for a reseller the subscriptions returned from &#x60;RESELLER&#x60; filter are excluded from the &#x60;USER&#x60; result. The result of &#x60;USER&#x60; can include usable and not usable subscriptions. Subscription is marked as usable if it can be used in the applications to access data. &#x60;USABLE&#x60; filter retruns a subset of the &#x60;USER&#x60; result which excludes subscriptions that are only visible because of the can_read permission (not usable). (optional)</param>
        /// <param name="resellerLabel">Filter accepts &#x60;*&#x60; as wildcard. Filter acccepts \&quot;null\&quot; for all objects with no reseller label or \&quot;!null\&quot; for all with any reseller label (optional)</param>
        /// <param name="customerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>SubscriptionsResponse</returns>
        SubscriptionsResponse GetSubscriptions (int? page = null, int? perPage = null, string include = null, long? userId = null, long? clientApplicationId = null, string externalReference = null, string status = null, string notificationStatus = null, string specificationsKey = null, string specificationsValue = null, DateTime? startDate = null, DateTime? endDate = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, string scope = null, string resellerLabel = null, string customerId = null, string orderBy = null);

        /// <summary>
        /// Get a range of subscriptions
        /// </summary>
        /// <remarks>
        /// Returns a list of subscriptions.  Possible include values: &#x60;&#x60;&#x60;user, user.usage, specifications, specifications[key1,key2], customer&#x60;&#x60;&#x60; 
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="userId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="clientApplicationId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="externalReference">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="status">one or multiple statuses (comma list). Allowed values are &#x60;open&#x60;, &#x60;payment_required&#x60;, &#x60;confirmed&#x60;, &#x60;scheduled_update&#x60;, &#x60;non_renewing&#x60; and &#x60;cancelled&#x60; (optional)</param>
        /// <param name="notificationStatus">Filter by notification status - no wildcard support (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="startDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="endDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="scope">Filter accepts &#x60;RESELLER&#x60;, &#x60;USER&#x60; or &#x60;USABLE&#x60;.&#x60;RESELLER&#x60; can be used for reseller users to get subscriptions that they sold to other users. &#x60;USER&#x60; returns all subscriptions where the user is the owner, is a seat user or has can_read permissions to access the subscription, for a reseller the subscriptions returned from &#x60;RESELLER&#x60; filter are excluded from the &#x60;USER&#x60; result. The result of &#x60;USER&#x60; can include usable and not usable subscriptions. Subscription is marked as usable if it can be used in the applications to access data. &#x60;USABLE&#x60; filter retruns a subset of the &#x60;USER&#x60; result which excludes subscriptions that are only visible because of the can_read permission (not usable). (optional)</param>
        /// <param name="resellerLabel">Filter accepts &#x60;*&#x60; as wildcard. Filter acccepts \&quot;null\&quot; for all objects with no reseller label or \&quot;!null\&quot; for all with any reseller label (optional)</param>
        /// <param name="customerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of SubscriptionsResponse</returns>
        ApiResponse<SubscriptionsResponse> GetSubscriptionsWithHttpInfo (int? page = null, int? perPage = null, string include = null, long? userId = null, long? clientApplicationId = null, string externalReference = null, string status = null, string notificationStatus = null, string specificationsKey = null, string specificationsValue = null, DateTime? startDate = null, DateTime? endDate = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, string scope = null, string resellerLabel = null, string customerId = null, string orderBy = null);
        /// <summary>
        /// Remove assets from a subscription
        /// </summary>
        /// <remarks>
        /// Remove one or more assets from a subscription in your accessible scope.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="subscriptionId">Id of the subscription from which the assets will be removed</param>
        /// <returns></returns>
        void RemoveAssetsFromSubscription (AssetIDs body, long? subscriptionId);

        /// <summary>
        /// Remove assets from a subscription
        /// </summary>
        /// <remarks>
        /// Remove one or more assets from a subscription in your accessible scope.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="subscriptionId">Id of the subscription from which the assets will be removed</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveAssetsFromSubscriptionWithHttpInfo (AssetIDs body, long? subscriptionId);
        /// <summary>
        /// Remove users (existing users) or emails (new users) from a seat in subscription
        /// </summary>
        /// <remarks>
        /// Remove one or more users or emails from a seat in subscription. **Either id or email pro entry should be provided (not both).** If an email is provided for existing user, then given user will be used. This operation does send notification emails to the seat user, so it should be used by the owner to remove seats.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="subscriptionId">Id of the subscription from which the user will be removed</param>
        /// <returns></returns>
        void RemoveSeatUsersFromSubscription (UserIDorEmails body, long? subscriptionId);

        /// <summary>
        /// Remove users (existing users) or emails (new users) from a seat in subscription
        /// </summary>
        /// <remarks>
        /// Remove one or more users or emails from a seat in subscription. **Either id or email pro entry should be provided (not both).** If an email is provided for existing user, then given user will be used. This operation does send notification emails to the seat user, so it should be used by the owner to remove seats.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="subscriptionId">Id of the subscription from which the user will be removed</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveSeatUsersFromSubscriptionWithHttpInfo (UserIDorEmails body, long? subscriptionId);
        /// <summary>
        /// Delete specifications of a subscription
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns></returns>
        void RemoveSpecificationsFromSubscriptions (List<string> body, long? subscriptionId);

        /// <summary>
        /// Delete specifications of a subscription
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveSpecificationsFromSubscriptionsWithHttpInfo (List<string> body, long? subscriptionId);
        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of a subscription in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns></returns>
        void RenameSpecificationsOfSubscriptions (SpecificationsRename body, long? subscriptionId);

        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of a subscription in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RenameSpecificationsOfSubscriptionsWithHttpInfo (SpecificationsRename body, long? subscriptionId);
        /// <summary>
        /// Replace the assets of a subscription
        /// </summary>
        /// <remarks>
        /// Replaces all assets belonging to a subscription in your accessible scope. You can send a list of resources that will replace all previous values.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="subscriptionId">Id of the subscription of which the assets will be replaced</param>
        /// <returns></returns>
        void ReplaceAssetsOfSubscription (AssetIDs body, long? subscriptionId);

        /// <summary>
        /// Replace the assets of a subscription
        /// </summary>
        /// <remarks>
        /// Replaces all assets belonging to a subscription in your accessible scope. You can send a list of resources that will replace all previous values.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="subscriptionId">Id of the subscription of which the assets will be replaced</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReplaceAssetsOfSubscriptionWithHttpInfo (AssetIDs body, long? subscriptionId);
        /// <summary>
        /// Unassign assets to a subscription based on a filter
        /// </summary>
        /// <remarks>
        /// Unassign one or more assets to a subscription based on a filter. Body may contain an object id and type which then will return all assets assigned to that object directly or indirectly (through other objects). Body may contain an index search query to search assets based on a set of fields (like in the /search endpoint), only assets matching that search will be returned. Body may combine these conditions or even may contain none of them (in the latter case all readable assets is used). The assets returned from the filter are then unassigned to the subscription. An error is raised if the filter given, does not contain any asset. If an asset is already unassigned, it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="subscriptionId">Id of the subscription to which the assets will be added</param>
        /// <returns></returns>
        void UnassignAssetSetToSubscription (SubscriptionAssetAssignmentRequest body, long? subscriptionId);

        /// <summary>
        /// Unassign assets to a subscription based on a filter
        /// </summary>
        /// <remarks>
        /// Unassign one or more assets to a subscription based on a filter. Body may contain an object id and type which then will return all assets assigned to that object directly or indirectly (through other objects). Body may contain an index search query to search assets based on a set of fields (like in the /search endpoint), only assets matching that search will be returned. Body may combine these conditions or even may contain none of them (in the latter case all readable assets is used). The assets returned from the filter are then unassigned to the subscription. An error is raised if the filter given, does not contain any asset. If an asset is already unassigned, it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="subscriptionId">Id of the subscription to which the assets will be added</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UnassignAssetSetToSubscriptionWithHttpInfo (SubscriptionAssetAssignmentRequest body, long? subscriptionId);
        /// <summary>
        /// Update specifications of a subscription
        /// </summary>
        /// <remarks>
        /// Update the specification object of a subscription in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns></returns>
        void UpdateSpecificationsOfSubscriptions (Dictionary<string, SpecificationRequest> body, long? subscriptionId);

        /// <summary>
        /// Update specifications of a subscription
        /// </summary>
        /// <remarks>
        /// Update the specification object of a subscription in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateSpecificationsOfSubscriptionsWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? subscriptionId);
        /// <summary>
        /// Update a subscription
        /// </summary>
        /// <remarks>
        /// Update accessible parameters of the requested resource. Setting a successor or predecessor is possible. The client_application and user of the given Subscription and the reference Subscription have to match to do so. The successor/predecessor of a subscription cant be itself
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the subscription to update</param>
        /// <returns></returns>
        void UpdateSubscription (SubscriptionRequest body, long? id);

        /// <summary>
        /// Update a subscription
        /// </summary>
        /// <remarks>
        /// Update accessible parameters of the requested resource. Setting a successor or predecessor is possible. The client_application and user of the given Subscription and the reference Subscription have to match to do so. The successor/predecessor of a subscription cant be itself
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the subscription to update</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateSubscriptionWithHttpInfo (SubscriptionRequest body, long? id);
        /// <summary>
        /// Update a subscription seat
        /// </summary>
        /// <remarks>
        /// Update the status of a subscription seat
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the subscription seat to update</param>
        /// <returns></returns>
        void UpdateSubscriptionSeat (SubscriptionSeatPatch body, long? id);

        /// <summary>
        /// Update a subscription seat
        /// </summary>
        /// <remarks>
        /// Update the status of a subscription seat
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the subscription seat to update</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateSubscriptionSeatWithHttpInfo (SubscriptionSeatPatch body, long? id);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Add assets to a subscription
        /// </summary>
        /// <remarks>
        /// Add one or more assets to a subscription.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="subscriptionId">Id of the subscription to which the assets will be added</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task AddAssetsToSubscriptionAsync (AssetIDs body, long? subscriptionId);

        /// <summary>
        /// Add assets to a subscription
        /// </summary>
        /// <remarks>
        /// Add one or more assets to a subscription.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="subscriptionId">Id of the subscription to which the assets will be added</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> AddAssetsToSubscriptionAsyncWithHttpInfo (AssetIDs body, long? subscriptionId);
        /// <summary>
        /// Add users (existing users) or emails (new users) to a seat in subscription
        /// </summary>
        /// <remarks>
        /// Add one or more users to a seat in subscription. User can only have one subscription per service (as seat user or as owner), the amount of available seats is defined in seat_quota of subscription. One or more emails can also be sent for users that do not yet exist in Netilion, the users emails will then be invited to join Netilion. &#x60;&#x60;&#x60;Either id or email pro entry should be provided (not both).&#x60;&#x60;&#x60; If an email is provided for existing user, then given user will be used.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="subscriptionId">Id of the subscription to which the user will be added</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task AddSeatUsersToSubscriptionAsync (UserIDorEmails body, long? subscriptionId);

        /// <summary>
        /// Add users (existing users) or emails (new users) to a seat in subscription
        /// </summary>
        /// <remarks>
        /// Add one or more users to a seat in subscription. User can only have one subscription per service (as seat user or as owner), the amount of available seats is defined in seat_quota of subscription. One or more emails can also be sent for users that do not yet exist in Netilion, the users emails will then be invited to join Netilion. &#x60;&#x60;&#x60;Either id or email pro entry should be provided (not both).&#x60;&#x60;&#x60; If an email is provided for existing user, then given user will be used.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="subscriptionId">Id of the subscription to which the user will be added</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> AddSeatUsersToSubscriptionAsyncWithHttpInfo (UserIDorEmails body, long? subscriptionId);
        /// <summary>
        /// Assign assets to a subscription based on a filter
        /// </summary>
        /// <remarks>
        /// Assign one or more assets to a subscription based on a filter. Body may contain an object id and type which then will return all assets assigned to that object directly or indirectly (through other objects). Body may contain an index search query to search assets based on a set of fields (like in the /search endpoint), only assets matching that search will be returned. Body may combine these conditions or even may contain none of them (in the latter case all readable assets is used). The assets returned from the filter are then assigned to the subscription. An error is raised if the filter given, does not contain any asset. If an asset is already assigned, it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="subscriptionId">Id of the subscription to which the assets will be added</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task AssignAssetSetToSubscriptionAsync (SubscriptionAssetAssignmentRequest body, long? subscriptionId);

        /// <summary>
        /// Assign assets to a subscription based on a filter
        /// </summary>
        /// <remarks>
        /// Assign one or more assets to a subscription based on a filter. Body may contain an object id and type which then will return all assets assigned to that object directly or indirectly (through other objects). Body may contain an index search query to search assets based on a set of fields (like in the /search endpoint), only assets matching that search will be returned. Body may combine these conditions or even may contain none of them (in the latter case all readable assets is used). The assets returned from the filter are then assigned to the subscription. An error is raised if the filter given, does not contain any asset. If an asset is already assigned, it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="subscriptionId">Id of the subscription to which the assets will be added</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> AssignAssetSetToSubscriptionAsyncWithHttpInfo (SubscriptionAssetAssignmentRequest body, long? subscriptionId);
        /// <summary>
        /// Create a new subscription
        /// </summary>
        /// <remarks>
        /// Creates a new subscription. Only available for technical_users of the client_application and admins. Setting a successor or predecessor is possible. The client_application and user of the given Subscription and the reference Subscription have to match to do so.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">subscription body</param>
        /// <returns>Task of SubscriptionResponse</returns>
        System.Threading.Tasks.Task<SubscriptionResponse> CreateSubscriptionAsync (SubscriptionRequest body);

        /// <summary>
        /// Create a new subscription
        /// </summary>
        /// <remarks>
        /// Creates a new subscription. Only available for technical_users of the client_application and admins. Setting a successor or predecessor is possible. The client_application and user of the given Subscription and the reference Subscription have to match to do so.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">subscription body</param>
        /// <returns>Task of ApiResponse (SubscriptionResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SubscriptionResponse>> CreateSubscriptionAsyncWithHttpInfo (SubscriptionRequest body);
        /// <summary>
        /// Delete a subscription
        /// </summary>
        /// <remarks>
        /// Delete a specific subscription identified by the id in the URL.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the subscription</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteSubscriptionAsync (long? id);

        /// <summary>
        /// Delete a subscription
        /// </summary>
        /// <remarks>
        /// Delete a specific subscription identified by the id in the URL.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the subscription</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteSubscriptionAsyncWithHttpInfo (long? id);
        /// <summary>
        /// Delete a subscription seat
        /// </summary>
        /// <remarks>
        /// Delete a specific subscription seat identified by the id in the URL. This operation does send notification emails to the subscription owner, so it should be used by the invited user.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the subscription seat</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteSubscriptionSeatAsync (long? id);

        /// <summary>
        /// Delete a subscription seat
        /// </summary>
        /// <remarks>
        /// Delete a specific subscription seat identified by the id in the URL. This operation does send notification emails to the subscription owner, so it should be used by the invited user.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the subscription seat</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteSubscriptionSeatAsyncWithHttpInfo (long? id);
        /// <summary>
        /// Get all assets of one subscription
        /// </summary>
        /// <remarks>
        /// Returns a list of all assets that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;status, tenant, parent, pictures, product, product.manufacturer, product.pictures, product.status, product.categories, product.categories.parent, specifications, specifications[key1,key2], product.tenant,                             product.manufacturer.tenant, status.tenant, instrumentations &#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="serialNumber">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productCategoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="manufacturerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusCode">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productionDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="nodeId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all assets with no nodes assigned or \&quot;!null\&quot; for any assigned node.  By adding &#x60;+&#x60; after the id, the filter considers the given node and all its sub components (nodes, instrumentations and systems), but this is not usable in combination with a comma list. (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="ownershipClaimed">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;serial_number&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, &#x60;last_seen_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of AssetsResponse</returns>
        System.Threading.Tasks.Task<AssetsResponse> GetAssetsOfSubscriptionAsync (long? subscriptionId, int? page = null, int? perPage = null, string include = null, string serialNumber = null, string productId = null, string productCategoryId = null, string parentId = null, string manufacturerId = null, string statusId = null, string statusCode = null, DateTime? productionDate = null, DateTime? productionDateFrom = null, DateTime? productionDateTo = null, string specificationsKey = null, string specificationsValue = null, string nodeId = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, bool? ownershipClaimed = null, string permission = null, string orderBy = null);

        /// <summary>
        /// Get all assets of one subscription
        /// </summary>
        /// <remarks>
        /// Returns a list of all assets that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;status, tenant, parent, pictures, product, product.manufacturer, product.pictures, product.status, product.categories, product.categories.parent, specifications, specifications[key1,key2], product.tenant,                             product.manufacturer.tenant, status.tenant, instrumentations &#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="serialNumber">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productCategoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="manufacturerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusCode">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productionDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="nodeId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all assets with no nodes assigned or \&quot;!null\&quot; for any assigned node.  By adding &#x60;+&#x60; after the id, the filter considers the given node and all its sub components (nodes, instrumentations and systems), but this is not usable in combination with a comma list. (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="ownershipClaimed">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;serial_number&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, &#x60;last_seen_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (AssetsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<AssetsResponse>> GetAssetsOfSubscriptionAsyncWithHttpInfo (long? subscriptionId, int? page = null, int? perPage = null, string include = null, string serialNumber = null, string productId = null, string productCategoryId = null, string parentId = null, string manufacturerId = null, string statusId = null, string statusCode = null, DateTime? productionDate = null, DateTime? productionDateFrom = null, DateTime? productionDateTo = null, string specificationsKey = null, string specificationsValue = null, string nodeId = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, bool? ownershipClaimed = null, string permission = null, string orderBy = null);
        /// <summary>
        /// Get all users or invited emails having a seat in subscription
        /// </summary>
        /// <remarks>
        /// Returns a list of all users or emails.  Possible include values: &#x60;&#x60;&#x60;subscription&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="email">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="userId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="status">one or multiple statuses (comma list). Allowed values are &#x60;pending&#x60;, &#x60;invited&#x60;, &#x60;accepted&#x60; (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of SubscriptionSeatsResponse</returns>
        System.Threading.Tasks.Task<SubscriptionSeatsResponse> GetSeatUsersOfSubscriptionAsync (long? subscriptionId, int? page = null, int? perPage = null, string include = null, string email = null, long? userId = null, string status = null, string orderBy = null);

        /// <summary>
        /// Get all users or invited emails having a seat in subscription
        /// </summary>
        /// <remarks>
        /// Returns a list of all users or emails.  Possible include values: &#x60;&#x60;&#x60;subscription&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="email">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="userId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="status">one or multiple statuses (comma list). Allowed values are &#x60;pending&#x60;, &#x60;invited&#x60;, &#x60;accepted&#x60; (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (SubscriptionSeatsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SubscriptionSeatsResponse>> GetSeatUsersOfSubscriptionAsyncWithHttpInfo (long? subscriptionId, int? page = null, int? perPage = null, string include = null, string email = null, long? userId = null, string status = null, string orderBy = null);
        /// <summary>
        /// Get specifications of a subscription
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of SpecificationsResponse</returns>
        System.Threading.Tasks.Task<SpecificationsResponse> GetSpecificationsOfSubscriptionAsync (long? subscriptionId, string key = null);

        /// <summary>
        /// Get specifications of a subscription
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SpecificationsResponse>> GetSpecificationsOfSubscriptionAsyncWithHttpInfo (long? subscriptionId, string key = null);
        /// <summary>
        /// Get a single subscription
        /// </summary>
        /// <remarks>
        /// Get a specific subscription identified by the id in the URL.  Possible include values: &#x60;&#x60;&#x60;user, user.usage, specifications, specifications[key1,key2], customer&#x60;&#x60;&#x60; 
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the subscription to fetch</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <returns>Task of SubscriptionResponse</returns>
        System.Threading.Tasks.Task<SubscriptionResponse> GetSubscriptionByIdAsync (long? id, string include = null);

        /// <summary>
        /// Get a single subscription
        /// </summary>
        /// <remarks>
        /// Get a specific subscription identified by the id in the URL.  Possible include values: &#x60;&#x60;&#x60;user, user.usage, specifications, specifications[key1,key2], customer&#x60;&#x60;&#x60; 
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the subscription to fetch</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <returns>Task of ApiResponse (SubscriptionResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SubscriptionResponse>> GetSubscriptionByIdAsyncWithHttpInfo (long? id, string include = null);
        /// <summary>
        /// Get a range of subscription seats
        /// </summary>
        /// <remarks>
        /// Returns a list of subscriptions seats.  Possible include values: &#x60;&#x60;&#x60;subscription, subscription.user&#x60;&#x60;&#x60; 
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="email">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="userId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="status">one or multiple statuses (comma list). Allowed values are &#x60;pending&#x60;, &#x60;invited&#x60;, &#x60;accepted&#x60; (optional)</param>
        /// <param name="clientApplicationId">Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of SubscriptionSeatsResponse</returns>
        System.Threading.Tasks.Task<SubscriptionSeatsResponse> GetSubscriptionSeatsAsync (int? page = null, int? perPage = null, string include = null, string email = null, long? userId = null, string status = null, long? clientApplicationId = null, string orderBy = null);

        /// <summary>
        /// Get a range of subscription seats
        /// </summary>
        /// <remarks>
        /// Returns a list of subscriptions seats.  Possible include values: &#x60;&#x60;&#x60;subscription, subscription.user&#x60;&#x60;&#x60; 
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="email">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="userId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="status">one or multiple statuses (comma list). Allowed values are &#x60;pending&#x60;, &#x60;invited&#x60;, &#x60;accepted&#x60; (optional)</param>
        /// <param name="clientApplicationId">Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (SubscriptionSeatsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SubscriptionSeatsResponse>> GetSubscriptionSeatsAsyncWithHttpInfo (int? page = null, int? perPage = null, string include = null, string email = null, long? userId = null, string status = null, long? clientApplicationId = null, string orderBy = null);
        /// <summary>
        /// Get a range of subscriptions
        /// </summary>
        /// <remarks>
        /// Returns a list of subscriptions.  Possible include values: &#x60;&#x60;&#x60;user, user.usage, specifications, specifications[key1,key2], customer&#x60;&#x60;&#x60; 
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="userId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="clientApplicationId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="externalReference">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="status">one or multiple statuses (comma list). Allowed values are &#x60;open&#x60;, &#x60;payment_required&#x60;, &#x60;confirmed&#x60;, &#x60;scheduled_update&#x60;, &#x60;non_renewing&#x60; and &#x60;cancelled&#x60; (optional)</param>
        /// <param name="notificationStatus">Filter by notification status - no wildcard support (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="startDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="endDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="scope">Filter accepts &#x60;RESELLER&#x60;, &#x60;USER&#x60; or &#x60;USABLE&#x60;.&#x60;RESELLER&#x60; can be used for reseller users to get subscriptions that they sold to other users. &#x60;USER&#x60; returns all subscriptions where the user is the owner, is a seat user or has can_read permissions to access the subscription, for a reseller the subscriptions returned from &#x60;RESELLER&#x60; filter are excluded from the &#x60;USER&#x60; result. The result of &#x60;USER&#x60; can include usable and not usable subscriptions. Subscription is marked as usable if it can be used in the applications to access data. &#x60;USABLE&#x60; filter retruns a subset of the &#x60;USER&#x60; result which excludes subscriptions that are only visible because of the can_read permission (not usable). (optional)</param>
        /// <param name="resellerLabel">Filter accepts &#x60;*&#x60; as wildcard. Filter acccepts \&quot;null\&quot; for all objects with no reseller label or \&quot;!null\&quot; for all with any reseller label (optional)</param>
        /// <param name="customerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of SubscriptionsResponse</returns>
        System.Threading.Tasks.Task<SubscriptionsResponse> GetSubscriptionsAsync (int? page = null, int? perPage = null, string include = null, long? userId = null, long? clientApplicationId = null, string externalReference = null, string status = null, string notificationStatus = null, string specificationsKey = null, string specificationsValue = null, DateTime? startDate = null, DateTime? endDate = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, string scope = null, string resellerLabel = null, string customerId = null, string orderBy = null);

        /// <summary>
        /// Get a range of subscriptions
        /// </summary>
        /// <remarks>
        /// Returns a list of subscriptions.  Possible include values: &#x60;&#x60;&#x60;user, user.usage, specifications, specifications[key1,key2], customer&#x60;&#x60;&#x60; 
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="userId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="clientApplicationId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="externalReference">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="status">one or multiple statuses (comma list). Allowed values are &#x60;open&#x60;, &#x60;payment_required&#x60;, &#x60;confirmed&#x60;, &#x60;scheduled_update&#x60;, &#x60;non_renewing&#x60; and &#x60;cancelled&#x60; (optional)</param>
        /// <param name="notificationStatus">Filter by notification status - no wildcard support (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="startDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="endDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="scope">Filter accepts &#x60;RESELLER&#x60;, &#x60;USER&#x60; or &#x60;USABLE&#x60;.&#x60;RESELLER&#x60; can be used for reseller users to get subscriptions that they sold to other users. &#x60;USER&#x60; returns all subscriptions where the user is the owner, is a seat user or has can_read permissions to access the subscription, for a reseller the subscriptions returned from &#x60;RESELLER&#x60; filter are excluded from the &#x60;USER&#x60; result. The result of &#x60;USER&#x60; can include usable and not usable subscriptions. Subscription is marked as usable if it can be used in the applications to access data. &#x60;USABLE&#x60; filter retruns a subset of the &#x60;USER&#x60; result which excludes subscriptions that are only visible because of the can_read permission (not usable). (optional)</param>
        /// <param name="resellerLabel">Filter accepts &#x60;*&#x60; as wildcard. Filter acccepts \&quot;null\&quot; for all objects with no reseller label or \&quot;!null\&quot; for all with any reseller label (optional)</param>
        /// <param name="customerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (SubscriptionsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SubscriptionsResponse>> GetSubscriptionsAsyncWithHttpInfo (int? page = null, int? perPage = null, string include = null, long? userId = null, long? clientApplicationId = null, string externalReference = null, string status = null, string notificationStatus = null, string specificationsKey = null, string specificationsValue = null, DateTime? startDate = null, DateTime? endDate = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, string scope = null, string resellerLabel = null, string customerId = null, string orderBy = null);
        /// <summary>
        /// Remove assets from a subscription
        /// </summary>
        /// <remarks>
        /// Remove one or more assets from a subscription in your accessible scope.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="subscriptionId">Id of the subscription from which the assets will be removed</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveAssetsFromSubscriptionAsync (AssetIDs body, long? subscriptionId);

        /// <summary>
        /// Remove assets from a subscription
        /// </summary>
        /// <remarks>
        /// Remove one or more assets from a subscription in your accessible scope.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="subscriptionId">Id of the subscription from which the assets will be removed</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveAssetsFromSubscriptionAsyncWithHttpInfo (AssetIDs body, long? subscriptionId);
        /// <summary>
        /// Remove users (existing users) or emails (new users) from a seat in subscription
        /// </summary>
        /// <remarks>
        /// Remove one or more users or emails from a seat in subscription. **Either id or email pro entry should be provided (not both).** If an email is provided for existing user, then given user will be used. This operation does send notification emails to the seat user, so it should be used by the owner to remove seats.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="subscriptionId">Id of the subscription from which the user will be removed</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveSeatUsersFromSubscriptionAsync (UserIDorEmails body, long? subscriptionId);

        /// <summary>
        /// Remove users (existing users) or emails (new users) from a seat in subscription
        /// </summary>
        /// <remarks>
        /// Remove one or more users or emails from a seat in subscription. **Either id or email pro entry should be provided (not both).** If an email is provided for existing user, then given user will be used. This operation does send notification emails to the seat user, so it should be used by the owner to remove seats.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="subscriptionId">Id of the subscription from which the user will be removed</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveSeatUsersFromSubscriptionAsyncWithHttpInfo (UserIDorEmails body, long? subscriptionId);
        /// <summary>
        /// Delete specifications of a subscription
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveSpecificationsFromSubscriptionsAsync (List<string> body, long? subscriptionId);

        /// <summary>
        /// Delete specifications of a subscription
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveSpecificationsFromSubscriptionsAsyncWithHttpInfo (List<string> body, long? subscriptionId);
        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of a subscription in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RenameSpecificationsOfSubscriptionsAsync (SpecificationsRename body, long? subscriptionId);

        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of a subscription in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RenameSpecificationsOfSubscriptionsAsyncWithHttpInfo (SpecificationsRename body, long? subscriptionId);
        /// <summary>
        /// Replace the assets of a subscription
        /// </summary>
        /// <remarks>
        /// Replaces all assets belonging to a subscription in your accessible scope. You can send a list of resources that will replace all previous values.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="subscriptionId">Id of the subscription of which the assets will be replaced</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task ReplaceAssetsOfSubscriptionAsync (AssetIDs body, long? subscriptionId);

        /// <summary>
        /// Replace the assets of a subscription
        /// </summary>
        /// <remarks>
        /// Replaces all assets belonging to a subscription in your accessible scope. You can send a list of resources that will replace all previous values.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="subscriptionId">Id of the subscription of which the assets will be replaced</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> ReplaceAssetsOfSubscriptionAsyncWithHttpInfo (AssetIDs body, long? subscriptionId);
        /// <summary>
        /// Unassign assets to a subscription based on a filter
        /// </summary>
        /// <remarks>
        /// Unassign one or more assets to a subscription based on a filter. Body may contain an object id and type which then will return all assets assigned to that object directly or indirectly (through other objects). Body may contain an index search query to search assets based on a set of fields (like in the /search endpoint), only assets matching that search will be returned. Body may combine these conditions or even may contain none of them (in the latter case all readable assets is used). The assets returned from the filter are then unassigned to the subscription. An error is raised if the filter given, does not contain any asset. If an asset is already unassigned, it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="subscriptionId">Id of the subscription to which the assets will be added</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UnassignAssetSetToSubscriptionAsync (SubscriptionAssetAssignmentRequest body, long? subscriptionId);

        /// <summary>
        /// Unassign assets to a subscription based on a filter
        /// </summary>
        /// <remarks>
        /// Unassign one or more assets to a subscription based on a filter. Body may contain an object id and type which then will return all assets assigned to that object directly or indirectly (through other objects). Body may contain an index search query to search assets based on a set of fields (like in the /search endpoint), only assets matching that search will be returned. Body may combine these conditions or even may contain none of them (in the latter case all readable assets is used). The assets returned from the filter are then unassigned to the subscription. An error is raised if the filter given, does not contain any asset. If an asset is already unassigned, it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="subscriptionId">Id of the subscription to which the assets will be added</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UnassignAssetSetToSubscriptionAsyncWithHttpInfo (SubscriptionAssetAssignmentRequest body, long? subscriptionId);
        /// <summary>
        /// Update specifications of a subscription
        /// </summary>
        /// <remarks>
        /// Update the specification object of a subscription in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UpdateSpecificationsOfSubscriptionsAsync (Dictionary<string, SpecificationRequest> body, long? subscriptionId);

        /// <summary>
        /// Update specifications of a subscription
        /// </summary>
        /// <remarks>
        /// Update the specification object of a subscription in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSpecificationsOfSubscriptionsAsyncWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? subscriptionId);
        /// <summary>
        /// Update a subscription
        /// </summary>
        /// <remarks>
        /// Update accessible parameters of the requested resource. Setting a successor or predecessor is possible. The client_application and user of the given Subscription and the reference Subscription have to match to do so. The successor/predecessor of a subscription cant be itself
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the subscription to update</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UpdateSubscriptionAsync (SubscriptionRequest body, long? id);

        /// <summary>
        /// Update a subscription
        /// </summary>
        /// <remarks>
        /// Update accessible parameters of the requested resource. Setting a successor or predecessor is possible. The client_application and user of the given Subscription and the reference Subscription have to match to do so. The successor/predecessor of a subscription cant be itself
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the subscription to update</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSubscriptionAsyncWithHttpInfo (SubscriptionRequest body, long? id);
        /// <summary>
        /// Update a subscription seat
        /// </summary>
        /// <remarks>
        /// Update the status of a subscription seat
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the subscription seat to update</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UpdateSubscriptionSeatAsync (SubscriptionSeatPatch body, long? id);

        /// <summary>
        /// Update a subscription seat
        /// </summary>
        /// <remarks>
        /// Update the status of a subscription seat
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the subscription seat to update</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSubscriptionSeatAsyncWithHttpInfo (SubscriptionSeatPatch body, long? id);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
        public partial class SubscriptionApi : ISubscriptionApi
    {
        private Netilion.Api.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="SubscriptionApi"/> class.
        /// </summary>
        /// <returns></returns>
        public SubscriptionApi(String basePath)
        {
            this.Configuration = new Netilion.Api.Client.Configuration { BasePath = basePath };

            ExceptionFactory = Netilion.Api.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SubscriptionApi"/> class
        /// </summary>
        /// <returns></returns>
        public SubscriptionApi()
        {
            this.Configuration = Netilion.Api.Client.Configuration.Default;

            ExceptionFactory = Netilion.Api.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SubscriptionApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public SubscriptionApi(Netilion.Api.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = Netilion.Api.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = Netilion.Api.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Netilion.Api.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Netilion.Api.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Add assets to a subscription Add one or more assets to a subscription.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="subscriptionId">Id of the subscription to which the assets will be added</param>
        /// <returns></returns>
        public void AddAssetsToSubscription (AssetIDs body, long? subscriptionId)
        {
             AddAssetsToSubscriptionWithHttpInfo(body, subscriptionId);
        }

        /// <summary>
        /// Add assets to a subscription Add one or more assets to a subscription.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="subscriptionId">Id of the subscription to which the assets will be added</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> AddAssetsToSubscriptionWithHttpInfo (AssetIDs body, long? subscriptionId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SubscriptionApi->AddAssetsToSubscription");
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionId' when calling SubscriptionApi->AddAssetsToSubscription");

            var localVarPath = "/subscriptions/{subscription_id}/assets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionId != null) localVarPathParams.Add("subscription_id", this.Configuration.ApiClient.ParameterToString(subscriptionId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddAssetsToSubscription", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Add assets to a subscription Add one or more assets to a subscription.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="subscriptionId">Id of the subscription to which the assets will be added</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task AddAssetsToSubscriptionAsync (AssetIDs body, long? subscriptionId)
        {
             await AddAssetsToSubscriptionAsyncWithHttpInfo(body, subscriptionId);

        }

        /// <summary>
        /// Add assets to a subscription Add one or more assets to a subscription.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="subscriptionId">Id of the subscription to which the assets will be added</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> AddAssetsToSubscriptionAsyncWithHttpInfo (AssetIDs body, long? subscriptionId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SubscriptionApi->AddAssetsToSubscription");
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionId' when calling SubscriptionApi->AddAssetsToSubscription");

            var localVarPath = "/subscriptions/{subscription_id}/assets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionId != null) localVarPathParams.Add("subscription_id", this.Configuration.ApiClient.ParameterToString(subscriptionId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddAssetsToSubscription", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Add users (existing users) or emails (new users) to a seat in subscription Add one or more users to a seat in subscription. User can only have one subscription per service (as seat user or as owner), the amount of available seats is defined in seat_quota of subscription. One or more emails can also be sent for users that do not yet exist in Netilion, the users emails will then be invited to join Netilion. &#x60;&#x60;&#x60;Either id or email pro entry should be provided (not both).&#x60;&#x60;&#x60; If an email is provided for existing user, then given user will be used.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="subscriptionId">Id of the subscription to which the user will be added</param>
        /// <returns></returns>
        public void AddSeatUsersToSubscription (UserIDorEmails body, long? subscriptionId)
        {
             AddSeatUsersToSubscriptionWithHttpInfo(body, subscriptionId);
        }

        /// <summary>
        /// Add users (existing users) or emails (new users) to a seat in subscription Add one or more users to a seat in subscription. User can only have one subscription per service (as seat user or as owner), the amount of available seats is defined in seat_quota of subscription. One or more emails can also be sent for users that do not yet exist in Netilion, the users emails will then be invited to join Netilion. &#x60;&#x60;&#x60;Either id or email pro entry should be provided (not both).&#x60;&#x60;&#x60; If an email is provided for existing user, then given user will be used.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="subscriptionId">Id of the subscription to which the user will be added</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> AddSeatUsersToSubscriptionWithHttpInfo (UserIDorEmails body, long? subscriptionId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SubscriptionApi->AddSeatUsersToSubscription");
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionId' when calling SubscriptionApi->AddSeatUsersToSubscription");

            var localVarPath = "/subscriptions/{subscription_id}/seats";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionId != null) localVarPathParams.Add("subscription_id", this.Configuration.ApiClient.ParameterToString(subscriptionId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddSeatUsersToSubscription", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Add users (existing users) or emails (new users) to a seat in subscription Add one or more users to a seat in subscription. User can only have one subscription per service (as seat user or as owner), the amount of available seats is defined in seat_quota of subscription. One or more emails can also be sent for users that do not yet exist in Netilion, the users emails will then be invited to join Netilion. &#x60;&#x60;&#x60;Either id or email pro entry should be provided (not both).&#x60;&#x60;&#x60; If an email is provided for existing user, then given user will be used.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="subscriptionId">Id of the subscription to which the user will be added</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task AddSeatUsersToSubscriptionAsync (UserIDorEmails body, long? subscriptionId)
        {
             await AddSeatUsersToSubscriptionAsyncWithHttpInfo(body, subscriptionId);

        }

        /// <summary>
        /// Add users (existing users) or emails (new users) to a seat in subscription Add one or more users to a seat in subscription. User can only have one subscription per service (as seat user or as owner), the amount of available seats is defined in seat_quota of subscription. One or more emails can also be sent for users that do not yet exist in Netilion, the users emails will then be invited to join Netilion. &#x60;&#x60;&#x60;Either id or email pro entry should be provided (not both).&#x60;&#x60;&#x60; If an email is provided for existing user, then given user will be used.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="subscriptionId">Id of the subscription to which the user will be added</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> AddSeatUsersToSubscriptionAsyncWithHttpInfo (UserIDorEmails body, long? subscriptionId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SubscriptionApi->AddSeatUsersToSubscription");
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionId' when calling SubscriptionApi->AddSeatUsersToSubscription");

            var localVarPath = "/subscriptions/{subscription_id}/seats";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionId != null) localVarPathParams.Add("subscription_id", this.Configuration.ApiClient.ParameterToString(subscriptionId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddSeatUsersToSubscription", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Assign assets to a subscription based on a filter Assign one or more assets to a subscription based on a filter. Body may contain an object id and type which then will return all assets assigned to that object directly or indirectly (through other objects). Body may contain an index search query to search assets based on a set of fields (like in the /search endpoint), only assets matching that search will be returned. Body may combine these conditions or even may contain none of them (in the latter case all readable assets is used). The assets returned from the filter are then assigned to the subscription. An error is raised if the filter given, does not contain any asset. If an asset is already assigned, it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="subscriptionId">Id of the subscription to which the assets will be added</param>
        /// <returns></returns>
        public void AssignAssetSetToSubscription (SubscriptionAssetAssignmentRequest body, long? subscriptionId)
        {
             AssignAssetSetToSubscriptionWithHttpInfo(body, subscriptionId);
        }

        /// <summary>
        /// Assign assets to a subscription based on a filter Assign one or more assets to a subscription based on a filter. Body may contain an object id and type which then will return all assets assigned to that object directly or indirectly (through other objects). Body may contain an index search query to search assets based on a set of fields (like in the /search endpoint), only assets matching that search will be returned. Body may combine these conditions or even may contain none of them (in the latter case all readable assets is used). The assets returned from the filter are then assigned to the subscription. An error is raised if the filter given, does not contain any asset. If an asset is already assigned, it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="subscriptionId">Id of the subscription to which the assets will be added</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> AssignAssetSetToSubscriptionWithHttpInfo (SubscriptionAssetAssignmentRequest body, long? subscriptionId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SubscriptionApi->AssignAssetSetToSubscription");
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionId' when calling SubscriptionApi->AssignAssetSetToSubscription");

            var localVarPath = "/subscriptions/{subscription_id}/asset_assignment";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionId != null) localVarPathParams.Add("subscription_id", this.Configuration.ApiClient.ParameterToString(subscriptionId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AssignAssetSetToSubscription", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Assign assets to a subscription based on a filter Assign one or more assets to a subscription based on a filter. Body may contain an object id and type which then will return all assets assigned to that object directly or indirectly (through other objects). Body may contain an index search query to search assets based on a set of fields (like in the /search endpoint), only assets matching that search will be returned. Body may combine these conditions or even may contain none of them (in the latter case all readable assets is used). The assets returned from the filter are then assigned to the subscription. An error is raised if the filter given, does not contain any asset. If an asset is already assigned, it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="subscriptionId">Id of the subscription to which the assets will be added</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task AssignAssetSetToSubscriptionAsync (SubscriptionAssetAssignmentRequest body, long? subscriptionId)
        {
             await AssignAssetSetToSubscriptionAsyncWithHttpInfo(body, subscriptionId);

        }

        /// <summary>
        /// Assign assets to a subscription based on a filter Assign one or more assets to a subscription based on a filter. Body may contain an object id and type which then will return all assets assigned to that object directly or indirectly (through other objects). Body may contain an index search query to search assets based on a set of fields (like in the /search endpoint), only assets matching that search will be returned. Body may combine these conditions or even may contain none of them (in the latter case all readable assets is used). The assets returned from the filter are then assigned to the subscription. An error is raised if the filter given, does not contain any asset. If an asset is already assigned, it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="subscriptionId">Id of the subscription to which the assets will be added</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> AssignAssetSetToSubscriptionAsyncWithHttpInfo (SubscriptionAssetAssignmentRequest body, long? subscriptionId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SubscriptionApi->AssignAssetSetToSubscription");
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionId' when calling SubscriptionApi->AssignAssetSetToSubscription");

            var localVarPath = "/subscriptions/{subscription_id}/asset_assignment";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionId != null) localVarPathParams.Add("subscription_id", this.Configuration.ApiClient.ParameterToString(subscriptionId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AssignAssetSetToSubscription", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Create a new subscription Creates a new subscription. Only available for technical_users of the client_application and admins. Setting a successor or predecessor is possible. The client_application and user of the given Subscription and the reference Subscription have to match to do so.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">subscription body</param>
        /// <returns>SubscriptionResponse</returns>
        public SubscriptionResponse CreateSubscription (SubscriptionRequest body)
        {
             ApiResponse<SubscriptionResponse> localVarResponse = CreateSubscriptionWithHttpInfo(body);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Create a new subscription Creates a new subscription. Only available for technical_users of the client_application and admins. Setting a successor or predecessor is possible. The client_application and user of the given Subscription and the reference Subscription have to match to do so.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">subscription body</param>
        /// <returns>ApiResponse of SubscriptionResponse</returns>
        public ApiResponse< SubscriptionResponse > CreateSubscriptionWithHttpInfo (SubscriptionRequest body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SubscriptionApi->CreateSubscription");

            var localVarPath = "/subscriptions";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateSubscription", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SubscriptionResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SubscriptionResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SubscriptionResponse)));
        }

        /// <summary>
        /// Create a new subscription Creates a new subscription. Only available for technical_users of the client_application and admins. Setting a successor or predecessor is possible. The client_application and user of the given Subscription and the reference Subscription have to match to do so.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">subscription body</param>
        /// <returns>Task of SubscriptionResponse</returns>
        public async System.Threading.Tasks.Task<SubscriptionResponse> CreateSubscriptionAsync (SubscriptionRequest body)
        {
             ApiResponse<SubscriptionResponse> localVarResponse = await CreateSubscriptionAsyncWithHttpInfo(body);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Create a new subscription Creates a new subscription. Only available for technical_users of the client_application and admins. Setting a successor or predecessor is possible. The client_application and user of the given Subscription and the reference Subscription have to match to do so.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">subscription body</param>
        /// <returns>Task of ApiResponse (SubscriptionResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SubscriptionResponse>> CreateSubscriptionAsyncWithHttpInfo (SubscriptionRequest body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SubscriptionApi->CreateSubscription");

            var localVarPath = "/subscriptions";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateSubscription", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SubscriptionResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SubscriptionResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SubscriptionResponse)));
        }

        /// <summary>
        /// Delete a subscription Delete a specific subscription identified by the id in the URL.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the subscription</param>
        /// <returns></returns>
        public void DeleteSubscription (long? id)
        {
             DeleteSubscriptionWithHttpInfo(id);
        }

        /// <summary>
        /// Delete a subscription Delete a specific subscription identified by the id in the URL.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the subscription</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteSubscriptionWithHttpInfo (long? id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling SubscriptionApi->DeleteSubscription");

            var localVarPath = "/subscriptions/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteSubscription", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete a subscription Delete a specific subscription identified by the id in the URL.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the subscription</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteSubscriptionAsync (long? id)
        {
             await DeleteSubscriptionAsyncWithHttpInfo(id);

        }

        /// <summary>
        /// Delete a subscription Delete a specific subscription identified by the id in the URL.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the subscription</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> DeleteSubscriptionAsyncWithHttpInfo (long? id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling SubscriptionApi->DeleteSubscription");

            var localVarPath = "/subscriptions/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteSubscription", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete a subscription seat Delete a specific subscription seat identified by the id in the URL. This operation does send notification emails to the subscription owner, so it should be used by the invited user.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the subscription seat</param>
        /// <returns></returns>
        public void DeleteSubscriptionSeat (long? id)
        {
             DeleteSubscriptionSeatWithHttpInfo(id);
        }

        /// <summary>
        /// Delete a subscription seat Delete a specific subscription seat identified by the id in the URL. This operation does send notification emails to the subscription owner, so it should be used by the invited user.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the subscription seat</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteSubscriptionSeatWithHttpInfo (long? id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling SubscriptionApi->DeleteSubscriptionSeat");

            var localVarPath = "/subscription/seats/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteSubscriptionSeat", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete a subscription seat Delete a specific subscription seat identified by the id in the URL. This operation does send notification emails to the subscription owner, so it should be used by the invited user.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the subscription seat</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteSubscriptionSeatAsync (long? id)
        {
             await DeleteSubscriptionSeatAsyncWithHttpInfo(id);

        }

        /// <summary>
        /// Delete a subscription seat Delete a specific subscription seat identified by the id in the URL. This operation does send notification emails to the subscription owner, so it should be used by the invited user.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the subscription seat</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> DeleteSubscriptionSeatAsyncWithHttpInfo (long? id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling SubscriptionApi->DeleteSubscriptionSeat");

            var localVarPath = "/subscription/seats/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteSubscriptionSeat", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Get all assets of one subscription Returns a list of all assets that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;status, tenant, parent, pictures, product, product.manufacturer, product.pictures, product.status, product.categories, product.categories.parent, specifications, specifications[key1,key2], product.tenant,                             product.manufacturer.tenant, status.tenant, instrumentations &#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="serialNumber">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productCategoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="manufacturerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusCode">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productionDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="nodeId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all assets with no nodes assigned or \&quot;!null\&quot; for any assigned node.  By adding &#x60;+&#x60; after the id, the filter considers the given node and all its sub components (nodes, instrumentations and systems), but this is not usable in combination with a comma list. (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="ownershipClaimed">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;serial_number&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, &#x60;last_seen_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>AssetsResponse</returns>
        public AssetsResponse GetAssetsOfSubscription (long? subscriptionId, int? page = null, int? perPage = null, string include = null, string serialNumber = null, string productId = null, string productCategoryId = null, string parentId = null, string manufacturerId = null, string statusId = null, string statusCode = null, DateTime? productionDate = null, DateTime? productionDateFrom = null, DateTime? productionDateTo = null, string specificationsKey = null, string specificationsValue = null, string nodeId = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, bool? ownershipClaimed = null, string permission = null, string orderBy = null)
        {
             ApiResponse<AssetsResponse> localVarResponse = GetAssetsOfSubscriptionWithHttpInfo(subscriptionId, page, perPage, include, serialNumber, productId, productCategoryId, parentId, manufacturerId, statusId, statusCode, productionDate, productionDateFrom, productionDateTo, specificationsKey, specificationsValue, nodeId, createdAt, createdAtFrom, createdAtTo, updatedAt, updatedAtFrom, updatedAtTo, ownershipClaimed, permission, orderBy);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get all assets of one subscription Returns a list of all assets that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;status, tenant, parent, pictures, product, product.manufacturer, product.pictures, product.status, product.categories, product.categories.parent, specifications, specifications[key1,key2], product.tenant,                             product.manufacturer.tenant, status.tenant, instrumentations &#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="serialNumber">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productCategoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="manufacturerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusCode">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productionDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="nodeId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all assets with no nodes assigned or \&quot;!null\&quot; for any assigned node.  By adding &#x60;+&#x60; after the id, the filter considers the given node and all its sub components (nodes, instrumentations and systems), but this is not usable in combination with a comma list. (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="ownershipClaimed">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;serial_number&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, &#x60;last_seen_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of AssetsResponse</returns>
        public ApiResponse< AssetsResponse > GetAssetsOfSubscriptionWithHttpInfo (long? subscriptionId, int? page = null, int? perPage = null, string include = null, string serialNumber = null, string productId = null, string productCategoryId = null, string parentId = null, string manufacturerId = null, string statusId = null, string statusCode = null, DateTime? productionDate = null, DateTime? productionDateFrom = null, DateTime? productionDateTo = null, string specificationsKey = null, string specificationsValue = null, string nodeId = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, bool? ownershipClaimed = null, string permission = null, string orderBy = null)
        {
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionId' when calling SubscriptionApi->GetAssetsOfSubscription");

            var localVarPath = "/subscriptions/{subscription_id}/assets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionId != null) localVarPathParams.Add("subscription_id", this.Configuration.ApiClient.ParameterToString(subscriptionId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (serialNumber != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "serial_number", serialNumber)); // query parameter
            if (productId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "product_id", productId)); // query parameter
            if (productCategoryId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "product_category_id", productCategoryId)); // query parameter
            if (parentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "parent_id", parentId)); // query parameter
            if (manufacturerId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "manufacturer_id", manufacturerId)); // query parameter
            if (statusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_id", statusId)); // query parameter
            if (statusCode != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_code", statusCode)); // query parameter
            if (productionDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "production_date", productionDate)); // query parameter
            if (productionDateFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "production_date_from", productionDateFrom)); // query parameter
            if (productionDateTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "production_date_to", productionDateTo)); // query parameter
            if (specificationsKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_key", specificationsKey)); // query parameter
            if (specificationsValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_value", specificationsValue)); // query parameter
            if (nodeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "node_id", nodeId)); // query parameter
            if (createdAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "created_at", createdAt)); // query parameter
            if (createdAtFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "created_at_from", createdAtFrom)); // query parameter
            if (createdAtTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "created_at_to", createdAtTo)); // query parameter
            if (updatedAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at", updatedAt)); // query parameter
            if (updatedAtFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_from", updatedAtFrom)); // query parameter
            if (updatedAtTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_to", updatedAtTo)); // query parameter
            if (ownershipClaimed != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ownership_claimed", ownershipClaimed)); // query parameter
            if (permission != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "permission", permission)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetAssetsOfSubscription", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AssetsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (AssetsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AssetsResponse)));
        }

        /// <summary>
        /// Get all assets of one subscription Returns a list of all assets that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;status, tenant, parent, pictures, product, product.manufacturer, product.pictures, product.status, product.categories, product.categories.parent, specifications, specifications[key1,key2], product.tenant,                             product.manufacturer.tenant, status.tenant, instrumentations &#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="serialNumber">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productCategoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="manufacturerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusCode">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productionDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="nodeId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all assets with no nodes assigned or \&quot;!null\&quot; for any assigned node.  By adding &#x60;+&#x60; after the id, the filter considers the given node and all its sub components (nodes, instrumentations and systems), but this is not usable in combination with a comma list. (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="ownershipClaimed">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;serial_number&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, &#x60;last_seen_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of AssetsResponse</returns>
        public async System.Threading.Tasks.Task<AssetsResponse> GetAssetsOfSubscriptionAsync (long? subscriptionId, int? page = null, int? perPage = null, string include = null, string serialNumber = null, string productId = null, string productCategoryId = null, string parentId = null, string manufacturerId = null, string statusId = null, string statusCode = null, DateTime? productionDate = null, DateTime? productionDateFrom = null, DateTime? productionDateTo = null, string specificationsKey = null, string specificationsValue = null, string nodeId = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, bool? ownershipClaimed = null, string permission = null, string orderBy = null)
        {
             ApiResponse<AssetsResponse> localVarResponse = await GetAssetsOfSubscriptionAsyncWithHttpInfo(subscriptionId, page, perPage, include, serialNumber, productId, productCategoryId, parentId, manufacturerId, statusId, statusCode, productionDate, productionDateFrom, productionDateTo, specificationsKey, specificationsValue, nodeId, createdAt, createdAtFrom, createdAtTo, updatedAt, updatedAtFrom, updatedAtTo, ownershipClaimed, permission, orderBy);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get all assets of one subscription Returns a list of all assets that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;status, tenant, parent, pictures, product, product.manufacturer, product.pictures, product.status, product.categories, product.categories.parent, specifications, specifications[key1,key2], product.tenant,                             product.manufacturer.tenant, status.tenant, instrumentations &#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="serialNumber">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productCategoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="manufacturerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusCode">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productionDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="nodeId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all assets with no nodes assigned or \&quot;!null\&quot; for any assigned node.  By adding &#x60;+&#x60; after the id, the filter considers the given node and all its sub components (nodes, instrumentations and systems), but this is not usable in combination with a comma list. (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="ownershipClaimed">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;serial_number&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, &#x60;last_seen_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (AssetsResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<AssetsResponse>> GetAssetsOfSubscriptionAsyncWithHttpInfo (long? subscriptionId, int? page = null, int? perPage = null, string include = null, string serialNumber = null, string productId = null, string productCategoryId = null, string parentId = null, string manufacturerId = null, string statusId = null, string statusCode = null, DateTime? productionDate = null, DateTime? productionDateFrom = null, DateTime? productionDateTo = null, string specificationsKey = null, string specificationsValue = null, string nodeId = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, bool? ownershipClaimed = null, string permission = null, string orderBy = null)
        {
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionId' when calling SubscriptionApi->GetAssetsOfSubscription");

            var localVarPath = "/subscriptions/{subscription_id}/assets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionId != null) localVarPathParams.Add("subscription_id", this.Configuration.ApiClient.ParameterToString(subscriptionId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (serialNumber != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "serial_number", serialNumber)); // query parameter
            if (productId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "product_id", productId)); // query parameter
            if (productCategoryId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "product_category_id", productCategoryId)); // query parameter
            if (parentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "parent_id", parentId)); // query parameter
            if (manufacturerId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "manufacturer_id", manufacturerId)); // query parameter
            if (statusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_id", statusId)); // query parameter
            if (statusCode != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_code", statusCode)); // query parameter
            if (productionDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "production_date", productionDate)); // query parameter
            if (productionDateFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "production_date_from", productionDateFrom)); // query parameter
            if (productionDateTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "production_date_to", productionDateTo)); // query parameter
            if (specificationsKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_key", specificationsKey)); // query parameter
            if (specificationsValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_value", specificationsValue)); // query parameter
            if (nodeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "node_id", nodeId)); // query parameter
            if (createdAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "created_at", createdAt)); // query parameter
            if (createdAtFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "created_at_from", createdAtFrom)); // query parameter
            if (createdAtTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "created_at_to", createdAtTo)); // query parameter
            if (updatedAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at", updatedAt)); // query parameter
            if (updatedAtFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_from", updatedAtFrom)); // query parameter
            if (updatedAtTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_to", updatedAtTo)); // query parameter
            if (ownershipClaimed != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ownership_claimed", ownershipClaimed)); // query parameter
            if (permission != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "permission", permission)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetAssetsOfSubscription", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AssetsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (AssetsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AssetsResponse)));
        }

        /// <summary>
        /// Get all users or invited emails having a seat in subscription Returns a list of all users or emails.  Possible include values: &#x60;&#x60;&#x60;subscription&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="email">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="userId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="status">one or multiple statuses (comma list). Allowed values are &#x60;pending&#x60;, &#x60;invited&#x60;, &#x60;accepted&#x60; (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>SubscriptionSeatsResponse</returns>
        public SubscriptionSeatsResponse GetSeatUsersOfSubscription (long? subscriptionId, int? page = null, int? perPage = null, string include = null, string email = null, long? userId = null, string status = null, string orderBy = null)
        {
             ApiResponse<SubscriptionSeatsResponse> localVarResponse = GetSeatUsersOfSubscriptionWithHttpInfo(subscriptionId, page, perPage, include, email, userId, status, orderBy);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get all users or invited emails having a seat in subscription Returns a list of all users or emails.  Possible include values: &#x60;&#x60;&#x60;subscription&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="email">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="userId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="status">one or multiple statuses (comma list). Allowed values are &#x60;pending&#x60;, &#x60;invited&#x60;, &#x60;accepted&#x60; (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of SubscriptionSeatsResponse</returns>
        public ApiResponse< SubscriptionSeatsResponse > GetSeatUsersOfSubscriptionWithHttpInfo (long? subscriptionId, int? page = null, int? perPage = null, string include = null, string email = null, long? userId = null, string status = null, string orderBy = null)
        {
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionId' when calling SubscriptionApi->GetSeatUsersOfSubscription");

            var localVarPath = "/subscriptions/{subscription_id}/seats";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionId != null) localVarPathParams.Add("subscription_id", this.Configuration.ApiClient.ParameterToString(subscriptionId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (email != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "email", email)); // query parameter
            if (userId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "user_id", userId)); // query parameter
            if (status != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status", status)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSeatUsersOfSubscription", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SubscriptionSeatsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SubscriptionSeatsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SubscriptionSeatsResponse)));
        }

        /// <summary>
        /// Get all users or invited emails having a seat in subscription Returns a list of all users or emails.  Possible include values: &#x60;&#x60;&#x60;subscription&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="email">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="userId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="status">one or multiple statuses (comma list). Allowed values are &#x60;pending&#x60;, &#x60;invited&#x60;, &#x60;accepted&#x60; (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of SubscriptionSeatsResponse</returns>
        public async System.Threading.Tasks.Task<SubscriptionSeatsResponse> GetSeatUsersOfSubscriptionAsync (long? subscriptionId, int? page = null, int? perPage = null, string include = null, string email = null, long? userId = null, string status = null, string orderBy = null)
        {
             ApiResponse<SubscriptionSeatsResponse> localVarResponse = await GetSeatUsersOfSubscriptionAsyncWithHttpInfo(subscriptionId, page, perPage, include, email, userId, status, orderBy);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get all users or invited emails having a seat in subscription Returns a list of all users or emails.  Possible include values: &#x60;&#x60;&#x60;subscription&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="email">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="userId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="status">one or multiple statuses (comma list). Allowed values are &#x60;pending&#x60;, &#x60;invited&#x60;, &#x60;accepted&#x60; (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (SubscriptionSeatsResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SubscriptionSeatsResponse>> GetSeatUsersOfSubscriptionAsyncWithHttpInfo (long? subscriptionId, int? page = null, int? perPage = null, string include = null, string email = null, long? userId = null, string status = null, string orderBy = null)
        {
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionId' when calling SubscriptionApi->GetSeatUsersOfSubscription");

            var localVarPath = "/subscriptions/{subscription_id}/seats";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionId != null) localVarPathParams.Add("subscription_id", this.Configuration.ApiClient.ParameterToString(subscriptionId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (email != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "email", email)); // query parameter
            if (userId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "user_id", userId)); // query parameter
            if (status != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status", status)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSeatUsersOfSubscription", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SubscriptionSeatsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SubscriptionSeatsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SubscriptionSeatsResponse)));
        }

        /// <summary>
        /// Get specifications of a subscription Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>SpecificationsResponse</returns>
        public SpecificationsResponse GetSpecificationsOfSubscription (long? subscriptionId, string key = null)
        {
             ApiResponse<SpecificationsResponse> localVarResponse = GetSpecificationsOfSubscriptionWithHttpInfo(subscriptionId, key);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get specifications of a subscription Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>ApiResponse of SpecificationsResponse</returns>
        public ApiResponse< SpecificationsResponse > GetSpecificationsOfSubscriptionWithHttpInfo (long? subscriptionId, string key = null)
        {
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionId' when calling SubscriptionApi->GetSpecificationsOfSubscription");

            var localVarPath = "/subscriptions/{subscription_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionId != null) localVarPathParams.Add("subscription_id", this.Configuration.ApiClient.ParameterToString(subscriptionId)); // path parameter
            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationsOfSubscription", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationsResponse)));
        }

        /// <summary>
        /// Get specifications of a subscription Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of SpecificationsResponse</returns>
        public async System.Threading.Tasks.Task<SpecificationsResponse> GetSpecificationsOfSubscriptionAsync (long? subscriptionId, string key = null)
        {
             ApiResponse<SpecificationsResponse> localVarResponse = await GetSpecificationsOfSubscriptionAsyncWithHttpInfo(subscriptionId, key);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get specifications of a subscription Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationsResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SpecificationsResponse>> GetSpecificationsOfSubscriptionAsyncWithHttpInfo (long? subscriptionId, string key = null)
        {
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionId' when calling SubscriptionApi->GetSpecificationsOfSubscription");

            var localVarPath = "/subscriptions/{subscription_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionId != null) localVarPathParams.Add("subscription_id", this.Configuration.ApiClient.ParameterToString(subscriptionId)); // path parameter
            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationsOfSubscription", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationsResponse)));
        }

        /// <summary>
        /// Get a single subscription Get a specific subscription identified by the id in the URL.  Possible include values: &#x60;&#x60;&#x60;user, user.usage, specifications, specifications[key1,key2], customer&#x60;&#x60;&#x60; 
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the subscription to fetch</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <returns>SubscriptionResponse</returns>
        public SubscriptionResponse GetSubscriptionById (long? id, string include = null)
        {
             ApiResponse<SubscriptionResponse> localVarResponse = GetSubscriptionByIdWithHttpInfo(id, include);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get a single subscription Get a specific subscription identified by the id in the URL.  Possible include values: &#x60;&#x60;&#x60;user, user.usage, specifications, specifications[key1,key2], customer&#x60;&#x60;&#x60; 
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the subscription to fetch</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <returns>ApiResponse of SubscriptionResponse</returns>
        public ApiResponse< SubscriptionResponse > GetSubscriptionByIdWithHttpInfo (long? id, string include = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling SubscriptionApi->GetSubscriptionById");

            var localVarPath = "/subscriptions/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSubscriptionById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SubscriptionResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SubscriptionResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SubscriptionResponse)));
        }

        /// <summary>
        /// Get a single subscription Get a specific subscription identified by the id in the URL.  Possible include values: &#x60;&#x60;&#x60;user, user.usage, specifications, specifications[key1,key2], customer&#x60;&#x60;&#x60; 
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the subscription to fetch</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <returns>Task of SubscriptionResponse</returns>
        public async System.Threading.Tasks.Task<SubscriptionResponse> GetSubscriptionByIdAsync (long? id, string include = null)
        {
             ApiResponse<SubscriptionResponse> localVarResponse = await GetSubscriptionByIdAsyncWithHttpInfo(id, include);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get a single subscription Get a specific subscription identified by the id in the URL.  Possible include values: &#x60;&#x60;&#x60;user, user.usage, specifications, specifications[key1,key2], customer&#x60;&#x60;&#x60; 
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the subscription to fetch</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <returns>Task of ApiResponse (SubscriptionResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SubscriptionResponse>> GetSubscriptionByIdAsyncWithHttpInfo (long? id, string include = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling SubscriptionApi->GetSubscriptionById");

            var localVarPath = "/subscriptions/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSubscriptionById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SubscriptionResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SubscriptionResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SubscriptionResponse)));
        }

        /// <summary>
        /// Get a range of subscription seats Returns a list of subscriptions seats.  Possible include values: &#x60;&#x60;&#x60;subscription, subscription.user&#x60;&#x60;&#x60; 
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="email">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="userId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="status">one or multiple statuses (comma list). Allowed values are &#x60;pending&#x60;, &#x60;invited&#x60;, &#x60;accepted&#x60; (optional)</param>
        /// <param name="clientApplicationId">Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>SubscriptionSeatsResponse</returns>
        public SubscriptionSeatsResponse GetSubscriptionSeats (int? page = null, int? perPage = null, string include = null, string email = null, long? userId = null, string status = null, long? clientApplicationId = null, string orderBy = null)
        {
             ApiResponse<SubscriptionSeatsResponse> localVarResponse = GetSubscriptionSeatsWithHttpInfo(page, perPage, include, email, userId, status, clientApplicationId, orderBy);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get a range of subscription seats Returns a list of subscriptions seats.  Possible include values: &#x60;&#x60;&#x60;subscription, subscription.user&#x60;&#x60;&#x60; 
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="email">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="userId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="status">one or multiple statuses (comma list). Allowed values are &#x60;pending&#x60;, &#x60;invited&#x60;, &#x60;accepted&#x60; (optional)</param>
        /// <param name="clientApplicationId">Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of SubscriptionSeatsResponse</returns>
        public ApiResponse< SubscriptionSeatsResponse > GetSubscriptionSeatsWithHttpInfo (int? page = null, int? perPage = null, string include = null, string email = null, long? userId = null, string status = null, long? clientApplicationId = null, string orderBy = null)
        {

            var localVarPath = "/subscription/seats";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (email != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "email", email)); // query parameter
            if (userId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "user_id", userId)); // query parameter
            if (status != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status", status)); // query parameter
            if (clientApplicationId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "client_application_id", clientApplicationId)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSubscriptionSeats", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SubscriptionSeatsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SubscriptionSeatsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SubscriptionSeatsResponse)));
        }

        /// <summary>
        /// Get a range of subscription seats Returns a list of subscriptions seats.  Possible include values: &#x60;&#x60;&#x60;subscription, subscription.user&#x60;&#x60;&#x60; 
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="email">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="userId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="status">one or multiple statuses (comma list). Allowed values are &#x60;pending&#x60;, &#x60;invited&#x60;, &#x60;accepted&#x60; (optional)</param>
        /// <param name="clientApplicationId">Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of SubscriptionSeatsResponse</returns>
        public async System.Threading.Tasks.Task<SubscriptionSeatsResponse> GetSubscriptionSeatsAsync (int? page = null, int? perPage = null, string include = null, string email = null, long? userId = null, string status = null, long? clientApplicationId = null, string orderBy = null)
        {
             ApiResponse<SubscriptionSeatsResponse> localVarResponse = await GetSubscriptionSeatsAsyncWithHttpInfo(page, perPage, include, email, userId, status, clientApplicationId, orderBy);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get a range of subscription seats Returns a list of subscriptions seats.  Possible include values: &#x60;&#x60;&#x60;subscription, subscription.user&#x60;&#x60;&#x60; 
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="email">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="userId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="status">one or multiple statuses (comma list). Allowed values are &#x60;pending&#x60;, &#x60;invited&#x60;, &#x60;accepted&#x60; (optional)</param>
        /// <param name="clientApplicationId">Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (SubscriptionSeatsResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SubscriptionSeatsResponse>> GetSubscriptionSeatsAsyncWithHttpInfo (int? page = null, int? perPage = null, string include = null, string email = null, long? userId = null, string status = null, long? clientApplicationId = null, string orderBy = null)
        {

            var localVarPath = "/subscription/seats";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (email != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "email", email)); // query parameter
            if (userId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "user_id", userId)); // query parameter
            if (status != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status", status)); // query parameter
            if (clientApplicationId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "client_application_id", clientApplicationId)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSubscriptionSeats", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SubscriptionSeatsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SubscriptionSeatsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SubscriptionSeatsResponse)));
        }

        /// <summary>
        /// Get a range of subscriptions Returns a list of subscriptions.  Possible include values: &#x60;&#x60;&#x60;user, user.usage, specifications, specifications[key1,key2], customer&#x60;&#x60;&#x60; 
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="userId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="clientApplicationId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="externalReference">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="status">one or multiple statuses (comma list). Allowed values are &#x60;open&#x60;, &#x60;payment_required&#x60;, &#x60;confirmed&#x60;, &#x60;scheduled_update&#x60;, &#x60;non_renewing&#x60; and &#x60;cancelled&#x60; (optional)</param>
        /// <param name="notificationStatus">Filter by notification status - no wildcard support (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="startDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="endDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="scope">Filter accepts &#x60;RESELLER&#x60;, &#x60;USER&#x60; or &#x60;USABLE&#x60;.&#x60;RESELLER&#x60; can be used for reseller users to get subscriptions that they sold to other users. &#x60;USER&#x60; returns all subscriptions where the user is the owner, is a seat user or has can_read permissions to access the subscription, for a reseller the subscriptions returned from &#x60;RESELLER&#x60; filter are excluded from the &#x60;USER&#x60; result. The result of &#x60;USER&#x60; can include usable and not usable subscriptions. Subscription is marked as usable if it can be used in the applications to access data. &#x60;USABLE&#x60; filter retruns a subset of the &#x60;USER&#x60; result which excludes subscriptions that are only visible because of the can_read permission (not usable). (optional)</param>
        /// <param name="resellerLabel">Filter accepts &#x60;*&#x60; as wildcard. Filter acccepts \&quot;null\&quot; for all objects with no reseller label or \&quot;!null\&quot; for all with any reseller label (optional)</param>
        /// <param name="customerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>SubscriptionsResponse</returns>
        public SubscriptionsResponse GetSubscriptions (int? page = null, int? perPage = null, string include = null, long? userId = null, long? clientApplicationId = null, string externalReference = null, string status = null, string notificationStatus = null, string specificationsKey = null, string specificationsValue = null, DateTime? startDate = null, DateTime? endDate = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, string scope = null, string resellerLabel = null, string customerId = null, string orderBy = null)
        {
             ApiResponse<SubscriptionsResponse> localVarResponse = GetSubscriptionsWithHttpInfo(page, perPage, include, userId, clientApplicationId, externalReference, status, notificationStatus, specificationsKey, specificationsValue, startDate, endDate, createdAt, createdAtFrom, createdAtTo, updatedAt, updatedAtFrom, updatedAtTo, scope, resellerLabel, customerId, orderBy);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get a range of subscriptions Returns a list of subscriptions.  Possible include values: &#x60;&#x60;&#x60;user, user.usage, specifications, specifications[key1,key2], customer&#x60;&#x60;&#x60; 
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="userId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="clientApplicationId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="externalReference">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="status">one or multiple statuses (comma list). Allowed values are &#x60;open&#x60;, &#x60;payment_required&#x60;, &#x60;confirmed&#x60;, &#x60;scheduled_update&#x60;, &#x60;non_renewing&#x60; and &#x60;cancelled&#x60; (optional)</param>
        /// <param name="notificationStatus">Filter by notification status - no wildcard support (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="startDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="endDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="scope">Filter accepts &#x60;RESELLER&#x60;, &#x60;USER&#x60; or &#x60;USABLE&#x60;.&#x60;RESELLER&#x60; can be used for reseller users to get subscriptions that they sold to other users. &#x60;USER&#x60; returns all subscriptions where the user is the owner, is a seat user or has can_read permissions to access the subscription, for a reseller the subscriptions returned from &#x60;RESELLER&#x60; filter are excluded from the &#x60;USER&#x60; result. The result of &#x60;USER&#x60; can include usable and not usable subscriptions. Subscription is marked as usable if it can be used in the applications to access data. &#x60;USABLE&#x60; filter retruns a subset of the &#x60;USER&#x60; result which excludes subscriptions that are only visible because of the can_read permission (not usable). (optional)</param>
        /// <param name="resellerLabel">Filter accepts &#x60;*&#x60; as wildcard. Filter acccepts \&quot;null\&quot; for all objects with no reseller label or \&quot;!null\&quot; for all with any reseller label (optional)</param>
        /// <param name="customerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of SubscriptionsResponse</returns>
        public ApiResponse< SubscriptionsResponse > GetSubscriptionsWithHttpInfo (int? page = null, int? perPage = null, string include = null, long? userId = null, long? clientApplicationId = null, string externalReference = null, string status = null, string notificationStatus = null, string specificationsKey = null, string specificationsValue = null, DateTime? startDate = null, DateTime? endDate = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, string scope = null, string resellerLabel = null, string customerId = null, string orderBy = null)
        {

            var localVarPath = "/subscriptions";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (userId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "user_id", userId)); // query parameter
            if (clientApplicationId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "client_application_id", clientApplicationId)); // query parameter
            if (externalReference != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "external_reference", externalReference)); // query parameter
            if (status != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status", status)); // query parameter
            if (notificationStatus != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "notification_status", notificationStatus)); // query parameter
            if (specificationsKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_key", specificationsKey)); // query parameter
            if (specificationsValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_value", specificationsValue)); // query parameter
            if (startDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start_date", startDate)); // query parameter
            if (endDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "end_date", endDate)); // query parameter
            if (createdAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "created_at", createdAt)); // query parameter
            if (createdAtFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "created_at_from", createdAtFrom)); // query parameter
            if (createdAtTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "created_at_to", createdAtTo)); // query parameter
            if (updatedAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at", updatedAt)); // query parameter
            if (updatedAtFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_from", updatedAtFrom)); // query parameter
            if (updatedAtTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_to", updatedAtTo)); // query parameter
            if (scope != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "scope", scope)); // query parameter
            if (resellerLabel != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "reseller_label", resellerLabel)); // query parameter
            if (customerId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "customer_id", customerId)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSubscriptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SubscriptionsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SubscriptionsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SubscriptionsResponse)));
        }

        /// <summary>
        /// Get a range of subscriptions Returns a list of subscriptions.  Possible include values: &#x60;&#x60;&#x60;user, user.usage, specifications, specifications[key1,key2], customer&#x60;&#x60;&#x60; 
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="userId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="clientApplicationId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="externalReference">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="status">one or multiple statuses (comma list). Allowed values are &#x60;open&#x60;, &#x60;payment_required&#x60;, &#x60;confirmed&#x60;, &#x60;scheduled_update&#x60;, &#x60;non_renewing&#x60; and &#x60;cancelled&#x60; (optional)</param>
        /// <param name="notificationStatus">Filter by notification status - no wildcard support (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="startDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="endDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="scope">Filter accepts &#x60;RESELLER&#x60;, &#x60;USER&#x60; or &#x60;USABLE&#x60;.&#x60;RESELLER&#x60; can be used for reseller users to get subscriptions that they sold to other users. &#x60;USER&#x60; returns all subscriptions where the user is the owner, is a seat user or has can_read permissions to access the subscription, for a reseller the subscriptions returned from &#x60;RESELLER&#x60; filter are excluded from the &#x60;USER&#x60; result. The result of &#x60;USER&#x60; can include usable and not usable subscriptions. Subscription is marked as usable if it can be used in the applications to access data. &#x60;USABLE&#x60; filter retruns a subset of the &#x60;USER&#x60; result which excludes subscriptions that are only visible because of the can_read permission (not usable). (optional)</param>
        /// <param name="resellerLabel">Filter accepts &#x60;*&#x60; as wildcard. Filter acccepts \&quot;null\&quot; for all objects with no reseller label or \&quot;!null\&quot; for all with any reseller label (optional)</param>
        /// <param name="customerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of SubscriptionsResponse</returns>
        public async System.Threading.Tasks.Task<SubscriptionsResponse> GetSubscriptionsAsync (int? page = null, int? perPage = null, string include = null, long? userId = null, long? clientApplicationId = null, string externalReference = null, string status = null, string notificationStatus = null, string specificationsKey = null, string specificationsValue = null, DateTime? startDate = null, DateTime? endDate = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, string scope = null, string resellerLabel = null, string customerId = null, string orderBy = null)
        {
             ApiResponse<SubscriptionsResponse> localVarResponse = await GetSubscriptionsAsyncWithHttpInfo(page, perPage, include, userId, clientApplicationId, externalReference, status, notificationStatus, specificationsKey, specificationsValue, startDate, endDate, createdAt, createdAtFrom, createdAtTo, updatedAt, updatedAtFrom, updatedAtTo, scope, resellerLabel, customerId, orderBy);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get a range of subscriptions Returns a list of subscriptions.  Possible include values: &#x60;&#x60;&#x60;user, user.usage, specifications, specifications[key1,key2], customer&#x60;&#x60;&#x60; 
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="userId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="clientApplicationId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="externalReference">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="status">one or multiple statuses (comma list). Allowed values are &#x60;open&#x60;, &#x60;payment_required&#x60;, &#x60;confirmed&#x60;, &#x60;scheduled_update&#x60;, &#x60;non_renewing&#x60; and &#x60;cancelled&#x60; (optional)</param>
        /// <param name="notificationStatus">Filter by notification status - no wildcard support (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="startDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="endDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="scope">Filter accepts &#x60;RESELLER&#x60;, &#x60;USER&#x60; or &#x60;USABLE&#x60;.&#x60;RESELLER&#x60; can be used for reseller users to get subscriptions that they sold to other users. &#x60;USER&#x60; returns all subscriptions where the user is the owner, is a seat user or has can_read permissions to access the subscription, for a reseller the subscriptions returned from &#x60;RESELLER&#x60; filter are excluded from the &#x60;USER&#x60; result. The result of &#x60;USER&#x60; can include usable and not usable subscriptions. Subscription is marked as usable if it can be used in the applications to access data. &#x60;USABLE&#x60; filter retruns a subset of the &#x60;USER&#x60; result which excludes subscriptions that are only visible because of the can_read permission (not usable). (optional)</param>
        /// <param name="resellerLabel">Filter accepts &#x60;*&#x60; as wildcard. Filter acccepts \&quot;null\&quot; for all objects with no reseller label or \&quot;!null\&quot; for all with any reseller label (optional)</param>
        /// <param name="customerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (SubscriptionsResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SubscriptionsResponse>> GetSubscriptionsAsyncWithHttpInfo (int? page = null, int? perPage = null, string include = null, long? userId = null, long? clientApplicationId = null, string externalReference = null, string status = null, string notificationStatus = null, string specificationsKey = null, string specificationsValue = null, DateTime? startDate = null, DateTime? endDate = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, string scope = null, string resellerLabel = null, string customerId = null, string orderBy = null)
        {

            var localVarPath = "/subscriptions";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (userId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "user_id", userId)); // query parameter
            if (clientApplicationId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "client_application_id", clientApplicationId)); // query parameter
            if (externalReference != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "external_reference", externalReference)); // query parameter
            if (status != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status", status)); // query parameter
            if (notificationStatus != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "notification_status", notificationStatus)); // query parameter
            if (specificationsKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_key", specificationsKey)); // query parameter
            if (specificationsValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_value", specificationsValue)); // query parameter
            if (startDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start_date", startDate)); // query parameter
            if (endDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "end_date", endDate)); // query parameter
            if (createdAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "created_at", createdAt)); // query parameter
            if (createdAtFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "created_at_from", createdAtFrom)); // query parameter
            if (createdAtTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "created_at_to", createdAtTo)); // query parameter
            if (updatedAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at", updatedAt)); // query parameter
            if (updatedAtFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_from", updatedAtFrom)); // query parameter
            if (updatedAtTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_to", updatedAtTo)); // query parameter
            if (scope != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "scope", scope)); // query parameter
            if (resellerLabel != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "reseller_label", resellerLabel)); // query parameter
            if (customerId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "customer_id", customerId)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSubscriptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SubscriptionsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SubscriptionsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SubscriptionsResponse)));
        }

        /// <summary>
        /// Remove assets from a subscription Remove one or more assets from a subscription in your accessible scope.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="subscriptionId">Id of the subscription from which the assets will be removed</param>
        /// <returns></returns>
        public void RemoveAssetsFromSubscription (AssetIDs body, long? subscriptionId)
        {
             RemoveAssetsFromSubscriptionWithHttpInfo(body, subscriptionId);
        }

        /// <summary>
        /// Remove assets from a subscription Remove one or more assets from a subscription in your accessible scope.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="subscriptionId">Id of the subscription from which the assets will be removed</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RemoveAssetsFromSubscriptionWithHttpInfo (AssetIDs body, long? subscriptionId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SubscriptionApi->RemoveAssetsFromSubscription");
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionId' when calling SubscriptionApi->RemoveAssetsFromSubscription");

            var localVarPath = "/subscriptions/{subscription_id}/assets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionId != null) localVarPathParams.Add("subscription_id", this.Configuration.ApiClient.ParameterToString(subscriptionId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveAssetsFromSubscription", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Remove assets from a subscription Remove one or more assets from a subscription in your accessible scope.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="subscriptionId">Id of the subscription from which the assets will be removed</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveAssetsFromSubscriptionAsync (AssetIDs body, long? subscriptionId)
        {
             await RemoveAssetsFromSubscriptionAsyncWithHttpInfo(body, subscriptionId);

        }

        /// <summary>
        /// Remove assets from a subscription Remove one or more assets from a subscription in your accessible scope.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="subscriptionId">Id of the subscription from which the assets will be removed</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RemoveAssetsFromSubscriptionAsyncWithHttpInfo (AssetIDs body, long? subscriptionId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SubscriptionApi->RemoveAssetsFromSubscription");
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionId' when calling SubscriptionApi->RemoveAssetsFromSubscription");

            var localVarPath = "/subscriptions/{subscription_id}/assets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionId != null) localVarPathParams.Add("subscription_id", this.Configuration.ApiClient.ParameterToString(subscriptionId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveAssetsFromSubscription", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Remove users (existing users) or emails (new users) from a seat in subscription Remove one or more users or emails from a seat in subscription. **Either id or email pro entry should be provided (not both).** If an email is provided for existing user, then given user will be used. This operation does send notification emails to the seat user, so it should be used by the owner to remove seats.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="subscriptionId">Id of the subscription from which the user will be removed</param>
        /// <returns></returns>
        public void RemoveSeatUsersFromSubscription (UserIDorEmails body, long? subscriptionId)
        {
             RemoveSeatUsersFromSubscriptionWithHttpInfo(body, subscriptionId);
        }

        /// <summary>
        /// Remove users (existing users) or emails (new users) from a seat in subscription Remove one or more users or emails from a seat in subscription. **Either id or email pro entry should be provided (not both).** If an email is provided for existing user, then given user will be used. This operation does send notification emails to the seat user, so it should be used by the owner to remove seats.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="subscriptionId">Id of the subscription from which the user will be removed</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RemoveSeatUsersFromSubscriptionWithHttpInfo (UserIDorEmails body, long? subscriptionId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SubscriptionApi->RemoveSeatUsersFromSubscription");
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionId' when calling SubscriptionApi->RemoveSeatUsersFromSubscription");

            var localVarPath = "/subscriptions/{subscription_id}/seats";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionId != null) localVarPathParams.Add("subscription_id", this.Configuration.ApiClient.ParameterToString(subscriptionId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveSeatUsersFromSubscription", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Remove users (existing users) or emails (new users) from a seat in subscription Remove one or more users or emails from a seat in subscription. **Either id or email pro entry should be provided (not both).** If an email is provided for existing user, then given user will be used. This operation does send notification emails to the seat user, so it should be used by the owner to remove seats.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="subscriptionId">Id of the subscription from which the user will be removed</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveSeatUsersFromSubscriptionAsync (UserIDorEmails body, long? subscriptionId)
        {
             await RemoveSeatUsersFromSubscriptionAsyncWithHttpInfo(body, subscriptionId);

        }

        /// <summary>
        /// Remove users (existing users) or emails (new users) from a seat in subscription Remove one or more users or emails from a seat in subscription. **Either id or email pro entry should be provided (not both).** If an email is provided for existing user, then given user will be used. This operation does send notification emails to the seat user, so it should be used by the owner to remove seats.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="subscriptionId">Id of the subscription from which the user will be removed</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RemoveSeatUsersFromSubscriptionAsyncWithHttpInfo (UserIDorEmails body, long? subscriptionId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SubscriptionApi->RemoveSeatUsersFromSubscription");
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionId' when calling SubscriptionApi->RemoveSeatUsersFromSubscription");

            var localVarPath = "/subscriptions/{subscription_id}/seats";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionId != null) localVarPathParams.Add("subscription_id", this.Configuration.ApiClient.ParameterToString(subscriptionId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveSeatUsersFromSubscription", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete specifications of a subscription The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns></returns>
        public void RemoveSpecificationsFromSubscriptions (List<string> body, long? subscriptionId)
        {
             RemoveSpecificationsFromSubscriptionsWithHttpInfo(body, subscriptionId);
        }

        /// <summary>
        /// Delete specifications of a subscription The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RemoveSpecificationsFromSubscriptionsWithHttpInfo (List<string> body, long? subscriptionId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SubscriptionApi->RemoveSpecificationsFromSubscriptions");
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionId' when calling SubscriptionApi->RemoveSpecificationsFromSubscriptions");

            var localVarPath = "/subscriptions/{subscription_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionId != null) localVarPathParams.Add("subscription_id", this.Configuration.ApiClient.ParameterToString(subscriptionId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveSpecificationsFromSubscriptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete specifications of a subscription The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveSpecificationsFromSubscriptionsAsync (List<string> body, long? subscriptionId)
        {
             await RemoveSpecificationsFromSubscriptionsAsyncWithHttpInfo(body, subscriptionId);

        }

        /// <summary>
        /// Delete specifications of a subscription The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RemoveSpecificationsFromSubscriptionsAsyncWithHttpInfo (List<string> body, long? subscriptionId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SubscriptionApi->RemoveSpecificationsFromSubscriptions");
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionId' when calling SubscriptionApi->RemoveSpecificationsFromSubscriptions");

            var localVarPath = "/subscriptions/{subscription_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionId != null) localVarPathParams.Add("subscription_id", this.Configuration.ApiClient.ParameterToString(subscriptionId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveSpecificationsFromSubscriptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of a subscription in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns></returns>
        public void RenameSpecificationsOfSubscriptions (SpecificationsRename body, long? subscriptionId)
        {
             RenameSpecificationsOfSubscriptionsWithHttpInfo(body, subscriptionId);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of a subscription in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RenameSpecificationsOfSubscriptionsWithHttpInfo (SpecificationsRename body, long? subscriptionId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SubscriptionApi->RenameSpecificationsOfSubscriptions");
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionId' when calling SubscriptionApi->RenameSpecificationsOfSubscriptions");

            var localVarPath = "/subscriptions/{subscription_id}/specifications/rename";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionId != null) localVarPathParams.Add("subscription_id", this.Configuration.ApiClient.ParameterToString(subscriptionId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RenameSpecificationsOfSubscriptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of a subscription in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RenameSpecificationsOfSubscriptionsAsync (SpecificationsRename body, long? subscriptionId)
        {
             await RenameSpecificationsOfSubscriptionsAsyncWithHttpInfo(body, subscriptionId);

        }

        /// <summary>
        /// Rename a specification key Rename one specification key of a subscription in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RenameSpecificationsOfSubscriptionsAsyncWithHttpInfo (SpecificationsRename body, long? subscriptionId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SubscriptionApi->RenameSpecificationsOfSubscriptions");
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionId' when calling SubscriptionApi->RenameSpecificationsOfSubscriptions");

            var localVarPath = "/subscriptions/{subscription_id}/specifications/rename";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionId != null) localVarPathParams.Add("subscription_id", this.Configuration.ApiClient.ParameterToString(subscriptionId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RenameSpecificationsOfSubscriptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Replace the assets of a subscription Replaces all assets belonging to a subscription in your accessible scope. You can send a list of resources that will replace all previous values.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="subscriptionId">Id of the subscription of which the assets will be replaced</param>
        /// <returns></returns>
        public void ReplaceAssetsOfSubscription (AssetIDs body, long? subscriptionId)
        {
             ReplaceAssetsOfSubscriptionWithHttpInfo(body, subscriptionId);
        }

        /// <summary>
        /// Replace the assets of a subscription Replaces all assets belonging to a subscription in your accessible scope. You can send a list of resources that will replace all previous values.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="subscriptionId">Id of the subscription of which the assets will be replaced</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReplaceAssetsOfSubscriptionWithHttpInfo (AssetIDs body, long? subscriptionId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SubscriptionApi->ReplaceAssetsOfSubscription");
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionId' when calling SubscriptionApi->ReplaceAssetsOfSubscription");

            var localVarPath = "/subscriptions/{subscription_id}/assets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionId != null) localVarPathParams.Add("subscription_id", this.Configuration.ApiClient.ParameterToString(subscriptionId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceAssetsOfSubscription", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Replace the assets of a subscription Replaces all assets belonging to a subscription in your accessible scope. You can send a list of resources that will replace all previous values.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="subscriptionId">Id of the subscription of which the assets will be replaced</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task ReplaceAssetsOfSubscriptionAsync (AssetIDs body, long? subscriptionId)
        {
             await ReplaceAssetsOfSubscriptionAsyncWithHttpInfo(body, subscriptionId);

        }

        /// <summary>
        /// Replace the assets of a subscription Replaces all assets belonging to a subscription in your accessible scope. You can send a list of resources that will replace all previous values.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="subscriptionId">Id of the subscription of which the assets will be replaced</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> ReplaceAssetsOfSubscriptionAsyncWithHttpInfo (AssetIDs body, long? subscriptionId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SubscriptionApi->ReplaceAssetsOfSubscription");
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionId' when calling SubscriptionApi->ReplaceAssetsOfSubscription");

            var localVarPath = "/subscriptions/{subscription_id}/assets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionId != null) localVarPathParams.Add("subscription_id", this.Configuration.ApiClient.ParameterToString(subscriptionId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceAssetsOfSubscription", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Unassign assets to a subscription based on a filter Unassign one or more assets to a subscription based on a filter. Body may contain an object id and type which then will return all assets assigned to that object directly or indirectly (through other objects). Body may contain an index search query to search assets based on a set of fields (like in the /search endpoint), only assets matching that search will be returned. Body may combine these conditions or even may contain none of them (in the latter case all readable assets is used). The assets returned from the filter are then unassigned to the subscription. An error is raised if the filter given, does not contain any asset. If an asset is already unassigned, it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="subscriptionId">Id of the subscription to which the assets will be added</param>
        /// <returns></returns>
        public void UnassignAssetSetToSubscription (SubscriptionAssetAssignmentRequest body, long? subscriptionId)
        {
             UnassignAssetSetToSubscriptionWithHttpInfo(body, subscriptionId);
        }

        /// <summary>
        /// Unassign assets to a subscription based on a filter Unassign one or more assets to a subscription based on a filter. Body may contain an object id and type which then will return all assets assigned to that object directly or indirectly (through other objects). Body may contain an index search query to search assets based on a set of fields (like in the /search endpoint), only assets matching that search will be returned. Body may combine these conditions or even may contain none of them (in the latter case all readable assets is used). The assets returned from the filter are then unassigned to the subscription. An error is raised if the filter given, does not contain any asset. If an asset is already unassigned, it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="subscriptionId">Id of the subscription to which the assets will be added</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UnassignAssetSetToSubscriptionWithHttpInfo (SubscriptionAssetAssignmentRequest body, long? subscriptionId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SubscriptionApi->UnassignAssetSetToSubscription");
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionId' when calling SubscriptionApi->UnassignAssetSetToSubscription");

            var localVarPath = "/subscriptions/{subscription_id}/asset_assignment";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionId != null) localVarPathParams.Add("subscription_id", this.Configuration.ApiClient.ParameterToString(subscriptionId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UnassignAssetSetToSubscription", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Unassign assets to a subscription based on a filter Unassign one or more assets to a subscription based on a filter. Body may contain an object id and type which then will return all assets assigned to that object directly or indirectly (through other objects). Body may contain an index search query to search assets based on a set of fields (like in the /search endpoint), only assets matching that search will be returned. Body may combine these conditions or even may contain none of them (in the latter case all readable assets is used). The assets returned from the filter are then unassigned to the subscription. An error is raised if the filter given, does not contain any asset. If an asset is already unassigned, it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="subscriptionId">Id of the subscription to which the assets will be added</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UnassignAssetSetToSubscriptionAsync (SubscriptionAssetAssignmentRequest body, long? subscriptionId)
        {
             await UnassignAssetSetToSubscriptionAsyncWithHttpInfo(body, subscriptionId);

        }

        /// <summary>
        /// Unassign assets to a subscription based on a filter Unassign one or more assets to a subscription based on a filter. Body may contain an object id and type which then will return all assets assigned to that object directly or indirectly (through other objects). Body may contain an index search query to search assets based on a set of fields (like in the /search endpoint), only assets matching that search will be returned. Body may combine these conditions or even may contain none of them (in the latter case all readable assets is used). The assets returned from the filter are then unassigned to the subscription. An error is raised if the filter given, does not contain any asset. If an asset is already unassigned, it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="subscriptionId">Id of the subscription to which the assets will be added</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> UnassignAssetSetToSubscriptionAsyncWithHttpInfo (SubscriptionAssetAssignmentRequest body, long? subscriptionId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SubscriptionApi->UnassignAssetSetToSubscription");
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionId' when calling SubscriptionApi->UnassignAssetSetToSubscription");

            var localVarPath = "/subscriptions/{subscription_id}/asset_assignment";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionId != null) localVarPathParams.Add("subscription_id", this.Configuration.ApiClient.ParameterToString(subscriptionId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UnassignAssetSetToSubscription", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update specifications of a subscription Update the specification object of a subscription in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns></returns>
        public void UpdateSpecificationsOfSubscriptions (Dictionary<string, SpecificationRequest> body, long? subscriptionId)
        {
             UpdateSpecificationsOfSubscriptionsWithHttpInfo(body, subscriptionId);
        }

        /// <summary>
        /// Update specifications of a subscription Update the specification object of a subscription in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateSpecificationsOfSubscriptionsWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? subscriptionId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SubscriptionApi->UpdateSpecificationsOfSubscriptions");
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionId' when calling SubscriptionApi->UpdateSpecificationsOfSubscriptions");

            var localVarPath = "/subscriptions/{subscription_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionId != null) localVarPathParams.Add("subscription_id", this.Configuration.ApiClient.ParameterToString(subscriptionId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSpecificationsOfSubscriptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update specifications of a subscription Update the specification object of a subscription in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UpdateSpecificationsOfSubscriptionsAsync (Dictionary<string, SpecificationRequest> body, long? subscriptionId)
        {
             await UpdateSpecificationsOfSubscriptionsAsyncWithHttpInfo(body, subscriptionId);

        }

        /// <summary>
        /// Update specifications of a subscription Update the specification object of a subscription in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="subscriptionId">Id of the specified subscription</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSpecificationsOfSubscriptionsAsyncWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? subscriptionId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SubscriptionApi->UpdateSpecificationsOfSubscriptions");
            // verify the required parameter 'subscriptionId' is set
            if (subscriptionId == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionId' when calling SubscriptionApi->UpdateSpecificationsOfSubscriptions");

            var localVarPath = "/subscriptions/{subscription_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionId != null) localVarPathParams.Add("subscription_id", this.Configuration.ApiClient.ParameterToString(subscriptionId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSpecificationsOfSubscriptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update a subscription Update accessible parameters of the requested resource. Setting a successor or predecessor is possible. The client_application and user of the given Subscription and the reference Subscription have to match to do so. The successor/predecessor of a subscription cant be itself
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the subscription to update</param>
        /// <returns></returns>
        public void UpdateSubscription (SubscriptionRequest body, long? id)
        {
             UpdateSubscriptionWithHttpInfo(body, id);
        }

        /// <summary>
        /// Update a subscription Update accessible parameters of the requested resource. Setting a successor or predecessor is possible. The client_application and user of the given Subscription and the reference Subscription have to match to do so. The successor/predecessor of a subscription cant be itself
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the subscription to update</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateSubscriptionWithHttpInfo (SubscriptionRequest body, long? id)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SubscriptionApi->UpdateSubscription");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling SubscriptionApi->UpdateSubscription");

            var localVarPath = "/subscriptions/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSubscription", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update a subscription Update accessible parameters of the requested resource. Setting a successor or predecessor is possible. The client_application and user of the given Subscription and the reference Subscription have to match to do so. The successor/predecessor of a subscription cant be itself
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the subscription to update</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UpdateSubscriptionAsync (SubscriptionRequest body, long? id)
        {
             await UpdateSubscriptionAsyncWithHttpInfo(body, id);

        }

        /// <summary>
        /// Update a subscription Update accessible parameters of the requested resource. Setting a successor or predecessor is possible. The client_application and user of the given Subscription and the reference Subscription have to match to do so. The successor/predecessor of a subscription cant be itself
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the subscription to update</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSubscriptionAsyncWithHttpInfo (SubscriptionRequest body, long? id)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SubscriptionApi->UpdateSubscription");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling SubscriptionApi->UpdateSubscription");

            var localVarPath = "/subscriptions/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSubscription", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update a subscription seat Update the status of a subscription seat
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the subscription seat to update</param>
        /// <returns></returns>
        public void UpdateSubscriptionSeat (SubscriptionSeatPatch body, long? id)
        {
             UpdateSubscriptionSeatWithHttpInfo(body, id);
        }

        /// <summary>
        /// Update a subscription seat Update the status of a subscription seat
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the subscription seat to update</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateSubscriptionSeatWithHttpInfo (SubscriptionSeatPatch body, long? id)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SubscriptionApi->UpdateSubscriptionSeat");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling SubscriptionApi->UpdateSubscriptionSeat");

            var localVarPath = "/subscription/seats/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSubscriptionSeat", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update a subscription seat Update the status of a subscription seat
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the subscription seat to update</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UpdateSubscriptionSeatAsync (SubscriptionSeatPatch body, long? id)
        {
             await UpdateSubscriptionSeatAsyncWithHttpInfo(body, id);

        }

        /// <summary>
        /// Update a subscription seat Update the status of a subscription seat
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the subscription seat to update</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSubscriptionSeatAsyncWithHttpInfo (SubscriptionSeatPatch body, long? id)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SubscriptionApi->UpdateSubscriptionSeat");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling SubscriptionApi->UpdateSubscriptionSeat");

            var localVarPath = "/subscription/seats/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSubscriptionSeat", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

    }
}
