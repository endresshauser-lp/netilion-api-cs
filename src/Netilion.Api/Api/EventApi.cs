/* 
 * Netilion API Documentation
 *
 * Welcome to the Netilion API Documentation, which provides interactive access and documentation to our REST API. Please visit our developer portal for further instructions and information: https://developer.netilion.endress.com/ 
 *
 * OpenAPI spec version: 01.00.00
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using Netilion.Api.Client;
using Netilion.Api.Model;

namespace Netilion.Api.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
        public interface IEventApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Add documents to an event
        /// </summary>
        /// <remarks>
        /// Add one or more documents to an event.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="eventId">Id of the asset to which the documents will be added</param>
        /// <returns></returns>
        void AddDocumentsToEvent (DocumentIDs body, long? eventId);

        /// <summary>
        /// Add documents to an event
        /// </summary>
        /// <remarks>
        /// Add one or more documents to an event.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="eventId">Id of the asset to which the documents will be added</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> AddDocumentsToEventWithHttpInfo (DocumentIDs body, long? eventId);
        /// <summary>
        /// Create a new event
        /// </summary>
        /// <remarks>
        /// Event must have a name, status, type and at least one asset or an instrumentation
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Event object that needs to be created.</param>
        /// <returns>EventResponse</returns>
        EventResponse CreateEvent (EventRequest body);

        /// <summary>
        /// Create a new event
        /// </summary>
        /// <remarks>
        /// Event must have a name, status, type and at least one asset or an instrumentation
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Event object that needs to be created.</param>
        /// <returns>ApiResponse of EventResponse</returns>
        ApiResponse<EventResponse> CreateEventWithHttpInfo (EventRequest body);
        /// <summary>
        /// Create a new event for an asset
        /// </summary>
        /// <remarks>
        /// Events must have a name, and can have a start_datetime (if not provided, the date of creation will be used as default value), end_datetime, event_type, event_status, description and responsible
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object to be created.</param>
        /// <param name="assetId">Id of the asset</param>
        /// <returns>EventResponse</returns>
        EventResponse CreateEventForAsset (EventRequestNoAssets body, long? assetId);

        /// <summary>
        /// Create a new event for an asset
        /// </summary>
        /// <remarks>
        /// Events must have a name, and can have a start_datetime (if not provided, the date of creation will be used as default value), end_datetime, event_type, event_status, description and responsible
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object to be created.</param>
        /// <param name="assetId">Id of the asset</param>
        /// <returns>ApiResponse of EventResponse</returns>
        ApiResponse<EventResponse> CreateEventForAssetWithHttpInfo (EventRequestNoAssets body, long? assetId);
        /// <summary>
        /// Create a new event for an instrumentation
        /// </summary>
        /// <remarks>
        /// Events must have a name, and can have a start_datetime (if not provided, the date of creation will be used as default value), end_datetime, event_type, event_status, description and responsible
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object to be created.</param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <returns>EventResponse</returns>
        EventResponse CreateEventForInstrumentation (EventRequestNoInstrumentations body, long? instrumentationId);

        /// <summary>
        /// Create a new event for an instrumentation
        /// </summary>
        /// <remarks>
        /// Events must have a name, and can have a start_datetime (if not provided, the date of creation will be used as default value), end_datetime, event_type, event_status, description and responsible
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object to be created.</param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <returns>ApiResponse of EventResponse</returns>
        ApiResponse<EventResponse> CreateEventForInstrumentationWithHttpInfo (EventRequestNoInstrumentations body, long? instrumentationId);
        /// <summary>
        /// Delete an event
        /// </summary>
        /// <remarks>
        /// Delete a specific resource identified by the id in the URL.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the event to delete</param>
        /// <returns></returns>
        void DeleteEvent (long? id);

        /// <summary>
        /// Delete an event
        /// </summary>
        /// <remarks>
        /// Delete a specific resource identified by the id in the URL.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the event to delete</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteEventWithHttpInfo (long? id);
        /// <summary>
        /// Get all assets of one event
        /// </summary>
        /// <remarks>
        /// Returns a list of all assets of an event that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;status, tenant, parent, pictures, product, product.manufacturer, product.pictures, product.status, product.categories, product.categories.parent, specifications, specifications[key1,key2], product.tenant,                             product.manufacturer.tenant, status.tenant, instrumentations &#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="serialNumber">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productCategoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="manufacturerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusCode">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productionDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="ownershipClaimed">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;serial_number&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, &#x60;last_seen_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>AssetsResponse</returns>
        AssetsResponse GetAssetsOfEvent (long? eventId, int? page = null, int? perPage = null, string include = null, string serialNumber = null, string productId = null, string productCategoryId = null, string parentId = null, string manufacturerId = null, string statusId = null, string statusCode = null, DateTime? productionDate = null, DateTime? productionDateFrom = null, DateTime? productionDateTo = null, string specificationsKey = null, string specificationsValue = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, bool? ownershipClaimed = null, string permission = null, string orderBy = null);

        /// <summary>
        /// Get all assets of one event
        /// </summary>
        /// <remarks>
        /// Returns a list of all assets of an event that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;status, tenant, parent, pictures, product, product.manufacturer, product.pictures, product.status, product.categories, product.categories.parent, specifications, specifications[key1,key2], product.tenant,                             product.manufacturer.tenant, status.tenant, instrumentations &#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="serialNumber">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productCategoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="manufacturerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusCode">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productionDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="ownershipClaimed">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;serial_number&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, &#x60;last_seen_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of AssetsResponse</returns>
        ApiResponse<AssetsResponse> GetAssetsOfEventWithHttpInfo (long? eventId, int? page = null, int? perPage = null, string include = null, string serialNumber = null, string productId = null, string productCategoryId = null, string parentId = null, string manufacturerId = null, string statusId = null, string statusCode = null, DateTime? productionDate = null, DateTime? productionDateFrom = null, DateTime? productionDateTo = null, string specificationsKey = null, string specificationsValue = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, bool? ownershipClaimed = null, string permission = null, string orderBy = null);
        /// <summary>
        /// Get all documents of an event
        /// </summary>
        /// <remarks>
        /// Returns a list of documents. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;status, tenant, classification, categories, categories.parent, categories.standards, attachments&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="classificationId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="documentVersion">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="number">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="categoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="validFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validUntil">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validAt">Expected date format is YYYY-MM-DD or YYYY-MM or YYYY (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>DocumentsResponse</returns>
        DocumentsResponse GetDocumentsOfEvent (long? eventId, int? page = null, int? perPage = null, string include = null, string name = null, string statusId = null, string classificationId = null, string documentVersion = null, string number = null, string tenantId = null, string categoryId = null, DateTime? validFrom = null, DateTime? validUntil = null, DateTime? validAt = null, string orderBy = null, string acceptLanguage = null);

        /// <summary>
        /// Get all documents of an event
        /// </summary>
        /// <remarks>
        /// Returns a list of documents. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;status, tenant, classification, categories, categories.parent, categories.standards, attachments&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="classificationId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="documentVersion">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="number">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="categoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="validFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validUntil">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validAt">Expected date format is YYYY-MM-DD or YYYY-MM or YYYY (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>ApiResponse of DocumentsResponse</returns>
        ApiResponse<DocumentsResponse> GetDocumentsOfEventWithHttpInfo (long? eventId, int? page = null, int? perPage = null, string include = null, string name = null, string statusId = null, string classificationId = null, string documentVersion = null, string number = null, string tenantId = null, string categoryId = null, DateTime? validFrom = null, DateTime? validUntil = null, DateTime? validAt = null, string orderBy = null, string acceptLanguage = null);
        /// <summary>
        /// Get a single event
        /// </summary>
        /// <remarks>
        /// Get a specific event identified by the id in the URL.  Possible include values: &#x60;&#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the event to fetch</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <returns>EventResponse</returns>
        EventResponse GetEventById (long? id, string include = null);

        /// <summary>
        /// Get a single event
        /// </summary>
        /// <remarks>
        /// Get a specific event identified by the id in the URL.  Possible include values: &#x60;&#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the event to fetch</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <returns>ApiResponse of EventResponse</returns>
        ApiResponse<EventResponse> GetEventByIdWithHttpInfo (long? id, string include = null);
        /// <summary>
        /// Get the status of a specific event
        /// </summary>
        /// <remarks>
        /// Returns the status of the event. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>EventStatusResponse</returns>
        EventStatusResponse GetEventIdStatus (long? eventId, string acceptLanguage = null);

        /// <summary>
        /// Get the status of a specific event
        /// </summary>
        /// <remarks>
        /// Returns the status of the event. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>ApiResponse of EventStatusResponse</returns>
        ApiResponse<EventStatusResponse> GetEventIdStatusWithHttpInfo (long? eventId, string acceptLanguage = null);
        /// <summary>
        /// Get the type of a specific event
        /// </summary>
        /// <remarks>
        /// Returns the type of the event. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>EventTypeResponse</returns>
        EventTypeResponse GetEventIdType (long? eventId, string acceptLanguage = null);

        /// <summary>
        /// Get the type of a specific event
        /// </summary>
        /// <remarks>
        /// Returns the type of the event. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>ApiResponse of EventTypeResponse</returns>
        ApiResponse<EventTypeResponse> GetEventIdTypeWithHttpInfo (long? eventId, string acceptLanguage = null);
        /// <summary>
        /// Get all possible statuses for the specified event
        /// </summary>
        /// <remarks>
        /// Returns a list of all possible event statuses for the specified event. You can apply the query parameters listed below to get a filtered list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>EventStatuses</returns>
        EventStatuses GetEventStatusesOptions (long? eventId, int? page = null, int? perPage = null, string name = null, string code = null, string tenantId = null, string orderBy = null, string acceptLanguage = null);

        /// <summary>
        /// Get all possible statuses for the specified event
        /// </summary>
        /// <remarks>
        /// Returns a list of all possible event statuses for the specified event. You can apply the query parameters listed below to get a filtered list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>ApiResponse of EventStatuses</returns>
        ApiResponse<EventStatuses> GetEventStatusesOptionsWithHttpInfo (long? eventId, int? page = null, int? perPage = null, string name = null, string code = null, string tenantId = null, string orderBy = null, string acceptLanguage = null);
        /// <summary>
        /// Get all possible types for the specified event
        /// </summary>
        /// <remarks>
        /// Returns a list of all possible event types for the specified event. You can apply the query parameters listed below to get a filtered list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>EventTypes</returns>
        EventTypes GetEventTypeesOptions (long? eventId, int? page = null, int? perPage = null, string name = null, string code = null, string tenantId = null, string orderBy = null, string acceptLanguage = null);

        /// <summary>
        /// Get all possible types for the specified event
        /// </summary>
        /// <remarks>
        /// Returns a list of all possible event types for the specified event. You can apply the query parameters listed below to get a filtered list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>ApiResponse of EventTypes</returns>
        ApiResponse<EventTypes> GetEventTypeesOptionsWithHttpInfo (long? eventId, int? page = null, int? perPage = null, string name = null, string code = null, string tenantId = null, string orderBy = null, string acceptLanguage = null);
        /// <summary>
        /// Get a range of events
        /// </summary>
        /// <remarks>
        /// Returns a list of events. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="startDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;start_datetime&#x60;, &#x60;end_datetime&#x60;, &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>EventsResponse</returns>
        EventsResponse GetEvents (int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string statusId = null, string startDatetime = null, string startDatetimeFrom = null, string startDatetimeTo = null, string endDatetime = null, DateTime? endDatetimeFrom = null, string endDatetimeTo = null, string tenantId = null, string orderBy = null);

        /// <summary>
        /// Get a range of events
        /// </summary>
        /// <remarks>
        /// Returns a list of events. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="startDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;start_datetime&#x60;, &#x60;end_datetime&#x60;, &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of EventsResponse</returns>
        ApiResponse<EventsResponse> GetEventsWithHttpInfo (int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string statusId = null, string startDatetime = null, string startDatetimeFrom = null, string startDatetimeTo = null, string endDatetime = null, DateTime? endDatetimeFrom = null, string endDatetimeTo = null, string tenantId = null, string orderBy = null);
        /// <summary>
        /// Get all events of one asset
        /// </summary>
        /// <remarks>
        /// Returns a list of all events belonging to an asset in your accessible scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="startDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;start_datetime&#x60;, &#x60;end_datetime&#x60;, &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>EventsResponse</returns>
        EventsResponse GetEventsOfAsset (long? assetId, int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string statusId = null, string startDatetime = null, string startDatetimeFrom = null, string startDatetimeTo = null, string endDatetime = null, DateTime? endDatetimeFrom = null, string endDatetimeTo = null, string tenantId = null, string orderBy = null);

        /// <summary>
        /// Get all events of one asset
        /// </summary>
        /// <remarks>
        /// Returns a list of all events belonging to an asset in your accessible scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="startDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;start_datetime&#x60;, &#x60;end_datetime&#x60;, &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of EventsResponse</returns>
        ApiResponse<EventsResponse> GetEventsOfAssetWithHttpInfo (long? assetId, int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string statusId = null, string startDatetime = null, string startDatetimeFrom = null, string startDatetimeTo = null, string endDatetime = null, DateTime? endDatetimeFrom = null, string endDatetimeTo = null, string tenantId = null, string orderBy = null);
        /// <summary>
        /// Get all events of one instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of all events belonging to an instrumentation in your accessible scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="startDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;start_datetime&#x60;, &#x60;end_datetime&#x60;, &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>EventsResponse</returns>
        EventsResponse GetEventsOfInstrumentation (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string statusId = null, string startDatetime = null, string startDatetimeFrom = null, string startDatetimeTo = null, string endDatetime = null, DateTime? endDatetimeFrom = null, string endDatetimeTo = null, string tenantId = null, string orderBy = null);

        /// <summary>
        /// Get all events of one instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of all events belonging to an instrumentation in your accessible scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="startDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;start_datetime&#x60;, &#x60;end_datetime&#x60;, &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of EventsResponse</returns>
        ApiResponse<EventsResponse> GetEventsOfInstrumentationWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string statusId = null, string startDatetime = null, string startDatetimeFrom = null, string startDatetimeTo = null, string endDatetime = null, DateTime? endDatetimeFrom = null, string endDatetimeTo = null, string tenantId = null, string orderBy = null);
        /// <summary>
        /// Get all instrumentations of one event
        /// </summary>
        /// <remarks>
        /// Returns a list of all instrumentations of an event that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;specifications, specifications[key1,key2], pictures, tenant, parent, status, type, type.tenant, type.parent&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="tag">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="criticality">Filter accepts undefined, low, medium or high (optional)</param>
        /// <param name="accessibility">Filter accepts undefined, easy, moderate or difficult (optional)</param>
        /// <param name="nodeId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all objects with no nodes assigned or \&quot;!null\&quot; for any assigned node (optional)</param>
        /// <param name="assetStatusId">One or multiple ids (comma list). Expected id format is integer. This retrieves all Instrumentations where at least one of its assets has one of the given statuses. (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;tag&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>InstrumentationsResponse</returns>
        InstrumentationsResponse GetInstrumentationsOfEvent (long? eventId, int? page = null, int? perPage = null, string include = null, string tag = null, string statusId = null, string typeId = null, string parentId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string criticality = null, string accessibility = null, string nodeId = null, string assetStatusId = null, string permission = null, string orderBy = null);

        /// <summary>
        /// Get all instrumentations of one event
        /// </summary>
        /// <remarks>
        /// Returns a list of all instrumentations of an event that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;specifications, specifications[key1,key2], pictures, tenant, parent, status, type, type.tenant, type.parent&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="tag">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="criticality">Filter accepts undefined, low, medium or high (optional)</param>
        /// <param name="accessibility">Filter accepts undefined, easy, moderate or difficult (optional)</param>
        /// <param name="nodeId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all objects with no nodes assigned or \&quot;!null\&quot; for any assigned node (optional)</param>
        /// <param name="assetStatusId">One or multiple ids (comma list). Expected id format is integer. This retrieves all Instrumentations where at least one of its assets has one of the given statuses. (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;tag&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of InstrumentationsResponse</returns>
        ApiResponse<InstrumentationsResponse> GetInstrumentationsOfEventWithHttpInfo (long? eventId, int? page = null, int? perPage = null, string include = null, string tag = null, string statusId = null, string typeId = null, string parentId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string criticality = null, string accessibility = null, string nodeId = null, string assetStatusId = null, string permission = null, string orderBy = null);
        /// <summary>
        /// Get specifications of an event
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>SpecificationsResponse</returns>
        SpecificationsResponse GetSpecificationsOfEvent (long? eventId, string key = null);

        /// <summary>
        /// Get specifications of an event
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>ApiResponse of SpecificationsResponse</returns>
        ApiResponse<SpecificationsResponse> GetSpecificationsOfEventWithHttpInfo (long? eventId, string key = null);
        /// <summary>
        /// Remove assets from an event
        /// </summary>
        /// <remarks>
        /// Remove one or more assets from an event. If the event has no more related assets or instrumentations, the event will be deleted
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="eventId">Id of the event where the asset will be removed</param>
        /// <returns></returns>
        void RemoveAssetsFromEvent (AssetIDs body, long? eventId);

        /// <summary>
        /// Remove assets from an event
        /// </summary>
        /// <remarks>
        /// Remove one or more assets from an event. If the event has no more related assets or instrumentations, the event will be deleted
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="eventId">Id of the event where the asset will be removed</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveAssetsFromEventWithHttpInfo (AssetIDs body, long? eventId);
        /// <summary>
        /// Remove documents from an event
        /// </summary>
        /// <remarks>
        /// Remove one or more documents from an event.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="eventId">Id of the event from which the documents will be removed</param>
        /// <returns></returns>
        void RemoveDocumentsFromEvent (DocumentIDs body, long? eventId);

        /// <summary>
        /// Remove documents from an event
        /// </summary>
        /// <remarks>
        /// Remove one or more documents from an event.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="eventId">Id of the event from which the documents will be removed</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveDocumentsFromEventWithHttpInfo (DocumentIDs body, long? eventId);
        /// <summary>
        /// Remove events from an asset
        /// </summary>
        /// <remarks>
        /// Remove one or more events from an asset in your accessible scope. If the event has no more related assets, the event will be deleted
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="assetId">Id of the asset from which the events will removed.</param>
        /// <returns></returns>
        void RemoveEventFromAsset (Events body, long? assetId);

        /// <summary>
        /// Remove events from an asset
        /// </summary>
        /// <remarks>
        /// Remove one or more events from an asset in your accessible scope. If the event has no more related assets, the event will be deleted
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="assetId">Id of the asset from which the events will removed.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveEventFromAssetWithHttpInfo (Events body, long? assetId);
        /// <summary>
        /// Remove events from an instrumentation
        /// </summary>
        /// <remarks>
        /// Remove one or more events from an instrumentation in your accessible scope. If the event has no more related instrumentations, the event will be deleted
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the events will removed.</param>
        /// <returns></returns>
        void RemoveEventFromInstrumentation (Events1 body, long? instrumentationId);

        /// <summary>
        /// Remove events from an instrumentation
        /// </summary>
        /// <remarks>
        /// Remove one or more events from an instrumentation in your accessible scope. If the event has no more related instrumentations, the event will be deleted
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the events will removed.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveEventFromInstrumentationWithHttpInfo (Events1 body, long? instrumentationId);
        /// <summary>
        /// Remove instrumentations from an event
        /// </summary>
        /// <remarks>
        /// Remove one or more instrumentations from an event. If the event has no more related instrumentations or assets, the event will be deleted
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="eventId">Id of the event where the instrumentation will be removed</param>
        /// <returns></returns>
        void RemoveInstrumentationsFromEvent (InstrumentationIDs body, long? eventId);

        /// <summary>
        /// Remove instrumentations from an event
        /// </summary>
        /// <remarks>
        /// Remove one or more instrumentations from an event. If the event has no more related instrumentations or assets, the event will be deleted
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="eventId">Id of the event where the instrumentation will be removed</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveInstrumentationsFromEventWithHttpInfo (InstrumentationIDs body, long? eventId);
        /// <summary>
        /// Delete specifications of an event
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="eventId">Id of the specified event</param>
        /// <returns></returns>
        void RemoveSpecificationsFromEvent (List<string> body, long? eventId);

        /// <summary>
        /// Delete specifications of an event
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="eventId">Id of the specified event</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveSpecificationsFromEventWithHttpInfo (List<string> body, long? eventId);
        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of an event in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="eventId">Id of the specified node</param>
        /// <returns></returns>
        void RenameSpecificationsOfEvent (SpecificationsRename body, long? eventId);

        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of an event in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="eventId">Id of the specified node</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RenameSpecificationsOfEventWithHttpInfo (SpecificationsRename body, long? eventId);
        /// <summary>
        /// Replace the documents of an event
        /// </summary>
        /// <remarks>
        /// Replaces all documents belonging to an event. You can send a list of resources that will replace all previous values.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="eventId">Id of the event of which the documents will be replaced</param>
        /// <returns></returns>
        void ReplaceDocumentsOfEvent (DocumentIDs body, long? eventId);

        /// <summary>
        /// Replace the documents of an event
        /// </summary>
        /// <remarks>
        /// Replaces all documents belonging to an event. You can send a list of resources that will replace all previous values.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="eventId">Id of the event of which the documents will be replaced</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReplaceDocumentsOfEventWithHttpInfo (DocumentIDs body, long? eventId);
        /// <summary>
        /// Update an event
        /// </summary>
        /// <remarks>
        /// Update accessible parameters of the requested resource.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the event to update</param>
        /// <returns></returns>
        void UpdateEvent (EventRequest body, long? id);

        /// <summary>
        /// Update an event
        /// </summary>
        /// <remarks>
        /// Update accessible parameters of the requested resource.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the event to update</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateEventWithHttpInfo (EventRequest body, long? id);
        /// <summary>
        /// Update specifications of an event
        /// </summary>
        /// <remarks>
        /// Update the specification object of an event in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of a-z A-Z 0-9 . - _ all uppercase A-Z are converted to lower-case a-z. For a key that is send mutliple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="eventId">Id of the specified event</param>
        /// <returns></returns>
        void UpdateSpecificationsOfEvent (Dictionary<string, SpecificationRequest> body, long? eventId);

        /// <summary>
        /// Update specifications of an event
        /// </summary>
        /// <remarks>
        /// Update the specification object of an event in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of a-z A-Z 0-9 . - _ all uppercase A-Z are converted to lower-case a-z. For a key that is send mutliple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="eventId">Id of the specified event</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateSpecificationsOfEventWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? eventId);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Add documents to an event
        /// </summary>
        /// <remarks>
        /// Add one or more documents to an event.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="eventId">Id of the asset to which the documents will be added</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task AddDocumentsToEventAsync (DocumentIDs body, long? eventId);

        /// <summary>
        /// Add documents to an event
        /// </summary>
        /// <remarks>
        /// Add one or more documents to an event.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="eventId">Id of the asset to which the documents will be added</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> AddDocumentsToEventAsyncWithHttpInfo (DocumentIDs body, long? eventId);
        /// <summary>
        /// Create a new event
        /// </summary>
        /// <remarks>
        /// Event must have a name, status, type and at least one asset or an instrumentation
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Event object that needs to be created.</param>
        /// <returns>Task of EventResponse</returns>
        System.Threading.Tasks.Task<EventResponse> CreateEventAsync (EventRequest body);

        /// <summary>
        /// Create a new event
        /// </summary>
        /// <remarks>
        /// Event must have a name, status, type and at least one asset or an instrumentation
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Event object that needs to be created.</param>
        /// <returns>Task of ApiResponse (EventResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<EventResponse>> CreateEventAsyncWithHttpInfo (EventRequest body);
        /// <summary>
        /// Create a new event for an asset
        /// </summary>
        /// <remarks>
        /// Events must have a name, and can have a start_datetime (if not provided, the date of creation will be used as default value), end_datetime, event_type, event_status, description and responsible
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object to be created.</param>
        /// <param name="assetId">Id of the asset</param>
        /// <returns>Task of EventResponse</returns>
        System.Threading.Tasks.Task<EventResponse> CreateEventForAssetAsync (EventRequestNoAssets body, long? assetId);

        /// <summary>
        /// Create a new event for an asset
        /// </summary>
        /// <remarks>
        /// Events must have a name, and can have a start_datetime (if not provided, the date of creation will be used as default value), end_datetime, event_type, event_status, description and responsible
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object to be created.</param>
        /// <param name="assetId">Id of the asset</param>
        /// <returns>Task of ApiResponse (EventResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<EventResponse>> CreateEventForAssetAsyncWithHttpInfo (EventRequestNoAssets body, long? assetId);
        /// <summary>
        /// Create a new event for an instrumentation
        /// </summary>
        /// <remarks>
        /// Events must have a name, and can have a start_datetime (if not provided, the date of creation will be used as default value), end_datetime, event_type, event_status, description and responsible
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object to be created.</param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <returns>Task of EventResponse</returns>
        System.Threading.Tasks.Task<EventResponse> CreateEventForInstrumentationAsync (EventRequestNoInstrumentations body, long? instrumentationId);

        /// <summary>
        /// Create a new event for an instrumentation
        /// </summary>
        /// <remarks>
        /// Events must have a name, and can have a start_datetime (if not provided, the date of creation will be used as default value), end_datetime, event_type, event_status, description and responsible
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object to be created.</param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <returns>Task of ApiResponse (EventResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<EventResponse>> CreateEventForInstrumentationAsyncWithHttpInfo (EventRequestNoInstrumentations body, long? instrumentationId);
        /// <summary>
        /// Delete an event
        /// </summary>
        /// <remarks>
        /// Delete a specific resource identified by the id in the URL.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the event to delete</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteEventAsync (long? id);

        /// <summary>
        /// Delete an event
        /// </summary>
        /// <remarks>
        /// Delete a specific resource identified by the id in the URL.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the event to delete</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteEventAsyncWithHttpInfo (long? id);
        /// <summary>
        /// Get all assets of one event
        /// </summary>
        /// <remarks>
        /// Returns a list of all assets of an event that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;status, tenant, parent, pictures, product, product.manufacturer, product.pictures, product.status, product.categories, product.categories.parent, specifications, specifications[key1,key2], product.tenant,                             product.manufacturer.tenant, status.tenant, instrumentations &#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="serialNumber">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productCategoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="manufacturerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusCode">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productionDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="ownershipClaimed">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;serial_number&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, &#x60;last_seen_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of AssetsResponse</returns>
        System.Threading.Tasks.Task<AssetsResponse> GetAssetsOfEventAsync (long? eventId, int? page = null, int? perPage = null, string include = null, string serialNumber = null, string productId = null, string productCategoryId = null, string parentId = null, string manufacturerId = null, string statusId = null, string statusCode = null, DateTime? productionDate = null, DateTime? productionDateFrom = null, DateTime? productionDateTo = null, string specificationsKey = null, string specificationsValue = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, bool? ownershipClaimed = null, string permission = null, string orderBy = null);

        /// <summary>
        /// Get all assets of one event
        /// </summary>
        /// <remarks>
        /// Returns a list of all assets of an event that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;status, tenant, parent, pictures, product, product.manufacturer, product.pictures, product.status, product.categories, product.categories.parent, specifications, specifications[key1,key2], product.tenant,                             product.manufacturer.tenant, status.tenant, instrumentations &#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="serialNumber">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productCategoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="manufacturerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusCode">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productionDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="ownershipClaimed">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;serial_number&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, &#x60;last_seen_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (AssetsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<AssetsResponse>> GetAssetsOfEventAsyncWithHttpInfo (long? eventId, int? page = null, int? perPage = null, string include = null, string serialNumber = null, string productId = null, string productCategoryId = null, string parentId = null, string manufacturerId = null, string statusId = null, string statusCode = null, DateTime? productionDate = null, DateTime? productionDateFrom = null, DateTime? productionDateTo = null, string specificationsKey = null, string specificationsValue = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, bool? ownershipClaimed = null, string permission = null, string orderBy = null);
        /// <summary>
        /// Get all documents of an event
        /// </summary>
        /// <remarks>
        /// Returns a list of documents. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;status, tenant, classification, categories, categories.parent, categories.standards, attachments&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="classificationId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="documentVersion">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="number">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="categoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="validFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validUntil">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validAt">Expected date format is YYYY-MM-DD or YYYY-MM or YYYY (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of DocumentsResponse</returns>
        System.Threading.Tasks.Task<DocumentsResponse> GetDocumentsOfEventAsync (long? eventId, int? page = null, int? perPage = null, string include = null, string name = null, string statusId = null, string classificationId = null, string documentVersion = null, string number = null, string tenantId = null, string categoryId = null, DateTime? validFrom = null, DateTime? validUntil = null, DateTime? validAt = null, string orderBy = null, string acceptLanguage = null);

        /// <summary>
        /// Get all documents of an event
        /// </summary>
        /// <remarks>
        /// Returns a list of documents. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;status, tenant, classification, categories, categories.parent, categories.standards, attachments&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="classificationId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="documentVersion">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="number">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="categoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="validFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validUntil">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validAt">Expected date format is YYYY-MM-DD or YYYY-MM or YYYY (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of ApiResponse (DocumentsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<DocumentsResponse>> GetDocumentsOfEventAsyncWithHttpInfo (long? eventId, int? page = null, int? perPage = null, string include = null, string name = null, string statusId = null, string classificationId = null, string documentVersion = null, string number = null, string tenantId = null, string categoryId = null, DateTime? validFrom = null, DateTime? validUntil = null, DateTime? validAt = null, string orderBy = null, string acceptLanguage = null);
        /// <summary>
        /// Get a single event
        /// </summary>
        /// <remarks>
        /// Get a specific event identified by the id in the URL.  Possible include values: &#x60;&#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the event to fetch</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <returns>Task of EventResponse</returns>
        System.Threading.Tasks.Task<EventResponse> GetEventByIdAsync (long? id, string include = null);

        /// <summary>
        /// Get a single event
        /// </summary>
        /// <remarks>
        /// Get a specific event identified by the id in the URL.  Possible include values: &#x60;&#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the event to fetch</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <returns>Task of ApiResponse (EventResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<EventResponse>> GetEventByIdAsyncWithHttpInfo (long? id, string include = null);
        /// <summary>
        /// Get the status of a specific event
        /// </summary>
        /// <remarks>
        /// Returns the status of the event. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of EventStatusResponse</returns>
        System.Threading.Tasks.Task<EventStatusResponse> GetEventIdStatusAsync (long? eventId, string acceptLanguage = null);

        /// <summary>
        /// Get the status of a specific event
        /// </summary>
        /// <remarks>
        /// Returns the status of the event. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of ApiResponse (EventStatusResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<EventStatusResponse>> GetEventIdStatusAsyncWithHttpInfo (long? eventId, string acceptLanguage = null);
        /// <summary>
        /// Get the type of a specific event
        /// </summary>
        /// <remarks>
        /// Returns the type of the event. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of EventTypeResponse</returns>
        System.Threading.Tasks.Task<EventTypeResponse> GetEventIdTypeAsync (long? eventId, string acceptLanguage = null);

        /// <summary>
        /// Get the type of a specific event
        /// </summary>
        /// <remarks>
        /// Returns the type of the event. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of ApiResponse (EventTypeResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<EventTypeResponse>> GetEventIdTypeAsyncWithHttpInfo (long? eventId, string acceptLanguage = null);
        /// <summary>
        /// Get all possible statuses for the specified event
        /// </summary>
        /// <remarks>
        /// Returns a list of all possible event statuses for the specified event. You can apply the query parameters listed below to get a filtered list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of EventStatuses</returns>
        System.Threading.Tasks.Task<EventStatuses> GetEventStatusesOptionsAsync (long? eventId, int? page = null, int? perPage = null, string name = null, string code = null, string tenantId = null, string orderBy = null, string acceptLanguage = null);

        /// <summary>
        /// Get all possible statuses for the specified event
        /// </summary>
        /// <remarks>
        /// Returns a list of all possible event statuses for the specified event. You can apply the query parameters listed below to get a filtered list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of ApiResponse (EventStatuses)</returns>
        System.Threading.Tasks.Task<ApiResponse<EventStatuses>> GetEventStatusesOptionsAsyncWithHttpInfo (long? eventId, int? page = null, int? perPage = null, string name = null, string code = null, string tenantId = null, string orderBy = null, string acceptLanguage = null);
        /// <summary>
        /// Get all possible types for the specified event
        /// </summary>
        /// <remarks>
        /// Returns a list of all possible event types for the specified event. You can apply the query parameters listed below to get a filtered list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of EventTypes</returns>
        System.Threading.Tasks.Task<EventTypes> GetEventTypeesOptionsAsync (long? eventId, int? page = null, int? perPage = null, string name = null, string code = null, string tenantId = null, string orderBy = null, string acceptLanguage = null);

        /// <summary>
        /// Get all possible types for the specified event
        /// </summary>
        /// <remarks>
        /// Returns a list of all possible event types for the specified event. You can apply the query parameters listed below to get a filtered list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of ApiResponse (EventTypes)</returns>
        System.Threading.Tasks.Task<ApiResponse<EventTypes>> GetEventTypeesOptionsAsyncWithHttpInfo (long? eventId, int? page = null, int? perPage = null, string name = null, string code = null, string tenantId = null, string orderBy = null, string acceptLanguage = null);
        /// <summary>
        /// Get a range of events
        /// </summary>
        /// <remarks>
        /// Returns a list of events. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="startDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;start_datetime&#x60;, &#x60;end_datetime&#x60;, &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of EventsResponse</returns>
        System.Threading.Tasks.Task<EventsResponse> GetEventsAsync (int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string statusId = null, string startDatetime = null, string startDatetimeFrom = null, string startDatetimeTo = null, string endDatetime = null, DateTime? endDatetimeFrom = null, string endDatetimeTo = null, string tenantId = null, string orderBy = null);

        /// <summary>
        /// Get a range of events
        /// </summary>
        /// <remarks>
        /// Returns a list of events. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="startDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;start_datetime&#x60;, &#x60;end_datetime&#x60;, &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (EventsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<EventsResponse>> GetEventsAsyncWithHttpInfo (int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string statusId = null, string startDatetime = null, string startDatetimeFrom = null, string startDatetimeTo = null, string endDatetime = null, DateTime? endDatetimeFrom = null, string endDatetimeTo = null, string tenantId = null, string orderBy = null);
        /// <summary>
        /// Get all events of one asset
        /// </summary>
        /// <remarks>
        /// Returns a list of all events belonging to an asset in your accessible scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="startDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;start_datetime&#x60;, &#x60;end_datetime&#x60;, &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of EventsResponse</returns>
        System.Threading.Tasks.Task<EventsResponse> GetEventsOfAssetAsync (long? assetId, int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string statusId = null, string startDatetime = null, string startDatetimeFrom = null, string startDatetimeTo = null, string endDatetime = null, DateTime? endDatetimeFrom = null, string endDatetimeTo = null, string tenantId = null, string orderBy = null);

        /// <summary>
        /// Get all events of one asset
        /// </summary>
        /// <remarks>
        /// Returns a list of all events belonging to an asset in your accessible scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="startDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;start_datetime&#x60;, &#x60;end_datetime&#x60;, &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (EventsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<EventsResponse>> GetEventsOfAssetAsyncWithHttpInfo (long? assetId, int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string statusId = null, string startDatetime = null, string startDatetimeFrom = null, string startDatetimeTo = null, string endDatetime = null, DateTime? endDatetimeFrom = null, string endDatetimeTo = null, string tenantId = null, string orderBy = null);
        /// <summary>
        /// Get all events of one instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of all events belonging to an instrumentation in your accessible scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="startDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;start_datetime&#x60;, &#x60;end_datetime&#x60;, &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of EventsResponse</returns>
        System.Threading.Tasks.Task<EventsResponse> GetEventsOfInstrumentationAsync (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string statusId = null, string startDatetime = null, string startDatetimeFrom = null, string startDatetimeTo = null, string endDatetime = null, DateTime? endDatetimeFrom = null, string endDatetimeTo = null, string tenantId = null, string orderBy = null);

        /// <summary>
        /// Get all events of one instrumentation
        /// </summary>
        /// <remarks>
        /// Returns a list of all events belonging to an instrumentation in your accessible scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="startDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;start_datetime&#x60;, &#x60;end_datetime&#x60;, &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (EventsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<EventsResponse>> GetEventsOfInstrumentationAsyncWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string statusId = null, string startDatetime = null, string startDatetimeFrom = null, string startDatetimeTo = null, string endDatetime = null, DateTime? endDatetimeFrom = null, string endDatetimeTo = null, string tenantId = null, string orderBy = null);
        /// <summary>
        /// Get all instrumentations of one event
        /// </summary>
        /// <remarks>
        /// Returns a list of all instrumentations of an event that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;specifications, specifications[key1,key2], pictures, tenant, parent, status, type, type.tenant, type.parent&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="tag">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="criticality">Filter accepts undefined, low, medium or high (optional)</param>
        /// <param name="accessibility">Filter accepts undefined, easy, moderate or difficult (optional)</param>
        /// <param name="nodeId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all objects with no nodes assigned or \&quot;!null\&quot; for any assigned node (optional)</param>
        /// <param name="assetStatusId">One or multiple ids (comma list). Expected id format is integer. This retrieves all Instrumentations where at least one of its assets has one of the given statuses. (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;tag&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of InstrumentationsResponse</returns>
        System.Threading.Tasks.Task<InstrumentationsResponse> GetInstrumentationsOfEventAsync (long? eventId, int? page = null, int? perPage = null, string include = null, string tag = null, string statusId = null, string typeId = null, string parentId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string criticality = null, string accessibility = null, string nodeId = null, string assetStatusId = null, string permission = null, string orderBy = null);

        /// <summary>
        /// Get all instrumentations of one event
        /// </summary>
        /// <remarks>
        /// Returns a list of all instrumentations of an event that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;specifications, specifications[key1,key2], pictures, tenant, parent, status, type, type.tenant, type.parent&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="tag">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="criticality">Filter accepts undefined, low, medium or high (optional)</param>
        /// <param name="accessibility">Filter accepts undefined, easy, moderate or difficult (optional)</param>
        /// <param name="nodeId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all objects with no nodes assigned or \&quot;!null\&quot; for any assigned node (optional)</param>
        /// <param name="assetStatusId">One or multiple ids (comma list). Expected id format is integer. This retrieves all Instrumentations where at least one of its assets has one of the given statuses. (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;tag&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (InstrumentationsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<InstrumentationsResponse>> GetInstrumentationsOfEventAsyncWithHttpInfo (long? eventId, int? page = null, int? perPage = null, string include = null, string tag = null, string statusId = null, string typeId = null, string parentId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string criticality = null, string accessibility = null, string nodeId = null, string assetStatusId = null, string permission = null, string orderBy = null);
        /// <summary>
        /// Get specifications of an event
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of SpecificationsResponse</returns>
        System.Threading.Tasks.Task<SpecificationsResponse> GetSpecificationsOfEventAsync (long? eventId, string key = null);

        /// <summary>
        /// Get specifications of an event
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SpecificationsResponse>> GetSpecificationsOfEventAsyncWithHttpInfo (long? eventId, string key = null);
        /// <summary>
        /// Remove assets from an event
        /// </summary>
        /// <remarks>
        /// Remove one or more assets from an event. If the event has no more related assets or instrumentations, the event will be deleted
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="eventId">Id of the event where the asset will be removed</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveAssetsFromEventAsync (AssetIDs body, long? eventId);

        /// <summary>
        /// Remove assets from an event
        /// </summary>
        /// <remarks>
        /// Remove one or more assets from an event. If the event has no more related assets or instrumentations, the event will be deleted
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="eventId">Id of the event where the asset will be removed</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveAssetsFromEventAsyncWithHttpInfo (AssetIDs body, long? eventId);
        /// <summary>
        /// Remove documents from an event
        /// </summary>
        /// <remarks>
        /// Remove one or more documents from an event.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="eventId">Id of the event from which the documents will be removed</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveDocumentsFromEventAsync (DocumentIDs body, long? eventId);

        /// <summary>
        /// Remove documents from an event
        /// </summary>
        /// <remarks>
        /// Remove one or more documents from an event.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="eventId">Id of the event from which the documents will be removed</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveDocumentsFromEventAsyncWithHttpInfo (DocumentIDs body, long? eventId);
        /// <summary>
        /// Remove events from an asset
        /// </summary>
        /// <remarks>
        /// Remove one or more events from an asset in your accessible scope. If the event has no more related assets, the event will be deleted
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="assetId">Id of the asset from which the events will removed.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveEventFromAssetAsync (Events body, long? assetId);

        /// <summary>
        /// Remove events from an asset
        /// </summary>
        /// <remarks>
        /// Remove one or more events from an asset in your accessible scope. If the event has no more related assets, the event will be deleted
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="assetId">Id of the asset from which the events will removed.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveEventFromAssetAsyncWithHttpInfo (Events body, long? assetId);
        /// <summary>
        /// Remove events from an instrumentation
        /// </summary>
        /// <remarks>
        /// Remove one or more events from an instrumentation in your accessible scope. If the event has no more related instrumentations, the event will be deleted
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the events will removed.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveEventFromInstrumentationAsync (Events1 body, long? instrumentationId);

        /// <summary>
        /// Remove events from an instrumentation
        /// </summary>
        /// <remarks>
        /// Remove one or more events from an instrumentation in your accessible scope. If the event has no more related instrumentations, the event will be deleted
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the events will removed.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveEventFromInstrumentationAsyncWithHttpInfo (Events1 body, long? instrumentationId);
        /// <summary>
        /// Remove instrumentations from an event
        /// </summary>
        /// <remarks>
        /// Remove one or more instrumentations from an event. If the event has no more related instrumentations or assets, the event will be deleted
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="eventId">Id of the event where the instrumentation will be removed</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveInstrumentationsFromEventAsync (InstrumentationIDs body, long? eventId);

        /// <summary>
        /// Remove instrumentations from an event
        /// </summary>
        /// <remarks>
        /// Remove one or more instrumentations from an event. If the event has no more related instrumentations or assets, the event will be deleted
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="eventId">Id of the event where the instrumentation will be removed</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveInstrumentationsFromEventAsyncWithHttpInfo (InstrumentationIDs body, long? eventId);
        /// <summary>
        /// Delete specifications of an event
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="eventId">Id of the specified event</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveSpecificationsFromEventAsync (List<string> body, long? eventId);

        /// <summary>
        /// Delete specifications of an event
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="eventId">Id of the specified event</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveSpecificationsFromEventAsyncWithHttpInfo (List<string> body, long? eventId);
        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of an event in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="eventId">Id of the specified node</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RenameSpecificationsOfEventAsync (SpecificationsRename body, long? eventId);

        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of an event in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="eventId">Id of the specified node</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RenameSpecificationsOfEventAsyncWithHttpInfo (SpecificationsRename body, long? eventId);
        /// <summary>
        /// Replace the documents of an event
        /// </summary>
        /// <remarks>
        /// Replaces all documents belonging to an event. You can send a list of resources that will replace all previous values.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="eventId">Id of the event of which the documents will be replaced</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task ReplaceDocumentsOfEventAsync (DocumentIDs body, long? eventId);

        /// <summary>
        /// Replace the documents of an event
        /// </summary>
        /// <remarks>
        /// Replaces all documents belonging to an event. You can send a list of resources that will replace all previous values.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="eventId">Id of the event of which the documents will be replaced</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> ReplaceDocumentsOfEventAsyncWithHttpInfo (DocumentIDs body, long? eventId);
        /// <summary>
        /// Update an event
        /// </summary>
        /// <remarks>
        /// Update accessible parameters of the requested resource.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the event to update</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UpdateEventAsync (EventRequest body, long? id);

        /// <summary>
        /// Update an event
        /// </summary>
        /// <remarks>
        /// Update accessible parameters of the requested resource.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the event to update</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UpdateEventAsyncWithHttpInfo (EventRequest body, long? id);
        /// <summary>
        /// Update specifications of an event
        /// </summary>
        /// <remarks>
        /// Update the specification object of an event in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of a-z A-Z 0-9 . - _ all uppercase A-Z are converted to lower-case a-z. For a key that is send mutliple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="eventId">Id of the specified event</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UpdateSpecificationsOfEventAsync (Dictionary<string, SpecificationRequest> body, long? eventId);

        /// <summary>
        /// Update specifications of an event
        /// </summary>
        /// <remarks>
        /// Update the specification object of an event in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of a-z A-Z 0-9 . - _ all uppercase A-Z are converted to lower-case a-z. For a key that is send mutliple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="eventId">Id of the specified event</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSpecificationsOfEventAsyncWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? eventId);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
        public partial class EventApi : IEventApi
    {
        private Netilion.Api.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="EventApi"/> class.
        /// </summary>
        /// <returns></returns>
        public EventApi(String basePath)
        {
            this.Configuration = new Netilion.Api.Client.Configuration { BasePath = basePath };

            ExceptionFactory = Netilion.Api.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="EventApi"/> class
        /// </summary>
        /// <returns></returns>
        public EventApi()
        {
            this.Configuration = Netilion.Api.Client.Configuration.Default;

            ExceptionFactory = Netilion.Api.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="EventApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public EventApi(Netilion.Api.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = Netilion.Api.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = Netilion.Api.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Netilion.Api.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Netilion.Api.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Add documents to an event Add one or more documents to an event.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="eventId">Id of the asset to which the documents will be added</param>
        /// <returns></returns>
        public void AddDocumentsToEvent (DocumentIDs body, long? eventId)
        {
             AddDocumentsToEventWithHttpInfo(body, eventId);
        }

        /// <summary>
        /// Add documents to an event Add one or more documents to an event.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="eventId">Id of the asset to which the documents will be added</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> AddDocumentsToEventWithHttpInfo (DocumentIDs body, long? eventId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling EventApi->AddDocumentsToEvent");
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling EventApi->AddDocumentsToEvent");

            var localVarPath = "/events/{event_id}/documents";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddDocumentsToEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Add documents to an event Add one or more documents to an event.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="eventId">Id of the asset to which the documents will be added</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task AddDocumentsToEventAsync (DocumentIDs body, long? eventId)
        {
             await AddDocumentsToEventAsyncWithHttpInfo(body, eventId);

        }

        /// <summary>
        /// Add documents to an event Add one or more documents to an event.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="eventId">Id of the asset to which the documents will be added</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> AddDocumentsToEventAsyncWithHttpInfo (DocumentIDs body, long? eventId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling EventApi->AddDocumentsToEvent");
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling EventApi->AddDocumentsToEvent");

            var localVarPath = "/events/{event_id}/documents";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddDocumentsToEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Create a new event Event must have a name, status, type and at least one asset or an instrumentation
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Event object that needs to be created.</param>
        /// <returns>EventResponse</returns>
        public EventResponse CreateEvent (EventRequest body)
        {
             ApiResponse<EventResponse> localVarResponse = CreateEventWithHttpInfo(body);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Create a new event Event must have a name, status, type and at least one asset or an instrumentation
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Event object that needs to be created.</param>
        /// <returns>ApiResponse of EventResponse</returns>
        public ApiResponse< EventResponse > CreateEventWithHttpInfo (EventRequest body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling EventApi->CreateEvent");

            var localVarPath = "/events";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<EventResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (EventResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(EventResponse)));
        }

        /// <summary>
        /// Create a new event Event must have a name, status, type and at least one asset or an instrumentation
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Event object that needs to be created.</param>
        /// <returns>Task of EventResponse</returns>
        public async System.Threading.Tasks.Task<EventResponse> CreateEventAsync (EventRequest body)
        {
             ApiResponse<EventResponse> localVarResponse = await CreateEventAsyncWithHttpInfo(body);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Create a new event Event must have a name, status, type and at least one asset or an instrumentation
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Event object that needs to be created.</param>
        /// <returns>Task of ApiResponse (EventResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<EventResponse>> CreateEventAsyncWithHttpInfo (EventRequest body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling EventApi->CreateEvent");

            var localVarPath = "/events";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<EventResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (EventResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(EventResponse)));
        }

        /// <summary>
        /// Create a new event for an asset Events must have a name, and can have a start_datetime (if not provided, the date of creation will be used as default value), end_datetime, event_type, event_status, description and responsible
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object to be created.</param>
        /// <param name="assetId">Id of the asset</param>
        /// <returns>EventResponse</returns>
        public EventResponse CreateEventForAsset (EventRequestNoAssets body, long? assetId)
        {
             ApiResponse<EventResponse> localVarResponse = CreateEventForAssetWithHttpInfo(body, assetId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Create a new event for an asset Events must have a name, and can have a start_datetime (if not provided, the date of creation will be used as default value), end_datetime, event_type, event_status, description and responsible
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object to be created.</param>
        /// <param name="assetId">Id of the asset</param>
        /// <returns>ApiResponse of EventResponse</returns>
        public ApiResponse< EventResponse > CreateEventForAssetWithHttpInfo (EventRequestNoAssets body, long? assetId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling EventApi->CreateEventForAsset");
            // verify the required parameter 'assetId' is set
            if (assetId == null)
                throw new ApiException(400, "Missing required parameter 'assetId' when calling EventApi->CreateEventForAsset");

            var localVarPath = "/assets/{asset_id}/events";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (assetId != null) localVarPathParams.Add("asset_id", this.Configuration.ApiClient.ParameterToString(assetId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateEventForAsset", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<EventResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (EventResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(EventResponse)));
        }

        /// <summary>
        /// Create a new event for an asset Events must have a name, and can have a start_datetime (if not provided, the date of creation will be used as default value), end_datetime, event_type, event_status, description and responsible
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object to be created.</param>
        /// <param name="assetId">Id of the asset</param>
        /// <returns>Task of EventResponse</returns>
        public async System.Threading.Tasks.Task<EventResponse> CreateEventForAssetAsync (EventRequestNoAssets body, long? assetId)
        {
             ApiResponse<EventResponse> localVarResponse = await CreateEventForAssetAsyncWithHttpInfo(body, assetId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Create a new event for an asset Events must have a name, and can have a start_datetime (if not provided, the date of creation will be used as default value), end_datetime, event_type, event_status, description and responsible
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object to be created.</param>
        /// <param name="assetId">Id of the asset</param>
        /// <returns>Task of ApiResponse (EventResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<EventResponse>> CreateEventForAssetAsyncWithHttpInfo (EventRequestNoAssets body, long? assetId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling EventApi->CreateEventForAsset");
            // verify the required parameter 'assetId' is set
            if (assetId == null)
                throw new ApiException(400, "Missing required parameter 'assetId' when calling EventApi->CreateEventForAsset");

            var localVarPath = "/assets/{asset_id}/events";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (assetId != null) localVarPathParams.Add("asset_id", this.Configuration.ApiClient.ParameterToString(assetId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateEventForAsset", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<EventResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (EventResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(EventResponse)));
        }

        /// <summary>
        /// Create a new event for an instrumentation Events must have a name, and can have a start_datetime (if not provided, the date of creation will be used as default value), end_datetime, event_type, event_status, description and responsible
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object to be created.</param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <returns>EventResponse</returns>
        public EventResponse CreateEventForInstrumentation (EventRequestNoInstrumentations body, long? instrumentationId)
        {
             ApiResponse<EventResponse> localVarResponse = CreateEventForInstrumentationWithHttpInfo(body, instrumentationId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Create a new event for an instrumentation Events must have a name, and can have a start_datetime (if not provided, the date of creation will be used as default value), end_datetime, event_type, event_status, description and responsible
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object to be created.</param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <returns>ApiResponse of EventResponse</returns>
        public ApiResponse< EventResponse > CreateEventForInstrumentationWithHttpInfo (EventRequestNoInstrumentations body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling EventApi->CreateEventForInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling EventApi->CreateEventForInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/events";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateEventForInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<EventResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (EventResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(EventResponse)));
        }

        /// <summary>
        /// Create a new event for an instrumentation Events must have a name, and can have a start_datetime (if not provided, the date of creation will be used as default value), end_datetime, event_type, event_status, description and responsible
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object to be created.</param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <returns>Task of EventResponse</returns>
        public async System.Threading.Tasks.Task<EventResponse> CreateEventForInstrumentationAsync (EventRequestNoInstrumentations body, long? instrumentationId)
        {
             ApiResponse<EventResponse> localVarResponse = await CreateEventForInstrumentationAsyncWithHttpInfo(body, instrumentationId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Create a new event for an instrumentation Events must have a name, and can have a start_datetime (if not provided, the date of creation will be used as default value), end_datetime, event_type, event_status, description and responsible
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object to be created.</param>
        /// <param name="instrumentationId">Id of the instrumentation</param>
        /// <returns>Task of ApiResponse (EventResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<EventResponse>> CreateEventForInstrumentationAsyncWithHttpInfo (EventRequestNoInstrumentations body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling EventApi->CreateEventForInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling EventApi->CreateEventForInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/events";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateEventForInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<EventResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (EventResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(EventResponse)));
        }

        /// <summary>
        /// Delete an event Delete a specific resource identified by the id in the URL.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the event to delete</param>
        /// <returns></returns>
        public void DeleteEvent (long? id)
        {
             DeleteEventWithHttpInfo(id);
        }

        /// <summary>
        /// Delete an event Delete a specific resource identified by the id in the URL.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the event to delete</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteEventWithHttpInfo (long? id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling EventApi->DeleteEvent");

            var localVarPath = "/events/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete an event Delete a specific resource identified by the id in the URL.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the event to delete</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteEventAsync (long? id)
        {
             await DeleteEventAsyncWithHttpInfo(id);

        }

        /// <summary>
        /// Delete an event Delete a specific resource identified by the id in the URL.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the event to delete</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> DeleteEventAsyncWithHttpInfo (long? id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling EventApi->DeleteEvent");

            var localVarPath = "/events/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Get all assets of one event Returns a list of all assets of an event that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;status, tenant, parent, pictures, product, product.manufacturer, product.pictures, product.status, product.categories, product.categories.parent, specifications, specifications[key1,key2], product.tenant,                             product.manufacturer.tenant, status.tenant, instrumentations &#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="serialNumber">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productCategoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="manufacturerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusCode">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productionDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="ownershipClaimed">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;serial_number&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, &#x60;last_seen_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>AssetsResponse</returns>
        public AssetsResponse GetAssetsOfEvent (long? eventId, int? page = null, int? perPage = null, string include = null, string serialNumber = null, string productId = null, string productCategoryId = null, string parentId = null, string manufacturerId = null, string statusId = null, string statusCode = null, DateTime? productionDate = null, DateTime? productionDateFrom = null, DateTime? productionDateTo = null, string specificationsKey = null, string specificationsValue = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, bool? ownershipClaimed = null, string permission = null, string orderBy = null)
        {
             ApiResponse<AssetsResponse> localVarResponse = GetAssetsOfEventWithHttpInfo(eventId, page, perPage, include, serialNumber, productId, productCategoryId, parentId, manufacturerId, statusId, statusCode, productionDate, productionDateFrom, productionDateTo, specificationsKey, specificationsValue, createdAt, createdAtFrom, createdAtTo, updatedAt, updatedAtFrom, updatedAtTo, ownershipClaimed, permission, orderBy);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get all assets of one event Returns a list of all assets of an event that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;status, tenant, parent, pictures, product, product.manufacturer, product.pictures, product.status, product.categories, product.categories.parent, specifications, specifications[key1,key2], product.tenant,                             product.manufacturer.tenant, status.tenant, instrumentations &#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="serialNumber">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productCategoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="manufacturerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusCode">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productionDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="ownershipClaimed">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;serial_number&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, &#x60;last_seen_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of AssetsResponse</returns>
        public ApiResponse< AssetsResponse > GetAssetsOfEventWithHttpInfo (long? eventId, int? page = null, int? perPage = null, string include = null, string serialNumber = null, string productId = null, string productCategoryId = null, string parentId = null, string manufacturerId = null, string statusId = null, string statusCode = null, DateTime? productionDate = null, DateTime? productionDateFrom = null, DateTime? productionDateTo = null, string specificationsKey = null, string specificationsValue = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, bool? ownershipClaimed = null, string permission = null, string orderBy = null)
        {
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling EventApi->GetAssetsOfEvent");

            var localVarPath = "/events/{event_id}/assets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (serialNumber != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "serial_number", serialNumber)); // query parameter
            if (productId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "product_id", productId)); // query parameter
            if (productCategoryId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "product_category_id", productCategoryId)); // query parameter
            if (parentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "parent_id", parentId)); // query parameter
            if (manufacturerId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "manufacturer_id", manufacturerId)); // query parameter
            if (statusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_id", statusId)); // query parameter
            if (statusCode != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_code", statusCode)); // query parameter
            if (productionDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "production_date", productionDate)); // query parameter
            if (productionDateFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "production_date_from", productionDateFrom)); // query parameter
            if (productionDateTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "production_date_to", productionDateTo)); // query parameter
            if (specificationsKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_key", specificationsKey)); // query parameter
            if (specificationsValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_value", specificationsValue)); // query parameter
            if (createdAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "created_at", createdAt)); // query parameter
            if (createdAtFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "created_at_from", createdAtFrom)); // query parameter
            if (createdAtTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "created_at_to", createdAtTo)); // query parameter
            if (updatedAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at", updatedAt)); // query parameter
            if (updatedAtFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_from", updatedAtFrom)); // query parameter
            if (updatedAtTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_to", updatedAtTo)); // query parameter
            if (ownershipClaimed != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ownership_claimed", ownershipClaimed)); // query parameter
            if (permission != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "permission", permission)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetAssetsOfEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AssetsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (AssetsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AssetsResponse)));
        }

        /// <summary>
        /// Get all assets of one event Returns a list of all assets of an event that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;status, tenant, parent, pictures, product, product.manufacturer, product.pictures, product.status, product.categories, product.categories.parent, specifications, specifications[key1,key2], product.tenant,                             product.manufacturer.tenant, status.tenant, instrumentations &#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="serialNumber">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productCategoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="manufacturerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusCode">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productionDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="ownershipClaimed">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;serial_number&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, &#x60;last_seen_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of AssetsResponse</returns>
        public async System.Threading.Tasks.Task<AssetsResponse> GetAssetsOfEventAsync (long? eventId, int? page = null, int? perPage = null, string include = null, string serialNumber = null, string productId = null, string productCategoryId = null, string parentId = null, string manufacturerId = null, string statusId = null, string statusCode = null, DateTime? productionDate = null, DateTime? productionDateFrom = null, DateTime? productionDateTo = null, string specificationsKey = null, string specificationsValue = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, bool? ownershipClaimed = null, string permission = null, string orderBy = null)
        {
             ApiResponse<AssetsResponse> localVarResponse = await GetAssetsOfEventAsyncWithHttpInfo(eventId, page, perPage, include, serialNumber, productId, productCategoryId, parentId, manufacturerId, statusId, statusCode, productionDate, productionDateFrom, productionDateTo, specificationsKey, specificationsValue, createdAt, createdAtFrom, createdAtTo, updatedAt, updatedAtFrom, updatedAtTo, ownershipClaimed, permission, orderBy);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get all assets of one event Returns a list of all assets of an event that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;status, tenant, parent, pictures, product, product.manufacturer, product.pictures, product.status, product.categories, product.categories.parent, specifications, specifications[key1,key2], product.tenant,                             product.manufacturer.tenant, status.tenant, instrumentations &#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="serialNumber">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productCategoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="manufacturerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusCode">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productionDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="ownershipClaimed">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;serial_number&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, &#x60;last_seen_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (AssetsResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<AssetsResponse>> GetAssetsOfEventAsyncWithHttpInfo (long? eventId, int? page = null, int? perPage = null, string include = null, string serialNumber = null, string productId = null, string productCategoryId = null, string parentId = null, string manufacturerId = null, string statusId = null, string statusCode = null, DateTime? productionDate = null, DateTime? productionDateFrom = null, DateTime? productionDateTo = null, string specificationsKey = null, string specificationsValue = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, bool? ownershipClaimed = null, string permission = null, string orderBy = null)
        {
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling EventApi->GetAssetsOfEvent");

            var localVarPath = "/events/{event_id}/assets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (serialNumber != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "serial_number", serialNumber)); // query parameter
            if (productId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "product_id", productId)); // query parameter
            if (productCategoryId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "product_category_id", productCategoryId)); // query parameter
            if (parentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "parent_id", parentId)); // query parameter
            if (manufacturerId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "manufacturer_id", manufacturerId)); // query parameter
            if (statusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_id", statusId)); // query parameter
            if (statusCode != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_code", statusCode)); // query parameter
            if (productionDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "production_date", productionDate)); // query parameter
            if (productionDateFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "production_date_from", productionDateFrom)); // query parameter
            if (productionDateTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "production_date_to", productionDateTo)); // query parameter
            if (specificationsKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_key", specificationsKey)); // query parameter
            if (specificationsValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_value", specificationsValue)); // query parameter
            if (createdAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "created_at", createdAt)); // query parameter
            if (createdAtFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "created_at_from", createdAtFrom)); // query parameter
            if (createdAtTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "created_at_to", createdAtTo)); // query parameter
            if (updatedAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at", updatedAt)); // query parameter
            if (updatedAtFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_from", updatedAtFrom)); // query parameter
            if (updatedAtTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_to", updatedAtTo)); // query parameter
            if (ownershipClaimed != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ownership_claimed", ownershipClaimed)); // query parameter
            if (permission != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "permission", permission)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetAssetsOfEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AssetsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (AssetsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AssetsResponse)));
        }

        /// <summary>
        /// Get all documents of an event Returns a list of documents. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;status, tenant, classification, categories, categories.parent, categories.standards, attachments&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="classificationId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="documentVersion">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="number">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="categoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="validFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validUntil">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validAt">Expected date format is YYYY-MM-DD or YYYY-MM or YYYY (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>DocumentsResponse</returns>
        public DocumentsResponse GetDocumentsOfEvent (long? eventId, int? page = null, int? perPage = null, string include = null, string name = null, string statusId = null, string classificationId = null, string documentVersion = null, string number = null, string tenantId = null, string categoryId = null, DateTime? validFrom = null, DateTime? validUntil = null, DateTime? validAt = null, string orderBy = null, string acceptLanguage = null)
        {
             ApiResponse<DocumentsResponse> localVarResponse = GetDocumentsOfEventWithHttpInfo(eventId, page, perPage, include, name, statusId, classificationId, documentVersion, number, tenantId, categoryId, validFrom, validUntil, validAt, orderBy, acceptLanguage);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get all documents of an event Returns a list of documents. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;status, tenant, classification, categories, categories.parent, categories.standards, attachments&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="classificationId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="documentVersion">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="number">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="categoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="validFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validUntil">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validAt">Expected date format is YYYY-MM-DD or YYYY-MM or YYYY (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>ApiResponse of DocumentsResponse</returns>
        public ApiResponse< DocumentsResponse > GetDocumentsOfEventWithHttpInfo (long? eventId, int? page = null, int? perPage = null, string include = null, string name = null, string statusId = null, string classificationId = null, string documentVersion = null, string number = null, string tenantId = null, string categoryId = null, DateTime? validFrom = null, DateTime? validUntil = null, DateTime? validAt = null, string orderBy = null, string acceptLanguage = null)
        {
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling EventApi->GetDocumentsOfEvent");

            var localVarPath = "/events/{event_id}/documents";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (statusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_id", statusId)); // query parameter
            if (classificationId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "classification_id", classificationId)); // query parameter
            if (documentVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "document_version", documentVersion)); // query parameter
            if (number != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "number", number)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (categoryId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "category_id", categoryId)); // query parameter
            if (validFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "valid_from", validFrom)); // query parameter
            if (validUntil != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "valid_until", validUntil)); // query parameter
            if (validAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "valid_at", validAt)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            if (acceptLanguage != null) localVarHeaderParams.Add("Accept-Language", this.Configuration.ApiClient.ParameterToString(acceptLanguage)); // header parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetDocumentsOfEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<DocumentsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (DocumentsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(DocumentsResponse)));
        }

        /// <summary>
        /// Get all documents of an event Returns a list of documents. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;status, tenant, classification, categories, categories.parent, categories.standards, attachments&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="classificationId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="documentVersion">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="number">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="categoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="validFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validUntil">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validAt">Expected date format is YYYY-MM-DD or YYYY-MM or YYYY (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of DocumentsResponse</returns>
        public async System.Threading.Tasks.Task<DocumentsResponse> GetDocumentsOfEventAsync (long? eventId, int? page = null, int? perPage = null, string include = null, string name = null, string statusId = null, string classificationId = null, string documentVersion = null, string number = null, string tenantId = null, string categoryId = null, DateTime? validFrom = null, DateTime? validUntil = null, DateTime? validAt = null, string orderBy = null, string acceptLanguage = null)
        {
             ApiResponse<DocumentsResponse> localVarResponse = await GetDocumentsOfEventAsyncWithHttpInfo(eventId, page, perPage, include, name, statusId, classificationId, documentVersion, number, tenantId, categoryId, validFrom, validUntil, validAt, orderBy, acceptLanguage);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get all documents of an event Returns a list of documents. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;status, tenant, classification, categories, categories.parent, categories.standards, attachments&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="classificationId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="documentVersion">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="number">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="categoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="validFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validUntil">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validAt">Expected date format is YYYY-MM-DD or YYYY-MM or YYYY (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of ApiResponse (DocumentsResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<DocumentsResponse>> GetDocumentsOfEventAsyncWithHttpInfo (long? eventId, int? page = null, int? perPage = null, string include = null, string name = null, string statusId = null, string classificationId = null, string documentVersion = null, string number = null, string tenantId = null, string categoryId = null, DateTime? validFrom = null, DateTime? validUntil = null, DateTime? validAt = null, string orderBy = null, string acceptLanguage = null)
        {
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling EventApi->GetDocumentsOfEvent");

            var localVarPath = "/events/{event_id}/documents";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (statusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_id", statusId)); // query parameter
            if (classificationId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "classification_id", classificationId)); // query parameter
            if (documentVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "document_version", documentVersion)); // query parameter
            if (number != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "number", number)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (categoryId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "category_id", categoryId)); // query parameter
            if (validFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "valid_from", validFrom)); // query parameter
            if (validUntil != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "valid_until", validUntil)); // query parameter
            if (validAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "valid_at", validAt)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            if (acceptLanguage != null) localVarHeaderParams.Add("Accept-Language", this.Configuration.ApiClient.ParameterToString(acceptLanguage)); // header parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetDocumentsOfEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<DocumentsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (DocumentsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(DocumentsResponse)));
        }

        /// <summary>
        /// Get a single event Get a specific event identified by the id in the URL.  Possible include values: &#x60;&#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the event to fetch</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <returns>EventResponse</returns>
        public EventResponse GetEventById (long? id, string include = null)
        {
             ApiResponse<EventResponse> localVarResponse = GetEventByIdWithHttpInfo(id, include);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get a single event Get a specific event identified by the id in the URL.  Possible include values: &#x60;&#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the event to fetch</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <returns>ApiResponse of EventResponse</returns>
        public ApiResponse< EventResponse > GetEventByIdWithHttpInfo (long? id, string include = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling EventApi->GetEventById");

            var localVarPath = "/events/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetEventById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<EventResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (EventResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(EventResponse)));
        }

        /// <summary>
        /// Get a single event Get a specific event identified by the id in the URL.  Possible include values: &#x60;&#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the event to fetch</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <returns>Task of EventResponse</returns>
        public async System.Threading.Tasks.Task<EventResponse> GetEventByIdAsync (long? id, string include = null)
        {
             ApiResponse<EventResponse> localVarResponse = await GetEventByIdAsyncWithHttpInfo(id, include);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get a single event Get a specific event identified by the id in the URL.  Possible include values: &#x60;&#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the event to fetch</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <returns>Task of ApiResponse (EventResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<EventResponse>> GetEventByIdAsyncWithHttpInfo (long? id, string include = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling EventApi->GetEventById");

            var localVarPath = "/events/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetEventById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<EventResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (EventResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(EventResponse)));
        }

        /// <summary>
        /// Get the status of a specific event Returns the status of the event. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>EventStatusResponse</returns>
        public EventStatusResponse GetEventIdStatus (long? eventId, string acceptLanguage = null)
        {
             ApiResponse<EventStatusResponse> localVarResponse = GetEventIdStatusWithHttpInfo(eventId, acceptLanguage);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get the status of a specific event Returns the status of the event. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>ApiResponse of EventStatusResponse</returns>
        public ApiResponse< EventStatusResponse > GetEventIdStatusWithHttpInfo (long? eventId, string acceptLanguage = null)
        {
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling EventApi->GetEventIdStatus");

            var localVarPath = "/events/{event_id}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (acceptLanguage != null) localVarHeaderParams.Add("Accept-Language", this.Configuration.ApiClient.ParameterToString(acceptLanguage)); // header parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetEventIdStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<EventStatusResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (EventStatusResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(EventStatusResponse)));
        }

        /// <summary>
        /// Get the status of a specific event Returns the status of the event. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of EventStatusResponse</returns>
        public async System.Threading.Tasks.Task<EventStatusResponse> GetEventIdStatusAsync (long? eventId, string acceptLanguage = null)
        {
             ApiResponse<EventStatusResponse> localVarResponse = await GetEventIdStatusAsyncWithHttpInfo(eventId, acceptLanguage);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get the status of a specific event Returns the status of the event. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of ApiResponse (EventStatusResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<EventStatusResponse>> GetEventIdStatusAsyncWithHttpInfo (long? eventId, string acceptLanguage = null)
        {
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling EventApi->GetEventIdStatus");

            var localVarPath = "/events/{event_id}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (acceptLanguage != null) localVarHeaderParams.Add("Accept-Language", this.Configuration.ApiClient.ParameterToString(acceptLanguage)); // header parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetEventIdStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<EventStatusResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (EventStatusResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(EventStatusResponse)));
        }

        /// <summary>
        /// Get the type of a specific event Returns the type of the event. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>EventTypeResponse</returns>
        public EventTypeResponse GetEventIdType (long? eventId, string acceptLanguage = null)
        {
             ApiResponse<EventTypeResponse> localVarResponse = GetEventIdTypeWithHttpInfo(eventId, acceptLanguage);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get the type of a specific event Returns the type of the event. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>ApiResponse of EventTypeResponse</returns>
        public ApiResponse< EventTypeResponse > GetEventIdTypeWithHttpInfo (long? eventId, string acceptLanguage = null)
        {
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling EventApi->GetEventIdType");

            var localVarPath = "/events/{event_id}/type";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (acceptLanguage != null) localVarHeaderParams.Add("Accept-Language", this.Configuration.ApiClient.ParameterToString(acceptLanguage)); // header parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetEventIdType", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<EventTypeResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (EventTypeResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(EventTypeResponse)));
        }

        /// <summary>
        /// Get the type of a specific event Returns the type of the event. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of EventTypeResponse</returns>
        public async System.Threading.Tasks.Task<EventTypeResponse> GetEventIdTypeAsync (long? eventId, string acceptLanguage = null)
        {
             ApiResponse<EventTypeResponse> localVarResponse = await GetEventIdTypeAsyncWithHttpInfo(eventId, acceptLanguage);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get the type of a specific event Returns the type of the event. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of ApiResponse (EventTypeResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<EventTypeResponse>> GetEventIdTypeAsyncWithHttpInfo (long? eventId, string acceptLanguage = null)
        {
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling EventApi->GetEventIdType");

            var localVarPath = "/events/{event_id}/type";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (acceptLanguage != null) localVarHeaderParams.Add("Accept-Language", this.Configuration.ApiClient.ParameterToString(acceptLanguage)); // header parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetEventIdType", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<EventTypeResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (EventTypeResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(EventTypeResponse)));
        }

        /// <summary>
        /// Get all possible statuses for the specified event Returns a list of all possible event statuses for the specified event. You can apply the query parameters listed below to get a filtered list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>EventStatuses</returns>
        public EventStatuses GetEventStatusesOptions (long? eventId, int? page = null, int? perPage = null, string name = null, string code = null, string tenantId = null, string orderBy = null, string acceptLanguage = null)
        {
             ApiResponse<EventStatuses> localVarResponse = GetEventStatusesOptionsWithHttpInfo(eventId, page, perPage, name, code, tenantId, orderBy, acceptLanguage);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get all possible statuses for the specified event Returns a list of all possible event statuses for the specified event. You can apply the query parameters listed below to get a filtered list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>ApiResponse of EventStatuses</returns>
        public ApiResponse< EventStatuses > GetEventStatusesOptionsWithHttpInfo (long? eventId, int? page = null, int? perPage = null, string name = null, string code = null, string tenantId = null, string orderBy = null, string acceptLanguage = null)
        {
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling EventApi->GetEventStatusesOptions");

            var localVarPath = "/events/{event_id}/status-options";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (code != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "code", code)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            if (acceptLanguage != null) localVarHeaderParams.Add("Accept-Language", this.Configuration.ApiClient.ParameterToString(acceptLanguage)); // header parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetEventStatusesOptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<EventStatuses>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (EventStatuses) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(EventStatuses)));
        }

        /// <summary>
        /// Get all possible statuses for the specified event Returns a list of all possible event statuses for the specified event. You can apply the query parameters listed below to get a filtered list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of EventStatuses</returns>
        public async System.Threading.Tasks.Task<EventStatuses> GetEventStatusesOptionsAsync (long? eventId, int? page = null, int? perPage = null, string name = null, string code = null, string tenantId = null, string orderBy = null, string acceptLanguage = null)
        {
             ApiResponse<EventStatuses> localVarResponse = await GetEventStatusesOptionsAsyncWithHttpInfo(eventId, page, perPage, name, code, tenantId, orderBy, acceptLanguage);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get all possible statuses for the specified event Returns a list of all possible event statuses for the specified event. You can apply the query parameters listed below to get a filtered list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of ApiResponse (EventStatuses)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<EventStatuses>> GetEventStatusesOptionsAsyncWithHttpInfo (long? eventId, int? page = null, int? perPage = null, string name = null, string code = null, string tenantId = null, string orderBy = null, string acceptLanguage = null)
        {
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling EventApi->GetEventStatusesOptions");

            var localVarPath = "/events/{event_id}/status-options";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (code != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "code", code)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            if (acceptLanguage != null) localVarHeaderParams.Add("Accept-Language", this.Configuration.ApiClient.ParameterToString(acceptLanguage)); // header parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetEventStatusesOptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<EventStatuses>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (EventStatuses) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(EventStatuses)));
        }

        /// <summary>
        /// Get all possible types for the specified event Returns a list of all possible event types for the specified event. You can apply the query parameters listed below to get a filtered list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>EventTypes</returns>
        public EventTypes GetEventTypeesOptions (long? eventId, int? page = null, int? perPage = null, string name = null, string code = null, string tenantId = null, string orderBy = null, string acceptLanguage = null)
        {
             ApiResponse<EventTypes> localVarResponse = GetEventTypeesOptionsWithHttpInfo(eventId, page, perPage, name, code, tenantId, orderBy, acceptLanguage);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get all possible types for the specified event Returns a list of all possible event types for the specified event. You can apply the query parameters listed below to get a filtered list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>ApiResponse of EventTypes</returns>
        public ApiResponse< EventTypes > GetEventTypeesOptionsWithHttpInfo (long? eventId, int? page = null, int? perPage = null, string name = null, string code = null, string tenantId = null, string orderBy = null, string acceptLanguage = null)
        {
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling EventApi->GetEventTypeesOptions");

            var localVarPath = "/events/{event_id}/type-options";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (code != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "code", code)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            if (acceptLanguage != null) localVarHeaderParams.Add("Accept-Language", this.Configuration.ApiClient.ParameterToString(acceptLanguage)); // header parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetEventTypeesOptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<EventTypes>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (EventTypes) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(EventTypes)));
        }

        /// <summary>
        /// Get all possible types for the specified event Returns a list of all possible event types for the specified event. You can apply the query parameters listed below to get a filtered list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of EventTypes</returns>
        public async System.Threading.Tasks.Task<EventTypes> GetEventTypeesOptionsAsync (long? eventId, int? page = null, int? perPage = null, string name = null, string code = null, string tenantId = null, string orderBy = null, string acceptLanguage = null)
        {
             ApiResponse<EventTypes> localVarResponse = await GetEventTypeesOptionsAsyncWithHttpInfo(eventId, page, perPage, name, code, tenantId, orderBy, acceptLanguage);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get all possible types for the specified event Returns a list of all possible event types for the specified event. You can apply the query parameters listed below to get a filtered list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of ApiResponse (EventTypes)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<EventTypes>> GetEventTypeesOptionsAsyncWithHttpInfo (long? eventId, int? page = null, int? perPage = null, string name = null, string code = null, string tenantId = null, string orderBy = null, string acceptLanguage = null)
        {
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling EventApi->GetEventTypeesOptions");

            var localVarPath = "/events/{event_id}/type-options";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (code != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "code", code)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            if (acceptLanguage != null) localVarHeaderParams.Add("Accept-Language", this.Configuration.ApiClient.ParameterToString(acceptLanguage)); // header parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetEventTypeesOptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<EventTypes>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (EventTypes) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(EventTypes)));
        }

        /// <summary>
        /// Get a range of events Returns a list of events. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="startDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;start_datetime&#x60;, &#x60;end_datetime&#x60;, &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>EventsResponse</returns>
        public EventsResponse GetEvents (int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string statusId = null, string startDatetime = null, string startDatetimeFrom = null, string startDatetimeTo = null, string endDatetime = null, DateTime? endDatetimeFrom = null, string endDatetimeTo = null, string tenantId = null, string orderBy = null)
        {
             ApiResponse<EventsResponse> localVarResponse = GetEventsWithHttpInfo(page, perPage, include, name, typeId, statusId, startDatetime, startDatetimeFrom, startDatetimeTo, endDatetime, endDatetimeFrom, endDatetimeTo, tenantId, orderBy);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get a range of events Returns a list of events. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="startDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;start_datetime&#x60;, &#x60;end_datetime&#x60;, &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of EventsResponse</returns>
        public ApiResponse< EventsResponse > GetEventsWithHttpInfo (int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string statusId = null, string startDatetime = null, string startDatetimeFrom = null, string startDatetimeTo = null, string endDatetime = null, DateTime? endDatetimeFrom = null, string endDatetimeTo = null, string tenantId = null, string orderBy = null)
        {

            var localVarPath = "/events";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (typeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type_id", typeId)); // query parameter
            if (statusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_id", statusId)); // query parameter
            if (startDatetime != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start_datetime", startDatetime)); // query parameter
            if (startDatetimeFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start_datetime_from", startDatetimeFrom)); // query parameter
            if (startDatetimeTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start_datetime_to", startDatetimeTo)); // query parameter
            if (endDatetime != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "end_datetime", endDatetime)); // query parameter
            if (endDatetimeFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "end_datetime_from", endDatetimeFrom)); // query parameter
            if (endDatetimeTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "end_datetime_to", endDatetimeTo)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetEvents", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<EventsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (EventsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(EventsResponse)));
        }

        /// <summary>
        /// Get a range of events Returns a list of events. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="startDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;start_datetime&#x60;, &#x60;end_datetime&#x60;, &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of EventsResponse</returns>
        public async System.Threading.Tasks.Task<EventsResponse> GetEventsAsync (int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string statusId = null, string startDatetime = null, string startDatetimeFrom = null, string startDatetimeTo = null, string endDatetime = null, DateTime? endDatetimeFrom = null, string endDatetimeTo = null, string tenantId = null, string orderBy = null)
        {
             ApiResponse<EventsResponse> localVarResponse = await GetEventsAsyncWithHttpInfo(page, perPage, include, name, typeId, statusId, startDatetime, startDatetimeFrom, startDatetimeTo, endDatetime, endDatetimeFrom, endDatetimeTo, tenantId, orderBy);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get a range of events Returns a list of events. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="startDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;start_datetime&#x60;, &#x60;end_datetime&#x60;, &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (EventsResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<EventsResponse>> GetEventsAsyncWithHttpInfo (int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string statusId = null, string startDatetime = null, string startDatetimeFrom = null, string startDatetimeTo = null, string endDatetime = null, DateTime? endDatetimeFrom = null, string endDatetimeTo = null, string tenantId = null, string orderBy = null)
        {

            var localVarPath = "/events";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (typeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type_id", typeId)); // query parameter
            if (statusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_id", statusId)); // query parameter
            if (startDatetime != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start_datetime", startDatetime)); // query parameter
            if (startDatetimeFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start_datetime_from", startDatetimeFrom)); // query parameter
            if (startDatetimeTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start_datetime_to", startDatetimeTo)); // query parameter
            if (endDatetime != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "end_datetime", endDatetime)); // query parameter
            if (endDatetimeFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "end_datetime_from", endDatetimeFrom)); // query parameter
            if (endDatetimeTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "end_datetime_to", endDatetimeTo)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetEvents", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<EventsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (EventsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(EventsResponse)));
        }

        /// <summary>
        /// Get all events of one asset Returns a list of all events belonging to an asset in your accessible scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="startDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;start_datetime&#x60;, &#x60;end_datetime&#x60;, &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>EventsResponse</returns>
        public EventsResponse GetEventsOfAsset (long? assetId, int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string statusId = null, string startDatetime = null, string startDatetimeFrom = null, string startDatetimeTo = null, string endDatetime = null, DateTime? endDatetimeFrom = null, string endDatetimeTo = null, string tenantId = null, string orderBy = null)
        {
             ApiResponse<EventsResponse> localVarResponse = GetEventsOfAssetWithHttpInfo(assetId, page, perPage, include, name, typeId, statusId, startDatetime, startDatetimeFrom, startDatetimeTo, endDatetime, endDatetimeFrom, endDatetimeTo, tenantId, orderBy);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get all events of one asset Returns a list of all events belonging to an asset in your accessible scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="startDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;start_datetime&#x60;, &#x60;end_datetime&#x60;, &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of EventsResponse</returns>
        public ApiResponse< EventsResponse > GetEventsOfAssetWithHttpInfo (long? assetId, int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string statusId = null, string startDatetime = null, string startDatetimeFrom = null, string startDatetimeTo = null, string endDatetime = null, DateTime? endDatetimeFrom = null, string endDatetimeTo = null, string tenantId = null, string orderBy = null)
        {
            // verify the required parameter 'assetId' is set
            if (assetId == null)
                throw new ApiException(400, "Missing required parameter 'assetId' when calling EventApi->GetEventsOfAsset");

            var localVarPath = "/assets/{asset_id}/events";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (assetId != null) localVarPathParams.Add("asset_id", this.Configuration.ApiClient.ParameterToString(assetId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (typeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type_id", typeId)); // query parameter
            if (statusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_id", statusId)); // query parameter
            if (startDatetime != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start_datetime", startDatetime)); // query parameter
            if (startDatetimeFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start_datetime_from", startDatetimeFrom)); // query parameter
            if (startDatetimeTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start_datetime_to", startDatetimeTo)); // query parameter
            if (endDatetime != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "end_datetime", endDatetime)); // query parameter
            if (endDatetimeFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "end_datetime_from", endDatetimeFrom)); // query parameter
            if (endDatetimeTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "end_datetime_to", endDatetimeTo)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetEventsOfAsset", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<EventsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (EventsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(EventsResponse)));
        }

        /// <summary>
        /// Get all events of one asset Returns a list of all events belonging to an asset in your accessible scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="startDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;start_datetime&#x60;, &#x60;end_datetime&#x60;, &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of EventsResponse</returns>
        public async System.Threading.Tasks.Task<EventsResponse> GetEventsOfAssetAsync (long? assetId, int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string statusId = null, string startDatetime = null, string startDatetimeFrom = null, string startDatetimeTo = null, string endDatetime = null, DateTime? endDatetimeFrom = null, string endDatetimeTo = null, string tenantId = null, string orderBy = null)
        {
             ApiResponse<EventsResponse> localVarResponse = await GetEventsOfAssetAsyncWithHttpInfo(assetId, page, perPage, include, name, typeId, statusId, startDatetime, startDatetimeFrom, startDatetimeTo, endDatetime, endDatetimeFrom, endDatetimeTo, tenantId, orderBy);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get all events of one asset Returns a list of all events belonging to an asset in your accessible scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="assetId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="startDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;start_datetime&#x60;, &#x60;end_datetime&#x60;, &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (EventsResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<EventsResponse>> GetEventsOfAssetAsyncWithHttpInfo (long? assetId, int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string statusId = null, string startDatetime = null, string startDatetimeFrom = null, string startDatetimeTo = null, string endDatetime = null, DateTime? endDatetimeFrom = null, string endDatetimeTo = null, string tenantId = null, string orderBy = null)
        {
            // verify the required parameter 'assetId' is set
            if (assetId == null)
                throw new ApiException(400, "Missing required parameter 'assetId' when calling EventApi->GetEventsOfAsset");

            var localVarPath = "/assets/{asset_id}/events";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (assetId != null) localVarPathParams.Add("asset_id", this.Configuration.ApiClient.ParameterToString(assetId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (typeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type_id", typeId)); // query parameter
            if (statusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_id", statusId)); // query parameter
            if (startDatetime != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start_datetime", startDatetime)); // query parameter
            if (startDatetimeFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start_datetime_from", startDatetimeFrom)); // query parameter
            if (startDatetimeTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start_datetime_to", startDatetimeTo)); // query parameter
            if (endDatetime != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "end_datetime", endDatetime)); // query parameter
            if (endDatetimeFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "end_datetime_from", endDatetimeFrom)); // query parameter
            if (endDatetimeTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "end_datetime_to", endDatetimeTo)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetEventsOfAsset", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<EventsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (EventsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(EventsResponse)));
        }

        /// <summary>
        /// Get all events of one instrumentation Returns a list of all events belonging to an instrumentation in your accessible scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="startDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;start_datetime&#x60;, &#x60;end_datetime&#x60;, &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>EventsResponse</returns>
        public EventsResponse GetEventsOfInstrumentation (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string statusId = null, string startDatetime = null, string startDatetimeFrom = null, string startDatetimeTo = null, string endDatetime = null, DateTime? endDatetimeFrom = null, string endDatetimeTo = null, string tenantId = null, string orderBy = null)
        {
             ApiResponse<EventsResponse> localVarResponse = GetEventsOfInstrumentationWithHttpInfo(instrumentationId, page, perPage, include, name, typeId, statusId, startDatetime, startDatetimeFrom, startDatetimeTo, endDatetime, endDatetimeFrom, endDatetimeTo, tenantId, orderBy);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get all events of one instrumentation Returns a list of all events belonging to an instrumentation in your accessible scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="startDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;start_datetime&#x60;, &#x60;end_datetime&#x60;, &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of EventsResponse</returns>
        public ApiResponse< EventsResponse > GetEventsOfInstrumentationWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string statusId = null, string startDatetime = null, string startDatetimeFrom = null, string startDatetimeTo = null, string endDatetime = null, DateTime? endDatetimeFrom = null, string endDatetimeTo = null, string tenantId = null, string orderBy = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling EventApi->GetEventsOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/events";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (typeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type_id", typeId)); // query parameter
            if (statusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_id", statusId)); // query parameter
            if (startDatetime != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start_datetime", startDatetime)); // query parameter
            if (startDatetimeFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start_datetime_from", startDatetimeFrom)); // query parameter
            if (startDatetimeTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start_datetime_to", startDatetimeTo)); // query parameter
            if (endDatetime != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "end_datetime", endDatetime)); // query parameter
            if (endDatetimeFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "end_datetime_from", endDatetimeFrom)); // query parameter
            if (endDatetimeTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "end_datetime_to", endDatetimeTo)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetEventsOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<EventsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (EventsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(EventsResponse)));
        }

        /// <summary>
        /// Get all events of one instrumentation Returns a list of all events belonging to an instrumentation in your accessible scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="startDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;start_datetime&#x60;, &#x60;end_datetime&#x60;, &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of EventsResponse</returns>
        public async System.Threading.Tasks.Task<EventsResponse> GetEventsOfInstrumentationAsync (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string statusId = null, string startDatetime = null, string startDatetimeFrom = null, string startDatetimeTo = null, string endDatetime = null, DateTime? endDatetimeFrom = null, string endDatetimeTo = null, string tenantId = null, string orderBy = null)
        {
             ApiResponse<EventsResponse> localVarResponse = await GetEventsOfInstrumentationAsyncWithHttpInfo(instrumentationId, page, perPage, include, name, typeId, statusId, startDatetime, startDatetimeFrom, startDatetimeTo, endDatetime, endDatetimeFrom, endDatetimeTo, tenantId, orderBy);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get all events of one instrumentation Returns a list of all events belonging to an instrumentation in your accessible scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;assets, instrumentations, status, type&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrumentationId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="startDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="startDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetime">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="endDatetimeTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;start_datetime&#x60;, &#x60;end_datetime&#x60;, &#x60;id&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (EventsResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<EventsResponse>> GetEventsOfInstrumentationAsyncWithHttpInfo (long? instrumentationId, int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string statusId = null, string startDatetime = null, string startDatetimeFrom = null, string startDatetimeTo = null, string endDatetime = null, DateTime? endDatetimeFrom = null, string endDatetimeTo = null, string tenantId = null, string orderBy = null)
        {
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling EventApi->GetEventsOfInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/events";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (typeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type_id", typeId)); // query parameter
            if (statusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_id", statusId)); // query parameter
            if (startDatetime != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start_datetime", startDatetime)); // query parameter
            if (startDatetimeFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start_datetime_from", startDatetimeFrom)); // query parameter
            if (startDatetimeTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "start_datetime_to", startDatetimeTo)); // query parameter
            if (endDatetime != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "end_datetime", endDatetime)); // query parameter
            if (endDatetimeFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "end_datetime_from", endDatetimeFrom)); // query parameter
            if (endDatetimeTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "end_datetime_to", endDatetimeTo)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetEventsOfInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<EventsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (EventsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(EventsResponse)));
        }

        /// <summary>
        /// Get all instrumentations of one event Returns a list of all instrumentations of an event that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;specifications, specifications[key1,key2], pictures, tenant, parent, status, type, type.tenant, type.parent&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="tag">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="criticality">Filter accepts undefined, low, medium or high (optional)</param>
        /// <param name="accessibility">Filter accepts undefined, easy, moderate or difficult (optional)</param>
        /// <param name="nodeId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all objects with no nodes assigned or \&quot;!null\&quot; for any assigned node (optional)</param>
        /// <param name="assetStatusId">One or multiple ids (comma list). Expected id format is integer. This retrieves all Instrumentations where at least one of its assets has one of the given statuses. (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;tag&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>InstrumentationsResponse</returns>
        public InstrumentationsResponse GetInstrumentationsOfEvent (long? eventId, int? page = null, int? perPage = null, string include = null, string tag = null, string statusId = null, string typeId = null, string parentId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string criticality = null, string accessibility = null, string nodeId = null, string assetStatusId = null, string permission = null, string orderBy = null)
        {
             ApiResponse<InstrumentationsResponse> localVarResponse = GetInstrumentationsOfEventWithHttpInfo(eventId, page, perPage, include, tag, statusId, typeId, parentId, tenantId, specificationsKey, specificationsValue, criticality, accessibility, nodeId, assetStatusId, permission, orderBy);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get all instrumentations of one event Returns a list of all instrumentations of an event that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;specifications, specifications[key1,key2], pictures, tenant, parent, status, type, type.tenant, type.parent&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="tag">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="criticality">Filter accepts undefined, low, medium or high (optional)</param>
        /// <param name="accessibility">Filter accepts undefined, easy, moderate or difficult (optional)</param>
        /// <param name="nodeId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all objects with no nodes assigned or \&quot;!null\&quot; for any assigned node (optional)</param>
        /// <param name="assetStatusId">One or multiple ids (comma list). Expected id format is integer. This retrieves all Instrumentations where at least one of its assets has one of the given statuses. (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;tag&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of InstrumentationsResponse</returns>
        public ApiResponse< InstrumentationsResponse > GetInstrumentationsOfEventWithHttpInfo (long? eventId, int? page = null, int? perPage = null, string include = null, string tag = null, string statusId = null, string typeId = null, string parentId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string criticality = null, string accessibility = null, string nodeId = null, string assetStatusId = null, string permission = null, string orderBy = null)
        {
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling EventApi->GetInstrumentationsOfEvent");

            var localVarPath = "/events/{event_id}/instrumentations";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (tag != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tag", tag)); // query parameter
            if (statusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_id", statusId)); // query parameter
            if (typeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type_id", typeId)); // query parameter
            if (parentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "parent_id", parentId)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (specificationsKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_key", specificationsKey)); // query parameter
            if (specificationsValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_value", specificationsValue)); // query parameter
            if (criticality != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "criticality", criticality)); // query parameter
            if (accessibility != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "accessibility", accessibility)); // query parameter
            if (nodeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "node_id", nodeId)); // query parameter
            if (assetStatusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asset_status_id", assetStatusId)); // query parameter
            if (permission != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "permission", permission)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetInstrumentationsOfEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InstrumentationsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InstrumentationsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InstrumentationsResponse)));
        }

        /// <summary>
        /// Get all instrumentations of one event Returns a list of all instrumentations of an event that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;specifications, specifications[key1,key2], pictures, tenant, parent, status, type, type.tenant, type.parent&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="tag">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="criticality">Filter accepts undefined, low, medium or high (optional)</param>
        /// <param name="accessibility">Filter accepts undefined, easy, moderate or difficult (optional)</param>
        /// <param name="nodeId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all objects with no nodes assigned or \&quot;!null\&quot; for any assigned node (optional)</param>
        /// <param name="assetStatusId">One or multiple ids (comma list). Expected id format is integer. This retrieves all Instrumentations where at least one of its assets has one of the given statuses. (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;tag&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of InstrumentationsResponse</returns>
        public async System.Threading.Tasks.Task<InstrumentationsResponse> GetInstrumentationsOfEventAsync (long? eventId, int? page = null, int? perPage = null, string include = null, string tag = null, string statusId = null, string typeId = null, string parentId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string criticality = null, string accessibility = null, string nodeId = null, string assetStatusId = null, string permission = null, string orderBy = null)
        {
             ApiResponse<InstrumentationsResponse> localVarResponse = await GetInstrumentationsOfEventAsyncWithHttpInfo(eventId, page, perPage, include, tag, statusId, typeId, parentId, tenantId, specificationsKey, specificationsValue, criticality, accessibility, nodeId, assetStatusId, permission, orderBy);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get all instrumentations of one event Returns a list of all instrumentations of an event that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;specifications, specifications[key1,key2], pictures, tenant, parent, status, type, type.tenant, type.parent&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="tag">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="criticality">Filter accepts undefined, low, medium or high (optional)</param>
        /// <param name="accessibility">Filter accepts undefined, easy, moderate or difficult (optional)</param>
        /// <param name="nodeId">One or multiple ids (comma list). Filter acccepts \&quot;null\&quot; for all objects with no nodes assigned or \&quot;!null\&quot; for any assigned node (optional)</param>
        /// <param name="assetStatusId">One or multiple ids (comma list). Expected id format is integer. This retrieves all Instrumentations where at least one of its assets has one of the given statuses. (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;tag&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (InstrumentationsResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InstrumentationsResponse>> GetInstrumentationsOfEventAsyncWithHttpInfo (long? eventId, int? page = null, int? perPage = null, string include = null, string tag = null, string statusId = null, string typeId = null, string parentId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string criticality = null, string accessibility = null, string nodeId = null, string assetStatusId = null, string permission = null, string orderBy = null)
        {
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling EventApi->GetInstrumentationsOfEvent");

            var localVarPath = "/events/{event_id}/instrumentations";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (tag != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tag", tag)); // query parameter
            if (statusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_id", statusId)); // query parameter
            if (typeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type_id", typeId)); // query parameter
            if (parentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "parent_id", parentId)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (specificationsKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_key", specificationsKey)); // query parameter
            if (specificationsValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_value", specificationsValue)); // query parameter
            if (criticality != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "criticality", criticality)); // query parameter
            if (accessibility != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "accessibility", accessibility)); // query parameter
            if (nodeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "node_id", nodeId)); // query parameter
            if (assetStatusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asset_status_id", assetStatusId)); // query parameter
            if (permission != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "permission", permission)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetInstrumentationsOfEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InstrumentationsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InstrumentationsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InstrumentationsResponse)));
        }

        /// <summary>
        /// Get specifications of an event Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>SpecificationsResponse</returns>
        public SpecificationsResponse GetSpecificationsOfEvent (long? eventId, string key = null)
        {
             ApiResponse<SpecificationsResponse> localVarResponse = GetSpecificationsOfEventWithHttpInfo(eventId, key);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get specifications of an event Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>ApiResponse of SpecificationsResponse</returns>
        public ApiResponse< SpecificationsResponse > GetSpecificationsOfEventWithHttpInfo (long? eventId, string key = null)
        {
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling EventApi->GetSpecificationsOfEvent");

            var localVarPath = "/events/{event_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationsOfEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationsResponse)));
        }

        /// <summary>
        /// Get specifications of an event Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of SpecificationsResponse</returns>
        public async System.Threading.Tasks.Task<SpecificationsResponse> GetSpecificationsOfEventAsync (long? eventId, string key = null)
        {
             ApiResponse<SpecificationsResponse> localVarResponse = await GetSpecificationsOfEventAsyncWithHttpInfo(eventId, key);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get specifications of an event Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="eventId">Id of the specified event</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationsResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SpecificationsResponse>> GetSpecificationsOfEventAsyncWithHttpInfo (long? eventId, string key = null)
        {
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling EventApi->GetSpecificationsOfEvent");

            var localVarPath = "/events/{event_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationsOfEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationsResponse)));
        }

        /// <summary>
        /// Remove assets from an event Remove one or more assets from an event. If the event has no more related assets or instrumentations, the event will be deleted
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="eventId">Id of the event where the asset will be removed</param>
        /// <returns></returns>
        public void RemoveAssetsFromEvent (AssetIDs body, long? eventId)
        {
             RemoveAssetsFromEventWithHttpInfo(body, eventId);
        }

        /// <summary>
        /// Remove assets from an event Remove one or more assets from an event. If the event has no more related assets or instrumentations, the event will be deleted
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="eventId">Id of the event where the asset will be removed</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RemoveAssetsFromEventWithHttpInfo (AssetIDs body, long? eventId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling EventApi->RemoveAssetsFromEvent");
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling EventApi->RemoveAssetsFromEvent");

            var localVarPath = "/events/{event_id}/assets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveAssetsFromEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Remove assets from an event Remove one or more assets from an event. If the event has no more related assets or instrumentations, the event will be deleted
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="eventId">Id of the event where the asset will be removed</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveAssetsFromEventAsync (AssetIDs body, long? eventId)
        {
             await RemoveAssetsFromEventAsyncWithHttpInfo(body, eventId);

        }

        /// <summary>
        /// Remove assets from an event Remove one or more assets from an event. If the event has no more related assets or instrumentations, the event will be deleted
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="eventId">Id of the event where the asset will be removed</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RemoveAssetsFromEventAsyncWithHttpInfo (AssetIDs body, long? eventId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling EventApi->RemoveAssetsFromEvent");
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling EventApi->RemoveAssetsFromEvent");

            var localVarPath = "/events/{event_id}/assets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveAssetsFromEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Remove documents from an event Remove one or more documents from an event.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="eventId">Id of the event from which the documents will be removed</param>
        /// <returns></returns>
        public void RemoveDocumentsFromEvent (DocumentIDs body, long? eventId)
        {
             RemoveDocumentsFromEventWithHttpInfo(body, eventId);
        }

        /// <summary>
        /// Remove documents from an event Remove one or more documents from an event.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="eventId">Id of the event from which the documents will be removed</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RemoveDocumentsFromEventWithHttpInfo (DocumentIDs body, long? eventId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling EventApi->RemoveDocumentsFromEvent");
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling EventApi->RemoveDocumentsFromEvent");

            var localVarPath = "/events/{event_id}/documents";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveDocumentsFromEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Remove documents from an event Remove one or more documents from an event.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="eventId">Id of the event from which the documents will be removed</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveDocumentsFromEventAsync (DocumentIDs body, long? eventId)
        {
             await RemoveDocumentsFromEventAsyncWithHttpInfo(body, eventId);

        }

        /// <summary>
        /// Remove documents from an event Remove one or more documents from an event.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="eventId">Id of the event from which the documents will be removed</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RemoveDocumentsFromEventAsyncWithHttpInfo (DocumentIDs body, long? eventId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling EventApi->RemoveDocumentsFromEvent");
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling EventApi->RemoveDocumentsFromEvent");

            var localVarPath = "/events/{event_id}/documents";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveDocumentsFromEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Remove events from an asset Remove one or more events from an asset in your accessible scope. If the event has no more related assets, the event will be deleted
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="assetId">Id of the asset from which the events will removed.</param>
        /// <returns></returns>
        public void RemoveEventFromAsset (Events body, long? assetId)
        {
             RemoveEventFromAssetWithHttpInfo(body, assetId);
        }

        /// <summary>
        /// Remove events from an asset Remove one or more events from an asset in your accessible scope. If the event has no more related assets, the event will be deleted
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="assetId">Id of the asset from which the events will removed.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RemoveEventFromAssetWithHttpInfo (Events body, long? assetId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling EventApi->RemoveEventFromAsset");
            // verify the required parameter 'assetId' is set
            if (assetId == null)
                throw new ApiException(400, "Missing required parameter 'assetId' when calling EventApi->RemoveEventFromAsset");

            var localVarPath = "/assets/{asset_id}/events";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (assetId != null) localVarPathParams.Add("asset_id", this.Configuration.ApiClient.ParameterToString(assetId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveEventFromAsset", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Remove events from an asset Remove one or more events from an asset in your accessible scope. If the event has no more related assets, the event will be deleted
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="assetId">Id of the asset from which the events will removed.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveEventFromAssetAsync (Events body, long? assetId)
        {
             await RemoveEventFromAssetAsyncWithHttpInfo(body, assetId);

        }

        /// <summary>
        /// Remove events from an asset Remove one or more events from an asset in your accessible scope. If the event has no more related assets, the event will be deleted
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="assetId">Id of the asset from which the events will removed.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RemoveEventFromAssetAsyncWithHttpInfo (Events body, long? assetId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling EventApi->RemoveEventFromAsset");
            // verify the required parameter 'assetId' is set
            if (assetId == null)
                throw new ApiException(400, "Missing required parameter 'assetId' when calling EventApi->RemoveEventFromAsset");

            var localVarPath = "/assets/{asset_id}/events";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (assetId != null) localVarPathParams.Add("asset_id", this.Configuration.ApiClient.ParameterToString(assetId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveEventFromAsset", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Remove events from an instrumentation Remove one or more events from an instrumentation in your accessible scope. If the event has no more related instrumentations, the event will be deleted
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the events will removed.</param>
        /// <returns></returns>
        public void RemoveEventFromInstrumentation (Events1 body, long? instrumentationId)
        {
             RemoveEventFromInstrumentationWithHttpInfo(body, instrumentationId);
        }

        /// <summary>
        /// Remove events from an instrumentation Remove one or more events from an instrumentation in your accessible scope. If the event has no more related instrumentations, the event will be deleted
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the events will removed.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RemoveEventFromInstrumentationWithHttpInfo (Events1 body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling EventApi->RemoveEventFromInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling EventApi->RemoveEventFromInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/events";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveEventFromInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Remove events from an instrumentation Remove one or more events from an instrumentation in your accessible scope. If the event has no more related instrumentations, the event will be deleted
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the events will removed.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveEventFromInstrumentationAsync (Events1 body, long? instrumentationId)
        {
             await RemoveEventFromInstrumentationAsyncWithHttpInfo(body, instrumentationId);

        }

        /// <summary>
        /// Remove events from an instrumentation Remove one or more events from an instrumentation in your accessible scope. If the event has no more related instrumentations, the event will be deleted
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="instrumentationId">Id of the instrumentation from which the events will removed.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RemoveEventFromInstrumentationAsyncWithHttpInfo (Events1 body, long? instrumentationId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling EventApi->RemoveEventFromInstrumentation");
            // verify the required parameter 'instrumentationId' is set
            if (instrumentationId == null)
                throw new ApiException(400, "Missing required parameter 'instrumentationId' when calling EventApi->RemoveEventFromInstrumentation");

            var localVarPath = "/instrumentations/{instrumentation_id}/events";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (instrumentationId != null) localVarPathParams.Add("instrumentation_id", this.Configuration.ApiClient.ParameterToString(instrumentationId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveEventFromInstrumentation", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Remove instrumentations from an event Remove one or more instrumentations from an event. If the event has no more related instrumentations or assets, the event will be deleted
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="eventId">Id of the event where the instrumentation will be removed</param>
        /// <returns></returns>
        public void RemoveInstrumentationsFromEvent (InstrumentationIDs body, long? eventId)
        {
             RemoveInstrumentationsFromEventWithHttpInfo(body, eventId);
        }

        /// <summary>
        /// Remove instrumentations from an event Remove one or more instrumentations from an event. If the event has no more related instrumentations or assets, the event will be deleted
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="eventId">Id of the event where the instrumentation will be removed</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RemoveInstrumentationsFromEventWithHttpInfo (InstrumentationIDs body, long? eventId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling EventApi->RemoveInstrumentationsFromEvent");
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling EventApi->RemoveInstrumentationsFromEvent");

            var localVarPath = "/events/{event_id}/instrumentations";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveInstrumentationsFromEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Remove instrumentations from an event Remove one or more instrumentations from an event. If the event has no more related instrumentations or assets, the event will be deleted
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="eventId">Id of the event where the instrumentation will be removed</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveInstrumentationsFromEventAsync (InstrumentationIDs body, long? eventId)
        {
             await RemoveInstrumentationsFromEventAsyncWithHttpInfo(body, eventId);

        }

        /// <summary>
        /// Remove instrumentations from an event Remove one or more instrumentations from an event. If the event has no more related instrumentations or assets, the event will be deleted
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="eventId">Id of the event where the instrumentation will be removed</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RemoveInstrumentationsFromEventAsyncWithHttpInfo (InstrumentationIDs body, long? eventId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling EventApi->RemoveInstrumentationsFromEvent");
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling EventApi->RemoveInstrumentationsFromEvent");

            var localVarPath = "/events/{event_id}/instrumentations";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveInstrumentationsFromEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete specifications of an event The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="eventId">Id of the specified event</param>
        /// <returns></returns>
        public void RemoveSpecificationsFromEvent (List<string> body, long? eventId)
        {
             RemoveSpecificationsFromEventWithHttpInfo(body, eventId);
        }

        /// <summary>
        /// Delete specifications of an event The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="eventId">Id of the specified event</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RemoveSpecificationsFromEventWithHttpInfo (List<string> body, long? eventId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling EventApi->RemoveSpecificationsFromEvent");
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling EventApi->RemoveSpecificationsFromEvent");

            var localVarPath = "/events/{event_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveSpecificationsFromEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete specifications of an event The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="eventId">Id of the specified event</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveSpecificationsFromEventAsync (List<string> body, long? eventId)
        {
             await RemoveSpecificationsFromEventAsyncWithHttpInfo(body, eventId);

        }

        /// <summary>
        /// Delete specifications of an event The specification keys in the body will be removed of the object in your accessible scope. Multiple specification keys can be sent in the same request. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="eventId">Id of the specified event</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RemoveSpecificationsFromEventAsyncWithHttpInfo (List<string> body, long? eventId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling EventApi->RemoveSpecificationsFromEvent");
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling EventApi->RemoveSpecificationsFromEvent");

            var localVarPath = "/events/{event_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveSpecificationsFromEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of an event in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="eventId">Id of the specified node</param>
        /// <returns></returns>
        public void RenameSpecificationsOfEvent (SpecificationsRename body, long? eventId)
        {
             RenameSpecificationsOfEventWithHttpInfo(body, eventId);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of an event in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="eventId">Id of the specified node</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RenameSpecificationsOfEventWithHttpInfo (SpecificationsRename body, long? eventId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling EventApi->RenameSpecificationsOfEvent");
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling EventApi->RenameSpecificationsOfEvent");

            var localVarPath = "/events/{event_id}/specifications/rename";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RenameSpecificationsOfEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of an event in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="eventId">Id of the specified node</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RenameSpecificationsOfEventAsync (SpecificationsRename body, long? eventId)
        {
             await RenameSpecificationsOfEventAsyncWithHttpInfo(body, eventId);

        }

        /// <summary>
        /// Rename a specification key Rename one specification key of an event in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="eventId">Id of the specified node</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RenameSpecificationsOfEventAsyncWithHttpInfo (SpecificationsRename body, long? eventId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling EventApi->RenameSpecificationsOfEvent");
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling EventApi->RenameSpecificationsOfEvent");

            var localVarPath = "/events/{event_id}/specifications/rename";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RenameSpecificationsOfEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Replace the documents of an event Replaces all documents belonging to an event. You can send a list of resources that will replace all previous values.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="eventId">Id of the event of which the documents will be replaced</param>
        /// <returns></returns>
        public void ReplaceDocumentsOfEvent (DocumentIDs body, long? eventId)
        {
             ReplaceDocumentsOfEventWithHttpInfo(body, eventId);
        }

        /// <summary>
        /// Replace the documents of an event Replaces all documents belonging to an event. You can send a list of resources that will replace all previous values.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="eventId">Id of the event of which the documents will be replaced</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReplaceDocumentsOfEventWithHttpInfo (DocumentIDs body, long? eventId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling EventApi->ReplaceDocumentsOfEvent");
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling EventApi->ReplaceDocumentsOfEvent");

            var localVarPath = "/events/{event_id}/documents";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceDocumentsOfEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Replace the documents of an event Replaces all documents belonging to an event. You can send a list of resources that will replace all previous values.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="eventId">Id of the event of which the documents will be replaced</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task ReplaceDocumentsOfEventAsync (DocumentIDs body, long? eventId)
        {
             await ReplaceDocumentsOfEventAsyncWithHttpInfo(body, eventId);

        }

        /// <summary>
        /// Replace the documents of an event Replaces all documents belonging to an event. You can send a list of resources that will replace all previous values.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="eventId">Id of the event of which the documents will be replaced</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> ReplaceDocumentsOfEventAsyncWithHttpInfo (DocumentIDs body, long? eventId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling EventApi->ReplaceDocumentsOfEvent");
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling EventApi->ReplaceDocumentsOfEvent");

            var localVarPath = "/events/{event_id}/documents";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceDocumentsOfEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update an event Update accessible parameters of the requested resource.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the event to update</param>
        /// <returns></returns>
        public void UpdateEvent (EventRequest body, long? id)
        {
             UpdateEventWithHttpInfo(body, id);
        }

        /// <summary>
        /// Update an event Update accessible parameters of the requested resource.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the event to update</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateEventWithHttpInfo (EventRequest body, long? id)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling EventApi->UpdateEvent");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling EventApi->UpdateEvent");

            var localVarPath = "/events/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update an event Update accessible parameters of the requested resource.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the event to update</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UpdateEventAsync (EventRequest body, long? id)
        {
             await UpdateEventAsyncWithHttpInfo(body, id);

        }

        /// <summary>
        /// Update an event Update accessible parameters of the requested resource.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the event to update</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> UpdateEventAsyncWithHttpInfo (EventRequest body, long? id)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling EventApi->UpdateEvent");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling EventApi->UpdateEvent");

            var localVarPath = "/events/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update specifications of an event Update the specification object of an event in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of a-z A-Z 0-9 . - _ all uppercase A-Z are converted to lower-case a-z. For a key that is send mutliple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="eventId">Id of the specified event</param>
        /// <returns></returns>
        public void UpdateSpecificationsOfEvent (Dictionary<string, SpecificationRequest> body, long? eventId)
        {
             UpdateSpecificationsOfEventWithHttpInfo(body, eventId);
        }

        /// <summary>
        /// Update specifications of an event Update the specification object of an event in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of a-z A-Z 0-9 . - _ all uppercase A-Z are converted to lower-case a-z. For a key that is send mutliple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="eventId">Id of the specified event</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateSpecificationsOfEventWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? eventId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling EventApi->UpdateSpecificationsOfEvent");
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling EventApi->UpdateSpecificationsOfEvent");

            var localVarPath = "/events/{event_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSpecificationsOfEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update specifications of an event Update the specification object of an event in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of a-z A-Z 0-9 . - _ all uppercase A-Z are converted to lower-case a-z. For a key that is send mutliple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="eventId">Id of the specified event</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UpdateSpecificationsOfEventAsync (Dictionary<string, SpecificationRequest> body, long? eventId)
        {
             await UpdateSpecificationsOfEventAsyncWithHttpInfo(body, eventId);

        }

        /// <summary>
        /// Update specifications of an event Update the specification object of an event in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of a-z A-Z 0-9 . - _ all uppercase A-Z are converted to lower-case a-z. For a key that is send mutliple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="eventId">Id of the specified event</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSpecificationsOfEventAsyncWithHttpInfo (Dictionary<string, SpecificationRequest> body, long? eventId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling EventApi->UpdateSpecificationsOfEvent");
            // verify the required parameter 'eventId' is set
            if (eventId == null)
                throw new ApiException(400, "Missing required parameter 'eventId' when calling EventApi->UpdateSpecificationsOfEvent");

            var localVarPath = "/events/{event_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (eventId != null) localVarPathParams.Add("event_id", this.Configuration.ApiClient.ParameterToString(eventId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSpecificationsOfEvent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

    }
}
