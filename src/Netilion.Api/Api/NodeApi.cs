/* 
 * Netilion API Documentation
 *
 * Welcome to the Netilion API Documentation, which provides interactive access and documentation to our REST API. Please visit our developer portal for further instructions and information: https://developer.netilion.endress.com/ 
 *
 * OpenAPI spec version: 01.00.00
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using Netilion.Api.Client;
using Netilion.Api.Model;

namespace Netilion.Api.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
        public interface INodeApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Add assets to a node
        /// </summary>
        /// <remarks>
        /// Add one or more assets to a node. This action requires &#x60;can_permit&#x60; permission on the node and on the asset.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the assets will be added</param>
        /// <returns></returns>
        void AddAssetsToNode (AssetIDs body, long? nodeId);

        /// <summary>
        /// Add assets to a node
        /// </summary>
        /// <remarks>
        /// Add one or more assets to a node. This action requires &#x60;can_permit&#x60; permission on the node and on the asset.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the assets will be added</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> AddAssetsToNodeWithHttpInfo (AssetIDs body, long? nodeId);
        /// <summary>
        /// Add documents to a node
        /// </summary>
        /// <remarks>
        /// Add one or more documents to a node. This action requires &#x60;can_update&#x60; permission on the node and &#x60;can_read&#x60; permission on the document.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the documents will be added</param>
        /// <returns></returns>
        void AddDocumentsToNode (DocumentIDs body, long? nodeId);

        /// <summary>
        /// Add documents to a node
        /// </summary>
        /// <remarks>
        /// Add one or more documents to a node. This action requires &#x60;can_update&#x60; permission on the node and &#x60;can_read&#x60; permission on the document.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the documents will be added</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> AddDocumentsToNodeWithHttpInfo (DocumentIDs body, long? nodeId);
        /// <summary>
        /// Add instrumentations to a node
        /// </summary>
        /// <remarks>
        /// Add one or more instrumentations to a node. This action requires &#x60;can_permit&#x60; permission on the node and on the instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the instrumentations will be added</param>
        /// <returns></returns>
        void AddInstrumentationsToNode (InstrumentationIDs body, long? nodeId);

        /// <summary>
        /// Add instrumentations to a node
        /// </summary>
        /// <remarks>
        /// Add one or more instrumentations to a node. This action requires &#x60;can_permit&#x60; permission on the node and on the instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the instrumentations will be added</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> AddInstrumentationsToNodeWithHttpInfo (InstrumentationIDs body, long? nodeId);
        /// <summary>
        /// Add a link as node picture
        /// </summary>
        /// <remarks>
        /// Add an external resource as node picture.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Picture link object to be created</param>
        /// <param name="id">Id of the node</param>
        /// <returns>PictureResponse</returns>
        PictureResponse AddNodePictureLink (PictureLinkRequest body, long? id);

        /// <summary>
        /// Add a link as node picture
        /// </summary>
        /// <remarks>
        /// Add an external resource as node picture.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Picture link object to be created</param>
        /// <param name="id">Id of the node</param>
        /// <returns>ApiResponse of PictureResponse</returns>
        ApiResponse<PictureResponse> AddNodePictureLinkWithHttpInfo (PictureLinkRequest body, long? id);
        /// <summary>
        /// Add recipes to a node
        /// </summary>
        /// <remarks>
        /// Add one or more recipes to a node. This action requires &#x60;can_permit&#x60; permission on the node and on the recipe.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the recipes will be added</param>
        /// <returns></returns>
        void AddRecipesToNode (RecipeIDs body, long? nodeId);

        /// <summary>
        /// Add recipes to a node
        /// </summary>
        /// <remarks>
        /// Add one or more recipes to a node. This action requires &#x60;can_permit&#x60; permission on the node and on the recipe.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the recipes will be added</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> AddRecipesToNodeWithHttpInfo (RecipeIDs body, long? nodeId);
        /// <summary>
        /// Add systems to a node
        /// </summary>
        /// <remarks>
        /// Add one or more systems to a node. This action requires &#x60;can_permit&#x60; permission on the node and on the system.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the systems will be added</param>
        /// <returns></returns>
        void AddSystemsToNode (SystemIDs body, long? nodeId);

        /// <summary>
        /// Add systems to a node
        /// </summary>
        /// <remarks>
        /// Add one or more systems to a node. This action requires &#x60;can_permit&#x60; permission on the node and on the system.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the systems will be added</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> AddSystemsToNodeWithHttpInfo (SystemIDs body, long? nodeId);
        /// <summary>
        /// Create a new node
        /// </summary>
        /// <remarks>
        /// Create a new node. The name of the given node needs to be unique within its parent. The node will not be created when this constraint is violated. To assign a parent node the user needs &#x60;can_permit&#x60; permission on the parent.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object body that will be created. Name, node status and node type are required</param>
        /// <returns>NodeResponse</returns>
        NodeResponse CreateNodes (NodeRequest body);

        /// <summary>
        /// Create a new node
        /// </summary>
        /// <remarks>
        /// Create a new node. The name of the given node needs to be unique within its parent. The node will not be created when this constraint is violated. To assign a parent node the user needs &#x60;can_permit&#x60; permission on the parent.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object body that will be created. Name, node status and node type are required</param>
        /// <returns>ApiResponse of NodeResponse</returns>
        ApiResponse<NodeResponse> CreateNodesWithHttpInfo (NodeRequest body);
        /// <summary>
        /// Delete a node
        /// </summary>
        /// <remarks>
        /// Delete a specific resource in your accessible scope, identified by the id in the URL.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the node to delete</param>
        /// <returns></returns>
        void DeleteNode (long? id);

        /// <summary>
        /// Delete a node
        /// </summary>
        /// <remarks>
        /// Delete a specific resource in your accessible scope, identified by the id in the URL.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the node to delete</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteNodeWithHttpInfo (long? id);
        /// <summary>
        /// Delete an node picture
        /// </summary>
        /// <remarks>
        /// Delete an node picture.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns></returns>
        void DeleteNodePicture (long? nodeId, long? id);

        /// <summary>
        /// Delete an node picture
        /// </summary>
        /// <remarks>
        /// Delete an node picture.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteNodePictureWithHttpInfo (long? nodeId, long? id);
        /// <summary>
        /// Download an node picture
        /// </summary>
        /// <remarks>
        /// Download an node picture.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns></returns>
        void DownloadNodePicture (long? nodeId, long? id);

        /// <summary>
        /// Download an node picture
        /// </summary>
        /// <remarks>
        /// Download an node picture.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DownloadNodePictureWithHttpInfo (long? nodeId, long? id);
        /// <summary>
        /// Get all assets of one node
        /// </summary>
        /// <remarks>
        /// Returns a list of all assets that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;status, tenant, parent, pictures, product, product.manufacturer, product.pictures, product.status, product.categories, product.categories.parent, specifications, specifications[key1,key2], product.tenant,                             product.manufacturer.tenant, status.tenant, instrumentations &#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="serialNumber">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productCategoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="manufacturerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusCode">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productionDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="ownershipClaimed">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;serial_number&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, &#x60;last_seen_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>AssetsResponse</returns>
        AssetsResponse GetAssetsOfNode (long? nodeId, int? page = null, int? perPage = null, string include = null, string serialNumber = null, string productId = null, string productCategoryId = null, string parentId = null, string manufacturerId = null, string statusId = null, string statusCode = null, DateTime? productionDate = null, DateTime? productionDateFrom = null, DateTime? productionDateTo = null, string specificationsKey = null, string specificationsValue = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, bool? ownershipClaimed = null, string permission = null, string orderBy = null);

        /// <summary>
        /// Get all assets of one node
        /// </summary>
        /// <remarks>
        /// Returns a list of all assets that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;status, tenant, parent, pictures, product, product.manufacturer, product.pictures, product.status, product.categories, product.categories.parent, specifications, specifications[key1,key2], product.tenant,                             product.manufacturer.tenant, status.tenant, instrumentations &#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="serialNumber">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productCategoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="manufacturerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusCode">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productionDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="ownershipClaimed">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;serial_number&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, &#x60;last_seen_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of AssetsResponse</returns>
        ApiResponse<AssetsResponse> GetAssetsOfNodeWithHttpInfo (long? nodeId, int? page = null, int? perPage = null, string include = null, string serialNumber = null, string productId = null, string productCategoryId = null, string parentId = null, string manufacturerId = null, string statusId = null, string statusCode = null, DateTime? productionDate = null, DateTime? productionDateFrom = null, DateTime? productionDateTo = null, string specificationsKey = null, string specificationsValue = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, bool? ownershipClaimed = null, string permission = null, string orderBy = null);
        /// <summary>
        /// Get all documents of a node
        /// </summary>
        /// <remarks>
        /// Returns a list of documents. If the query has no matches, the response is an empty list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language. Possible include values: &#x60;&#x60;&#x60;status, tenant, classification, categories, categories.parent, categories.standards, attachments&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="documentVersion">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="number">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="classificationId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="categoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="validFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validUntil">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validAt">Expected date format is YYYY-MM-DD or YYYY-MM or YYYY (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>DocumentsResponse</returns>
        DocumentsResponse GetDocumentsOfNode (long? nodeId, int? page = null, int? perPage = null, string include = null, string name = null, string documentVersion = null, string number = null, string statusId = null, string classificationId = null, string tenantId = null, string categoryId = null, DateTime? validFrom = null, DateTime? validUntil = null, DateTime? validAt = null, string acceptLanguage = null);

        /// <summary>
        /// Get all documents of a node
        /// </summary>
        /// <remarks>
        /// Returns a list of documents. If the query has no matches, the response is an empty list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language. Possible include values: &#x60;&#x60;&#x60;status, tenant, classification, categories, categories.parent, categories.standards, attachments&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="documentVersion">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="number">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="classificationId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="categoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="validFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validUntil">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validAt">Expected date format is YYYY-MM-DD or YYYY-MM or YYYY (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>ApiResponse of DocumentsResponse</returns>
        ApiResponse<DocumentsResponse> GetDocumentsOfNodeWithHttpInfo (long? nodeId, int? page = null, int? perPage = null, string include = null, string name = null, string documentVersion = null, string number = null, string statusId = null, string classificationId = null, string tenantId = null, string categoryId = null, DateTime? validFrom = null, DateTime? validUntil = null, DateTime? validAt = null, string acceptLanguage = null);
        /// <summary>
        /// Get all instrumentations of one node
        /// </summary>
        /// <remarks>
        /// Returns a list of all instrumentations that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;specifications, specifications[key1,key2], pictures, tenant, parent, status, worst_asset_status, type&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="tag">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="criticality">Filter accepts undefined, low, medium or high (optional)</param>
        /// <param name="accessibility">Filter accepts undefined, easy, moderate or difficult (optional)</param>
        /// <param name="assetStatusId">One or multiple ids (comma list). Expected id format is integer. This retrieves all Instrumentations where at least one of its assets has one of the given statuses. (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;tag&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>InstrumentationsResponse</returns>
        InstrumentationsResponse GetInstrumentationsOfNode (long? nodeId, int? page = null, int? perPage = null, string include = null, string tag = null, string statusId = null, string typeId = null, string parentId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string criticality = null, string accessibility = null, string assetStatusId = null, string permission = null, string orderBy = null);

        /// <summary>
        /// Get all instrumentations of one node
        /// </summary>
        /// <remarks>
        /// Returns a list of all instrumentations that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;specifications, specifications[key1,key2], pictures, tenant, parent, status, worst_asset_status, type&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="tag">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="criticality">Filter accepts undefined, low, medium or high (optional)</param>
        /// <param name="accessibility">Filter accepts undefined, easy, moderate or difficult (optional)</param>
        /// <param name="assetStatusId">One or multiple ids (comma list). Expected id format is integer. This retrieves all Instrumentations where at least one of its assets has one of the given statuses. (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;tag&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of InstrumentationsResponse</returns>
        ApiResponse<InstrumentationsResponse> GetInstrumentationsOfNodeWithHttpInfo (long? nodeId, int? page = null, int? perPage = null, string include = null, string tag = null, string statusId = null, string typeId = null, string parentId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string criticality = null, string accessibility = null, string assetStatusId = null, string permission = null, string orderBy = null);
        /// <summary>
        /// Get the type of the specific node
        /// </summary>
        /// <remarks>
        /// Returns the type of the node. Needed if only permission on node but not on tenant. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language. Possible include values: &#x60;&#x60;&#x60;tenant&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>NodeTypeResponse</returns>
        NodeTypeResponse GetNodeIdType (long? nodeId, string include = null, string acceptLanguage = null);

        /// <summary>
        /// Get the type of the specific node
        /// </summary>
        /// <remarks>
        /// Returns the type of the node. Needed if only permission on node but not on tenant. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language. Possible include values: &#x60;&#x60;&#x60;tenant&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>ApiResponse of NodeTypeResponse</returns>
        ApiResponse<NodeTypeResponse> GetNodeIdTypeWithHttpInfo (long? nodeId, string include = null, string acceptLanguage = null);
        /// <summary>
        /// Get an node picture
        /// </summary>
        /// <remarks>
        /// Get a single picture of an node.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>PictureResponse</returns>
        PictureResponse GetNodePicture (long? nodeId, long? id);

        /// <summary>
        /// Get an node picture
        /// </summary>
        /// <remarks>
        /// Get a single picture of an node.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>ApiResponse of PictureResponse</returns>
        ApiResponse<PictureResponse> GetNodePictureWithHttpInfo (long? nodeId, long? id);
        /// <summary>
        /// Get node pictures
        /// </summary>
        /// <remarks>
        /// Get all pictures of an node.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the node</param>
        /// <param name="width">filter by width (optional)</param>
        /// <param name="widthFrom">filter by width_from (optional)</param>
        /// <param name="widthTo">filter by width_to (optional)</param>
        /// <param name="height">filter by height (optional)</param>
        /// <param name="heightFrom">filter by height_from (optional)</param>
        /// <param name="heightTo">filter by height_to (optional)</param>
        /// <returns>PicturesResponse</returns>
        PicturesResponse GetNodePictures (long? id, int? width = null, int? widthFrom = null, int? widthTo = null, int? height = null, int? heightFrom = null, int? heightTo = null);

        /// <summary>
        /// Get node pictures
        /// </summary>
        /// <remarks>
        /// Get all pictures of an node.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the node</param>
        /// <param name="width">filter by width (optional)</param>
        /// <param name="widthFrom">filter by width_from (optional)</param>
        /// <param name="widthTo">filter by width_to (optional)</param>
        /// <param name="height">filter by height (optional)</param>
        /// <param name="heightFrom">filter by height_from (optional)</param>
        /// <param name="heightTo">filter by height_to (optional)</param>
        /// <returns>ApiResponse of PicturesResponse</returns>
        ApiResponse<PicturesResponse> GetNodePicturesWithHttpInfo (long? id, int? width = null, int? widthFrom = null, int? widthTo = null, int? height = null, int? heightFrom = null, int? heightTo = null);
        /// <summary>
        /// Get all possible types of the specified node
        /// </summary>
        /// <remarks>
        /// Returns a list of all possible node types for the specified node. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>NodeTypes</returns>
        NodeTypes GetNodeTypesOptions (long? nodeId, int? page = null, int? perPage = null, string tenantId = null, string name = null, string code = null, string acceptLanguage = null);

        /// <summary>
        /// Get all possible types of the specified node
        /// </summary>
        /// <remarks>
        /// Returns a list of all possible node types for the specified node. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>ApiResponse of NodeTypes</returns>
        ApiResponse<NodeTypes> GetNodeTypesOptionsWithHttpInfo (long? nodeId, int? page = null, int? perPage = null, string tenantId = null, string name = null, string code = null, string acceptLanguage = null);
        /// <summary>
        /// Get a range of nodes
        /// </summary>
        /// <remarks>
        /// Returns a list of nodes in your accessible scope. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;parent, tenant, type, type.parent, specifications, specifications[key1,key2], pictures, instrumentations, instrumentations.specifications, instrumentations.specifications[key1,key2], instrumentations.values, instrumentations.values.unit, instrumentations.values_in_preferred_units, instrumentations.values_in_preferred_units.unit, worst_asset_status&#x60;&#x60;&#x60; Hidden nodes are not returned by default, if the hidden nodes should be included, add \&quot;&#x60;&#x60;&#x60;hidden&#x60;&#x60;&#x60;\&quot; to the include parameter 
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>NodesResponse</returns>
        NodesResponse GetNodes (int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string parentId = null, string tenantId = null, string permission = null, string orderBy = null);

        /// <summary>
        /// Get a range of nodes
        /// </summary>
        /// <remarks>
        /// Returns a list of nodes in your accessible scope. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;parent, tenant, type, type.parent, specifications, specifications[key1,key2], pictures, instrumentations, instrumentations.specifications, instrumentations.specifications[key1,key2], instrumentations.values, instrumentations.values.unit, instrumentations.values_in_preferred_units, instrumentations.values_in_preferred_units.unit, worst_asset_status&#x60;&#x60;&#x60; Hidden nodes are not returned by default, if the hidden nodes should be included, add \&quot;&#x60;&#x60;&#x60;hidden&#x60;&#x60;&#x60;\&quot; to the include parameter 
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of NodesResponse</returns>
        ApiResponse<NodesResponse> GetNodesWithHttpInfo (int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string parentId = null, string tenantId = null, string permission = null, string orderBy = null);
        /// <summary>
        /// Get a single node
        /// </summary>
        /// <remarks>
        /// Get a specific node in your accessible scope, identified by the id in the URL.  Possible include values: &#x60;&#x60;&#x60;parent, tenant, type, specifications, specifications[key1,key2], pictures, instrumentations, instrumentations.specifications, instrumentations.specifications[key1,key2], instrumentations.values, instrumentations.values.unit, instrumentations.values_in_preferred_units, instrumentations.values_in_preferred_units.unit, worst_asset_status&#x60;&#x60;&#x60; 
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the node to fetch</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <returns>NodeResponse</returns>
        NodeResponse GetNodesById (long? id, string include = null);

        /// <summary>
        /// Get a single node
        /// </summary>
        /// <remarks>
        /// Get a specific node in your accessible scope, identified by the id in the URL.  Possible include values: &#x60;&#x60;&#x60;parent, tenant, type, specifications, specifications[key1,key2], pictures, instrumentations, instrumentations.specifications, instrumentations.specifications[key1,key2], instrumentations.values, instrumentations.values.unit, instrumentations.values_in_preferred_units, instrumentations.values_in_preferred_units.unit, worst_asset_status&#x60;&#x60;&#x60; 
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the node to fetch</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <returns>ApiResponse of NodeResponse</returns>
        ApiResponse<NodeResponse> GetNodesByIdWithHttpInfo (long? id, string include = null);
        /// <summary>
        /// Get all recipes of one node
        /// </summary>
        /// <remarks>
        /// Returns a list of all recipes that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;Possible include values: pictures, specifications, specifications[key1,key2], tenant, status, type, type.tenant, type.parent &#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>RecipesResponse</returns>
        RecipesResponse GetRecipesOfNode (long? nodeId, int? page = null, int? perPage = null, string include = null, string name = null, string statusId = null, string typeId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string orderBy = null);

        /// <summary>
        /// Get all recipes of one node
        /// </summary>
        /// <remarks>
        /// Returns a list of all recipes that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;Possible include values: pictures, specifications, specifications[key1,key2], tenant, status, type, type.tenant, type.parent &#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of RecipesResponse</returns>
        ApiResponse<RecipesResponse> GetRecipesOfNodeWithHttpInfo (long? nodeId, int? page = null, int? perPage = null, string include = null, string name = null, string statusId = null, string typeId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string orderBy = null);
        /// <summary>
        /// Get existing asset specification keys
        /// </summary>
        /// <remarks>
        /// Returns the existing specification keys in all readable nodes.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>SpecificationKeys</returns>
        SpecificationKeys GetSpecificationKeysOfNodes (string key = null, bool? uiVisible = null);

        /// <summary>
        /// Get existing asset specification keys
        /// </summary>
        /// <remarks>
        /// Returns the existing specification keys in all readable nodes.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>ApiResponse of SpecificationKeys</returns>
        ApiResponse<SpecificationKeys> GetSpecificationKeysOfNodesWithHttpInfo (string key = null, bool? uiVisible = null);
        /// <summary>
        /// Get specifications of a node
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the specified node</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>SpecificationsUIVisibleResponse</returns>
        SpecificationsUIVisibleResponse GetSpecificationsOfNode (long? nodeId, string key = null, bool? uiVisible = null);

        /// <summary>
        /// Get specifications of a node
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the specified node</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>ApiResponse of SpecificationsUIVisibleResponse</returns>
        ApiResponse<SpecificationsUIVisibleResponse> GetSpecificationsOfNodeWithHttpInfo (long? nodeId, string key = null, bool? uiVisible = null);
        /// <summary>
        /// Get all systems of one node
        /// </summary>
        /// <remarks>
        /// Returns a list of all systems that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;pictures, specifications, specifications[key1,key2], tenant, parent, status, type, type.tenant, type.parent, worst_asset_status &#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>SystemsResponse</returns>
        SystemsResponse GetSystemsOfNode (long? nodeId, int? page = null, int? perPage = null, string include = null, string name = null, string statusId = null, string typeId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string permission = null, string orderBy = null);

        /// <summary>
        /// Get all systems of one node
        /// </summary>
        /// <remarks>
        /// Returns a list of all systems that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;pictures, specifications, specifications[key1,key2], tenant, parent, status, type, type.tenant, type.parent, worst_asset_status &#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of SystemsResponse</returns>
        ApiResponse<SystemsResponse> GetSystemsOfNodeWithHttpInfo (long? nodeId, int? page = null, int? perPage = null, string include = null, string name = null, string statusId = null, string typeId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string permission = null, string orderBy = null);
        /// <summary>
        /// Remove assets from a node
        /// </summary>
        /// <remarks>
        /// Remove one or more assets from a node in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the node and on the asset.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the assets will be removed</param>
        /// <returns></returns>
        void RemoveAssetsFromNode (AssetIDs body, long? nodeId);

        /// <summary>
        /// Remove assets from a node
        /// </summary>
        /// <remarks>
        /// Remove one or more assets from a node in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the node and on the asset.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the assets will be removed</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveAssetsFromNodeWithHttpInfo (AssetIDs body, long? nodeId);
        /// <summary>
        /// Remove documents from a node
        /// </summary>
        /// <remarks>
        /// Remove one or more documents from a node. This action requires &#x60;can_update&#x60; permission on the node and &#x60;can_read&#x60; permission on the document.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the documents will be removed</param>
        /// <returns></returns>
        void RemoveDocumentsFromNode (DocumentIDs body, long? nodeId);

        /// <summary>
        /// Remove documents from a node
        /// </summary>
        /// <remarks>
        /// Remove one or more documents from a node. This action requires &#x60;can_update&#x60; permission on the node and &#x60;can_read&#x60; permission on the document.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the documents will be removed</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveDocumentsFromNodeWithHttpInfo (DocumentIDs body, long? nodeId);
        /// <summary>
        /// Remove instrumentations from a node
        /// </summary>
        /// <remarks>
        /// Remove one or more instrumentations from a node in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the node and on the instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the instrumentations will be removed</param>
        /// <returns></returns>
        void RemoveInstrumentationsFromNode (InstrumentationIDs body, long? nodeId);

        /// <summary>
        /// Remove instrumentations from a node
        /// </summary>
        /// <remarks>
        /// Remove one or more instrumentations from a node in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the node and on the instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the instrumentations will be removed</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveInstrumentationsFromNodeWithHttpInfo (InstrumentationIDs body, long? nodeId);
        /// <summary>
        /// Remove recipes from a node
        /// </summary>
        /// <remarks>
        /// Remove one or more recipes from a node in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the node and on the recipe.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the recipes will be removed</param>
        /// <returns></returns>
        void RemoveRecipesFromNode (RecipeIDs body, long? nodeId);

        /// <summary>
        /// Remove recipes from a node
        /// </summary>
        /// <remarks>
        /// Remove one or more recipes from a node in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the node and on the recipe.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the recipes will be removed</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveRecipesFromNodeWithHttpInfo (RecipeIDs body, long? nodeId);
        /// <summary>
        /// Delete specifications of a node
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns></returns>
        void RemoveSpecificationsFromNode (List<string> body, long? nodeId);

        /// <summary>
        /// Delete specifications of a node
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveSpecificationsFromNodeWithHttpInfo (List<string> body, long? nodeId);
        /// <summary>
        /// Remove systems from a node
        /// </summary>
        /// <remarks>
        /// Remove one or more systems from a node in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the node and on the system.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the systems will be removed</param>
        /// <returns></returns>
        void RemoveSystemsFromNode (SystemIDs body, long? nodeId);

        /// <summary>
        /// Remove systems from a node
        /// </summary>
        /// <remarks>
        /// Remove one or more systems from a node in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the node and on the system.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the systems will be removed</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveSystemsFromNodeWithHttpInfo (SystemIDs body, long? nodeId);
        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of a node in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns></returns>
        void RenameSpecificationsOfNode (SpecificationsRename body, long? nodeId);

        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of a node in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RenameSpecificationsOfNodeWithHttpInfo (SpecificationsRename body, long? nodeId);
        /// <summary>
        /// Replace the assets of a node
        /// </summary>
        /// <remarks>
        /// Replaces all assets belonging to a node in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the node and on the asset.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the assets will be replaced</param>
        /// <returns></returns>
        void ReplaceAssetsOfNode (AssetIDs body, long? nodeId);

        /// <summary>
        /// Replace the assets of a node
        /// </summary>
        /// <remarks>
        /// Replaces all assets belonging to a node in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the node and on the asset.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the assets will be replaced</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReplaceAssetsOfNodeWithHttpInfo (AssetIDs body, long? nodeId);
        /// <summary>
        /// Replace the documents of a node
        /// </summary>
        /// <remarks>
        /// Replaces all documents belonging to a node. You can send a list of resources that will replace all previous values. This action requires &#x60;can_update&#x60; permission on the node and &#x60;can_read&#x60; permission on the document.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the documents will be replaced</param>
        /// <returns></returns>
        void ReplaceDocumentsOfNode (DocumentIDs body, long? nodeId);

        /// <summary>
        /// Replace the documents of a node
        /// </summary>
        /// <remarks>
        /// Replaces all documents belonging to a node. You can send a list of resources that will replace all previous values. This action requires &#x60;can_update&#x60; permission on the node and &#x60;can_read&#x60; permission on the document.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the documents will be replaced</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReplaceDocumentsOfNodeWithHttpInfo (DocumentIDs body, long? nodeId);
        /// <summary>
        /// Replace the instrumentations of a node
        /// </summary>
        /// <remarks>
        /// Replaces all instrumentations belonging to a node in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the node and on the instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the instrumentations will be replaced</param>
        /// <returns></returns>
        void ReplaceInstrumentationsOfNode (InstrumentationIDs body, long? nodeId);

        /// <summary>
        /// Replace the instrumentations of a node
        /// </summary>
        /// <remarks>
        /// Replaces all instrumentations belonging to a node in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the node and on the instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the instrumentations will be replaced</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReplaceInstrumentationsOfNodeWithHttpInfo (InstrumentationIDs body, long? nodeId);
        /// <summary>
        /// Replace the recipes of a node
        /// </summary>
        /// <remarks>
        /// Replaces all recipes belonging to a node in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the node and on the recipe.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the recipes will be replaced</param>
        /// <returns></returns>
        void ReplaceRecipesOfNode (RecipeIDs body, long? nodeId);

        /// <summary>
        /// Replace the recipes of a node
        /// </summary>
        /// <remarks>
        /// Replaces all recipes belonging to a node in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the node and on the recipe.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the recipes will be replaced</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReplaceRecipesOfNodeWithHttpInfo (RecipeIDs body, long? nodeId);
        /// <summary>
        /// Replace the systems of a node
        /// </summary>
        /// <remarks>
        /// Replaces all systems belonging to a node in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the node and on the system.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the systems will be replaced</param>
        /// <returns></returns>
        void ReplaceSystemsOfNode (SystemIDs body, long? nodeId);

        /// <summary>
        /// Replace the systems of a node
        /// </summary>
        /// <remarks>
        /// Replaces all systems belonging to a node in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the node and on the system.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the systems will be replaced</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReplaceSystemsOfNodeWithHttpInfo (SystemIDs body, long? nodeId);
        /// <summary>
        /// Update a node
        /// </summary>
        /// <remarks>
        /// Update accessible parameters of the requested resource in your accessible scope. To assign a parent node the user needs &#x60;can_permit&#x60; permission on the parent and on the current node.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the node to update</param>
        /// <returns></returns>
        void UpdateNode (NodeRequest body, long? id);

        /// <summary>
        /// Update a node
        /// </summary>
        /// <remarks>
        /// Update accessible parameters of the requested resource in your accessible scope. To assign a parent node the user needs &#x60;can_permit&#x60; permission on the parent and on the current node.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the node to update</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateNodeWithHttpInfo (NodeRequest body, long? id);
        /// <summary>
        /// Update an node picture
        /// </summary>
        /// <remarks>
        /// Upload a new node picture. Check the file-storage quota. Allowed content-types are - image/gif - image/jpg - image/jpeg - image/png
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="image"></param>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>PictureResponse</returns>
        PictureResponse UpdateNodePicture (byte[] image, long? nodeId, long? id);

        /// <summary>
        /// Update an node picture
        /// </summary>
        /// <remarks>
        /// Upload a new node picture. Check the file-storage quota. Allowed content-types are - image/gif - image/jpg - image/jpeg - image/png
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="image"></param>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>ApiResponse of PictureResponse</returns>
        ApiResponse<PictureResponse> UpdateNodePictureWithHttpInfo (byte[] image, long? nodeId, long? id);
        /// <summary>
        /// Update a node picture link
        /// </summary>
        /// <remarks>
        /// Update a node picture link.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Picture link object to be updated</param>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>PictureResponse</returns>
        PictureResponse UpdateNodePictureLink (PictureLinkRequest body, long? nodeId, long? id);

        /// <summary>
        /// Update a node picture link
        /// </summary>
        /// <remarks>
        /// Update a node picture link.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Picture link object to be updated</param>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>ApiResponse of PictureResponse</returns>
        ApiResponse<PictureResponse> UpdateNodePictureLinkWithHttpInfo (PictureLinkRequest body, long? nodeId, long? id);
        /// <summary>
        /// Update specifications of a node
        /// </summary>
        /// <remarks>
        /// Update the specification object of a node in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns></returns>
        void UpdateSpecificationsOfNode (Dictionary<string, SpecificationUIVisibleRequest> body, long? nodeId);

        /// <summary>
        /// Update specifications of a node
        /// </summary>
        /// <remarks>
        /// Update the specification object of a node in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateSpecificationsOfNodeWithHttpInfo (Dictionary<string, SpecificationUIVisibleRequest> body, long? nodeId);
        /// <summary>
        /// Upload an node picture
        /// </summary>
        /// <remarks>
        /// Upload a new node picture. Checks the file-storage quota. Allowed content-types are - image/gif - image/jpg - image/jpeg - image/png
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="image"></param>
        /// <param name="id">Id of the node</param>
        /// <returns>PictureResponse</returns>
        PictureResponse UploadNodePicture (byte[] image, long? id);

        /// <summary>
        /// Upload an node picture
        /// </summary>
        /// <remarks>
        /// Upload a new node picture. Checks the file-storage quota. Allowed content-types are - image/gif - image/jpg - image/jpeg - image/png
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="image"></param>
        /// <param name="id">Id of the node</param>
        /// <returns>ApiResponse of PictureResponse</returns>
        ApiResponse<PictureResponse> UploadNodePictureWithHttpInfo (byte[] image, long? id);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Add assets to a node
        /// </summary>
        /// <remarks>
        /// Add one or more assets to a node. This action requires &#x60;can_permit&#x60; permission on the node and on the asset.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the assets will be added</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task AddAssetsToNodeAsync (AssetIDs body, long? nodeId);

        /// <summary>
        /// Add assets to a node
        /// </summary>
        /// <remarks>
        /// Add one or more assets to a node. This action requires &#x60;can_permit&#x60; permission on the node and on the asset.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the assets will be added</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> AddAssetsToNodeAsyncWithHttpInfo (AssetIDs body, long? nodeId);
        /// <summary>
        /// Add documents to a node
        /// </summary>
        /// <remarks>
        /// Add one or more documents to a node. This action requires &#x60;can_update&#x60; permission on the node and &#x60;can_read&#x60; permission on the document.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the documents will be added</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task AddDocumentsToNodeAsync (DocumentIDs body, long? nodeId);

        /// <summary>
        /// Add documents to a node
        /// </summary>
        /// <remarks>
        /// Add one or more documents to a node. This action requires &#x60;can_update&#x60; permission on the node and &#x60;can_read&#x60; permission on the document.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the documents will be added</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> AddDocumentsToNodeAsyncWithHttpInfo (DocumentIDs body, long? nodeId);
        /// <summary>
        /// Add instrumentations to a node
        /// </summary>
        /// <remarks>
        /// Add one or more instrumentations to a node. This action requires &#x60;can_permit&#x60; permission on the node and on the instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the instrumentations will be added</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task AddInstrumentationsToNodeAsync (InstrumentationIDs body, long? nodeId);

        /// <summary>
        /// Add instrumentations to a node
        /// </summary>
        /// <remarks>
        /// Add one or more instrumentations to a node. This action requires &#x60;can_permit&#x60; permission on the node and on the instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the instrumentations will be added</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> AddInstrumentationsToNodeAsyncWithHttpInfo (InstrumentationIDs body, long? nodeId);
        /// <summary>
        /// Add a link as node picture
        /// </summary>
        /// <remarks>
        /// Add an external resource as node picture.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Picture link object to be created</param>
        /// <param name="id">Id of the node</param>
        /// <returns>Task of PictureResponse</returns>
        System.Threading.Tasks.Task<PictureResponse> AddNodePictureLinkAsync (PictureLinkRequest body, long? id);

        /// <summary>
        /// Add a link as node picture
        /// </summary>
        /// <remarks>
        /// Add an external resource as node picture.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Picture link object to be created</param>
        /// <param name="id">Id of the node</param>
        /// <returns>Task of ApiResponse (PictureResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<PictureResponse>> AddNodePictureLinkAsyncWithHttpInfo (PictureLinkRequest body, long? id);
        /// <summary>
        /// Add recipes to a node
        /// </summary>
        /// <remarks>
        /// Add one or more recipes to a node. This action requires &#x60;can_permit&#x60; permission on the node and on the recipe.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the recipes will be added</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task AddRecipesToNodeAsync (RecipeIDs body, long? nodeId);

        /// <summary>
        /// Add recipes to a node
        /// </summary>
        /// <remarks>
        /// Add one or more recipes to a node. This action requires &#x60;can_permit&#x60; permission on the node and on the recipe.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the recipes will be added</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> AddRecipesToNodeAsyncWithHttpInfo (RecipeIDs body, long? nodeId);
        /// <summary>
        /// Add systems to a node
        /// </summary>
        /// <remarks>
        /// Add one or more systems to a node. This action requires &#x60;can_permit&#x60; permission on the node and on the system.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the systems will be added</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task AddSystemsToNodeAsync (SystemIDs body, long? nodeId);

        /// <summary>
        /// Add systems to a node
        /// </summary>
        /// <remarks>
        /// Add one or more systems to a node. This action requires &#x60;can_permit&#x60; permission on the node and on the system.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the systems will be added</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> AddSystemsToNodeAsyncWithHttpInfo (SystemIDs body, long? nodeId);
        /// <summary>
        /// Create a new node
        /// </summary>
        /// <remarks>
        /// Create a new node. The name of the given node needs to be unique within its parent. The node will not be created when this constraint is violated. To assign a parent node the user needs &#x60;can_permit&#x60; permission on the parent.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object body that will be created. Name, node status and node type are required</param>
        /// <returns>Task of NodeResponse</returns>
        System.Threading.Tasks.Task<NodeResponse> CreateNodesAsync (NodeRequest body);

        /// <summary>
        /// Create a new node
        /// </summary>
        /// <remarks>
        /// Create a new node. The name of the given node needs to be unique within its parent. The node will not be created when this constraint is violated. To assign a parent node the user needs &#x60;can_permit&#x60; permission on the parent.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object body that will be created. Name, node status and node type are required</param>
        /// <returns>Task of ApiResponse (NodeResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<NodeResponse>> CreateNodesAsyncWithHttpInfo (NodeRequest body);
        /// <summary>
        /// Delete a node
        /// </summary>
        /// <remarks>
        /// Delete a specific resource in your accessible scope, identified by the id in the URL.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the node to delete</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteNodeAsync (long? id);

        /// <summary>
        /// Delete a node
        /// </summary>
        /// <remarks>
        /// Delete a specific resource in your accessible scope, identified by the id in the URL.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the node to delete</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteNodeAsyncWithHttpInfo (long? id);
        /// <summary>
        /// Delete an node picture
        /// </summary>
        /// <remarks>
        /// Delete an node picture.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteNodePictureAsync (long? nodeId, long? id);

        /// <summary>
        /// Delete an node picture
        /// </summary>
        /// <remarks>
        /// Delete an node picture.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteNodePictureAsyncWithHttpInfo (long? nodeId, long? id);
        /// <summary>
        /// Download an node picture
        /// </summary>
        /// <remarks>
        /// Download an node picture.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DownloadNodePictureAsync (long? nodeId, long? id);

        /// <summary>
        /// Download an node picture
        /// </summary>
        /// <remarks>
        /// Download an node picture.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DownloadNodePictureAsyncWithHttpInfo (long? nodeId, long? id);
        /// <summary>
        /// Get all assets of one node
        /// </summary>
        /// <remarks>
        /// Returns a list of all assets that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;status, tenant, parent, pictures, product, product.manufacturer, product.pictures, product.status, product.categories, product.categories.parent, specifications, specifications[key1,key2], product.tenant,                             product.manufacturer.tenant, status.tenant, instrumentations &#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="serialNumber">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productCategoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="manufacturerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusCode">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productionDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="ownershipClaimed">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;serial_number&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, &#x60;last_seen_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of AssetsResponse</returns>
        System.Threading.Tasks.Task<AssetsResponse> GetAssetsOfNodeAsync (long? nodeId, int? page = null, int? perPage = null, string include = null, string serialNumber = null, string productId = null, string productCategoryId = null, string parentId = null, string manufacturerId = null, string statusId = null, string statusCode = null, DateTime? productionDate = null, DateTime? productionDateFrom = null, DateTime? productionDateTo = null, string specificationsKey = null, string specificationsValue = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, bool? ownershipClaimed = null, string permission = null, string orderBy = null);

        /// <summary>
        /// Get all assets of one node
        /// </summary>
        /// <remarks>
        /// Returns a list of all assets that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;status, tenant, parent, pictures, product, product.manufacturer, product.pictures, product.status, product.categories, product.categories.parent, specifications, specifications[key1,key2], product.tenant,                             product.manufacturer.tenant, status.tenant, instrumentations &#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="serialNumber">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productCategoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="manufacturerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusCode">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productionDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="ownershipClaimed">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;serial_number&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, &#x60;last_seen_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (AssetsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<AssetsResponse>> GetAssetsOfNodeAsyncWithHttpInfo (long? nodeId, int? page = null, int? perPage = null, string include = null, string serialNumber = null, string productId = null, string productCategoryId = null, string parentId = null, string manufacturerId = null, string statusId = null, string statusCode = null, DateTime? productionDate = null, DateTime? productionDateFrom = null, DateTime? productionDateTo = null, string specificationsKey = null, string specificationsValue = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, bool? ownershipClaimed = null, string permission = null, string orderBy = null);
        /// <summary>
        /// Get all documents of a node
        /// </summary>
        /// <remarks>
        /// Returns a list of documents. If the query has no matches, the response is an empty list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language. Possible include values: &#x60;&#x60;&#x60;status, tenant, classification, categories, categories.parent, categories.standards, attachments&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="documentVersion">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="number">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="classificationId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="categoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="validFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validUntil">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validAt">Expected date format is YYYY-MM-DD or YYYY-MM or YYYY (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of DocumentsResponse</returns>
        System.Threading.Tasks.Task<DocumentsResponse> GetDocumentsOfNodeAsync (long? nodeId, int? page = null, int? perPage = null, string include = null, string name = null, string documentVersion = null, string number = null, string statusId = null, string classificationId = null, string tenantId = null, string categoryId = null, DateTime? validFrom = null, DateTime? validUntil = null, DateTime? validAt = null, string acceptLanguage = null);

        /// <summary>
        /// Get all documents of a node
        /// </summary>
        /// <remarks>
        /// Returns a list of documents. If the query has no matches, the response is an empty list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language. Possible include values: &#x60;&#x60;&#x60;status, tenant, classification, categories, categories.parent, categories.standards, attachments&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="documentVersion">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="number">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="classificationId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="categoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="validFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validUntil">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validAt">Expected date format is YYYY-MM-DD or YYYY-MM or YYYY (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of ApiResponse (DocumentsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<DocumentsResponse>> GetDocumentsOfNodeAsyncWithHttpInfo (long? nodeId, int? page = null, int? perPage = null, string include = null, string name = null, string documentVersion = null, string number = null, string statusId = null, string classificationId = null, string tenantId = null, string categoryId = null, DateTime? validFrom = null, DateTime? validUntil = null, DateTime? validAt = null, string acceptLanguage = null);
        /// <summary>
        /// Get all instrumentations of one node
        /// </summary>
        /// <remarks>
        /// Returns a list of all instrumentations that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;specifications, specifications[key1,key2], pictures, tenant, parent, status, worst_asset_status, type&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="tag">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="criticality">Filter accepts undefined, low, medium or high (optional)</param>
        /// <param name="accessibility">Filter accepts undefined, easy, moderate or difficult (optional)</param>
        /// <param name="assetStatusId">One or multiple ids (comma list). Expected id format is integer. This retrieves all Instrumentations where at least one of its assets has one of the given statuses. (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;tag&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of InstrumentationsResponse</returns>
        System.Threading.Tasks.Task<InstrumentationsResponse> GetInstrumentationsOfNodeAsync (long? nodeId, int? page = null, int? perPage = null, string include = null, string tag = null, string statusId = null, string typeId = null, string parentId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string criticality = null, string accessibility = null, string assetStatusId = null, string permission = null, string orderBy = null);

        /// <summary>
        /// Get all instrumentations of one node
        /// </summary>
        /// <remarks>
        /// Returns a list of all instrumentations that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;specifications, specifications[key1,key2], pictures, tenant, parent, status, worst_asset_status, type&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="tag">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="criticality">Filter accepts undefined, low, medium or high (optional)</param>
        /// <param name="accessibility">Filter accepts undefined, easy, moderate or difficult (optional)</param>
        /// <param name="assetStatusId">One or multiple ids (comma list). Expected id format is integer. This retrieves all Instrumentations where at least one of its assets has one of the given statuses. (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;tag&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (InstrumentationsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<InstrumentationsResponse>> GetInstrumentationsOfNodeAsyncWithHttpInfo (long? nodeId, int? page = null, int? perPage = null, string include = null, string tag = null, string statusId = null, string typeId = null, string parentId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string criticality = null, string accessibility = null, string assetStatusId = null, string permission = null, string orderBy = null);
        /// <summary>
        /// Get the type of the specific node
        /// </summary>
        /// <remarks>
        /// Returns the type of the node. Needed if only permission on node but not on tenant. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language. Possible include values: &#x60;&#x60;&#x60;tenant&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of NodeTypeResponse</returns>
        System.Threading.Tasks.Task<NodeTypeResponse> GetNodeIdTypeAsync (long? nodeId, string include = null, string acceptLanguage = null);

        /// <summary>
        /// Get the type of the specific node
        /// </summary>
        /// <remarks>
        /// Returns the type of the node. Needed if only permission on node but not on tenant. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language. Possible include values: &#x60;&#x60;&#x60;tenant&#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of ApiResponse (NodeTypeResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<NodeTypeResponse>> GetNodeIdTypeAsyncWithHttpInfo (long? nodeId, string include = null, string acceptLanguage = null);
        /// <summary>
        /// Get an node picture
        /// </summary>
        /// <remarks>
        /// Get a single picture of an node.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>Task of PictureResponse</returns>
        System.Threading.Tasks.Task<PictureResponse> GetNodePictureAsync (long? nodeId, long? id);

        /// <summary>
        /// Get an node picture
        /// </summary>
        /// <remarks>
        /// Get a single picture of an node.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>Task of ApiResponse (PictureResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<PictureResponse>> GetNodePictureAsyncWithHttpInfo (long? nodeId, long? id);
        /// <summary>
        /// Get node pictures
        /// </summary>
        /// <remarks>
        /// Get all pictures of an node.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the node</param>
        /// <param name="width">filter by width (optional)</param>
        /// <param name="widthFrom">filter by width_from (optional)</param>
        /// <param name="widthTo">filter by width_to (optional)</param>
        /// <param name="height">filter by height (optional)</param>
        /// <param name="heightFrom">filter by height_from (optional)</param>
        /// <param name="heightTo">filter by height_to (optional)</param>
        /// <returns>Task of PicturesResponse</returns>
        System.Threading.Tasks.Task<PicturesResponse> GetNodePicturesAsync (long? id, int? width = null, int? widthFrom = null, int? widthTo = null, int? height = null, int? heightFrom = null, int? heightTo = null);

        /// <summary>
        /// Get node pictures
        /// </summary>
        /// <remarks>
        /// Get all pictures of an node.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the node</param>
        /// <param name="width">filter by width (optional)</param>
        /// <param name="widthFrom">filter by width_from (optional)</param>
        /// <param name="widthTo">filter by width_to (optional)</param>
        /// <param name="height">filter by height (optional)</param>
        /// <param name="heightFrom">filter by height_from (optional)</param>
        /// <param name="heightTo">filter by height_to (optional)</param>
        /// <returns>Task of ApiResponse (PicturesResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<PicturesResponse>> GetNodePicturesAsyncWithHttpInfo (long? id, int? width = null, int? widthFrom = null, int? widthTo = null, int? height = null, int? heightFrom = null, int? heightTo = null);
        /// <summary>
        /// Get all possible types of the specified node
        /// </summary>
        /// <remarks>
        /// Returns a list of all possible node types for the specified node. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of NodeTypes</returns>
        System.Threading.Tasks.Task<NodeTypes> GetNodeTypesOptionsAsync (long? nodeId, int? page = null, int? perPage = null, string tenantId = null, string name = null, string code = null, string acceptLanguage = null);

        /// <summary>
        /// Get all possible types of the specified node
        /// </summary>
        /// <remarks>
        /// Returns a list of all possible node types for the specified node. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of ApiResponse (NodeTypes)</returns>
        System.Threading.Tasks.Task<ApiResponse<NodeTypes>> GetNodeTypesOptionsAsyncWithHttpInfo (long? nodeId, int? page = null, int? perPage = null, string tenantId = null, string name = null, string code = null, string acceptLanguage = null);
        /// <summary>
        /// Get a range of nodes
        /// </summary>
        /// <remarks>
        /// Returns a list of nodes in your accessible scope. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;parent, tenant, type, type.parent, specifications, specifications[key1,key2], pictures, instrumentations, instrumentations.specifications, instrumentations.specifications[key1,key2], instrumentations.values, instrumentations.values.unit, instrumentations.values_in_preferred_units, instrumentations.values_in_preferred_units.unit, worst_asset_status&#x60;&#x60;&#x60; Hidden nodes are not returned by default, if the hidden nodes should be included, add \&quot;&#x60;&#x60;&#x60;hidden&#x60;&#x60;&#x60;\&quot; to the include parameter 
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of NodesResponse</returns>
        System.Threading.Tasks.Task<NodesResponse> GetNodesAsync (int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string parentId = null, string tenantId = null, string permission = null, string orderBy = null);

        /// <summary>
        /// Get a range of nodes
        /// </summary>
        /// <remarks>
        /// Returns a list of nodes in your accessible scope. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;parent, tenant, type, type.parent, specifications, specifications[key1,key2], pictures, instrumentations, instrumentations.specifications, instrumentations.specifications[key1,key2], instrumentations.values, instrumentations.values.unit, instrumentations.values_in_preferred_units, instrumentations.values_in_preferred_units.unit, worst_asset_status&#x60;&#x60;&#x60; Hidden nodes are not returned by default, if the hidden nodes should be included, add \&quot;&#x60;&#x60;&#x60;hidden&#x60;&#x60;&#x60;\&quot; to the include parameter 
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (NodesResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<NodesResponse>> GetNodesAsyncWithHttpInfo (int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string parentId = null, string tenantId = null, string permission = null, string orderBy = null);
        /// <summary>
        /// Get a single node
        /// </summary>
        /// <remarks>
        /// Get a specific node in your accessible scope, identified by the id in the URL.  Possible include values: &#x60;&#x60;&#x60;parent, tenant, type, specifications, specifications[key1,key2], pictures, instrumentations, instrumentations.specifications, instrumentations.specifications[key1,key2], instrumentations.values, instrumentations.values.unit, instrumentations.values_in_preferred_units, instrumentations.values_in_preferred_units.unit, worst_asset_status&#x60;&#x60;&#x60; 
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the node to fetch</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <returns>Task of NodeResponse</returns>
        System.Threading.Tasks.Task<NodeResponse> GetNodesByIdAsync (long? id, string include = null);

        /// <summary>
        /// Get a single node
        /// </summary>
        /// <remarks>
        /// Get a specific node in your accessible scope, identified by the id in the URL.  Possible include values: &#x60;&#x60;&#x60;parent, tenant, type, specifications, specifications[key1,key2], pictures, instrumentations, instrumentations.specifications, instrumentations.specifications[key1,key2], instrumentations.values, instrumentations.values.unit, instrumentations.values_in_preferred_units, instrumentations.values_in_preferred_units.unit, worst_asset_status&#x60;&#x60;&#x60; 
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the node to fetch</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <returns>Task of ApiResponse (NodeResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<NodeResponse>> GetNodesByIdAsyncWithHttpInfo (long? id, string include = null);
        /// <summary>
        /// Get all recipes of one node
        /// </summary>
        /// <remarks>
        /// Returns a list of all recipes that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;Possible include values: pictures, specifications, specifications[key1,key2], tenant, status, type, type.tenant, type.parent &#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of RecipesResponse</returns>
        System.Threading.Tasks.Task<RecipesResponse> GetRecipesOfNodeAsync (long? nodeId, int? page = null, int? perPage = null, string include = null, string name = null, string statusId = null, string typeId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string orderBy = null);

        /// <summary>
        /// Get all recipes of one node
        /// </summary>
        /// <remarks>
        /// Returns a list of all recipes that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;Possible include values: pictures, specifications, specifications[key1,key2], tenant, status, type, type.tenant, type.parent &#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (RecipesResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<RecipesResponse>> GetRecipesOfNodeAsyncWithHttpInfo (long? nodeId, int? page = null, int? perPage = null, string include = null, string name = null, string statusId = null, string typeId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string orderBy = null);
        /// <summary>
        /// Get existing asset specification keys
        /// </summary>
        /// <remarks>
        /// Returns the existing specification keys in all readable nodes.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of SpecificationKeys</returns>
        System.Threading.Tasks.Task<SpecificationKeys> GetSpecificationKeysOfNodesAsync (string key = null, bool? uiVisible = null);

        /// <summary>
        /// Get existing asset specification keys
        /// </summary>
        /// <remarks>
        /// Returns the existing specification keys in all readable nodes.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationKeys)</returns>
        System.Threading.Tasks.Task<ApiResponse<SpecificationKeys>> GetSpecificationKeysOfNodesAsyncWithHttpInfo (string key = null, bool? uiVisible = null);
        /// <summary>
        /// Get specifications of a node
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the specified node</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of SpecificationsUIVisibleResponse</returns>
        System.Threading.Tasks.Task<SpecificationsUIVisibleResponse> GetSpecificationsOfNodeAsync (long? nodeId, string key = null, bool? uiVisible = null);

        /// <summary>
        /// Get specifications of a node
        /// </summary>
        /// <remarks>
        /// Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the specified node</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationsUIVisibleResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SpecificationsUIVisibleResponse>> GetSpecificationsOfNodeAsyncWithHttpInfo (long? nodeId, string key = null, bool? uiVisible = null);
        /// <summary>
        /// Get all systems of one node
        /// </summary>
        /// <remarks>
        /// Returns a list of all systems that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;pictures, specifications, specifications[key1,key2], tenant, parent, status, type, type.tenant, type.parent, worst_asset_status &#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of SystemsResponse</returns>
        System.Threading.Tasks.Task<SystemsResponse> GetSystemsOfNodeAsync (long? nodeId, int? page = null, int? perPage = null, string include = null, string name = null, string statusId = null, string typeId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string permission = null, string orderBy = null);

        /// <summary>
        /// Get all systems of one node
        /// </summary>
        /// <remarks>
        /// Returns a list of all systems that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;pictures, specifications, specifications[key1,key2], tenant, parent, status, type, type.tenant, type.parent, worst_asset_status &#x60;&#x60;&#x60;
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (SystemsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SystemsResponse>> GetSystemsOfNodeAsyncWithHttpInfo (long? nodeId, int? page = null, int? perPage = null, string include = null, string name = null, string statusId = null, string typeId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string permission = null, string orderBy = null);
        /// <summary>
        /// Remove assets from a node
        /// </summary>
        /// <remarks>
        /// Remove one or more assets from a node in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the node and on the asset.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the assets will be removed</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveAssetsFromNodeAsync (AssetIDs body, long? nodeId);

        /// <summary>
        /// Remove assets from a node
        /// </summary>
        /// <remarks>
        /// Remove one or more assets from a node in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the node and on the asset.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the assets will be removed</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveAssetsFromNodeAsyncWithHttpInfo (AssetIDs body, long? nodeId);
        /// <summary>
        /// Remove documents from a node
        /// </summary>
        /// <remarks>
        /// Remove one or more documents from a node. This action requires &#x60;can_update&#x60; permission on the node and &#x60;can_read&#x60; permission on the document.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the documents will be removed</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveDocumentsFromNodeAsync (DocumentIDs body, long? nodeId);

        /// <summary>
        /// Remove documents from a node
        /// </summary>
        /// <remarks>
        /// Remove one or more documents from a node. This action requires &#x60;can_update&#x60; permission on the node and &#x60;can_read&#x60; permission on the document.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the documents will be removed</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveDocumentsFromNodeAsyncWithHttpInfo (DocumentIDs body, long? nodeId);
        /// <summary>
        /// Remove instrumentations from a node
        /// </summary>
        /// <remarks>
        /// Remove one or more instrumentations from a node in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the node and on the instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the instrumentations will be removed</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveInstrumentationsFromNodeAsync (InstrumentationIDs body, long? nodeId);

        /// <summary>
        /// Remove instrumentations from a node
        /// </summary>
        /// <remarks>
        /// Remove one or more instrumentations from a node in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the node and on the instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the instrumentations will be removed</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveInstrumentationsFromNodeAsyncWithHttpInfo (InstrumentationIDs body, long? nodeId);
        /// <summary>
        /// Remove recipes from a node
        /// </summary>
        /// <remarks>
        /// Remove one or more recipes from a node in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the node and on the recipe.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the recipes will be removed</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveRecipesFromNodeAsync (RecipeIDs body, long? nodeId);

        /// <summary>
        /// Remove recipes from a node
        /// </summary>
        /// <remarks>
        /// Remove one or more recipes from a node in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the node and on the recipe.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the recipes will be removed</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveRecipesFromNodeAsyncWithHttpInfo (RecipeIDs body, long? nodeId);
        /// <summary>
        /// Delete specifications of a node
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveSpecificationsFromNodeAsync (List<string> body, long? nodeId);

        /// <summary>
        /// Delete specifications of a node
        /// </summary>
        /// <remarks>
        /// The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveSpecificationsFromNodeAsyncWithHttpInfo (List<string> body, long? nodeId);
        /// <summary>
        /// Remove systems from a node
        /// </summary>
        /// <remarks>
        /// Remove one or more systems from a node in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the node and on the system.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the systems will be removed</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveSystemsFromNodeAsync (SystemIDs body, long? nodeId);

        /// <summary>
        /// Remove systems from a node
        /// </summary>
        /// <remarks>
        /// Remove one or more systems from a node in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the node and on the system.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the systems will be removed</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveSystemsFromNodeAsyncWithHttpInfo (SystemIDs body, long? nodeId);
        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of a node in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RenameSpecificationsOfNodeAsync (SpecificationsRename body, long? nodeId);

        /// <summary>
        /// Rename a specification key
        /// </summary>
        /// <remarks>
        /// Rename one specification key of a node in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RenameSpecificationsOfNodeAsyncWithHttpInfo (SpecificationsRename body, long? nodeId);
        /// <summary>
        /// Replace the assets of a node
        /// </summary>
        /// <remarks>
        /// Replaces all assets belonging to a node in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the node and on the asset.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the assets will be replaced</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task ReplaceAssetsOfNodeAsync (AssetIDs body, long? nodeId);

        /// <summary>
        /// Replace the assets of a node
        /// </summary>
        /// <remarks>
        /// Replaces all assets belonging to a node in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the node and on the asset.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the assets will be replaced</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> ReplaceAssetsOfNodeAsyncWithHttpInfo (AssetIDs body, long? nodeId);
        /// <summary>
        /// Replace the documents of a node
        /// </summary>
        /// <remarks>
        /// Replaces all documents belonging to a node. You can send a list of resources that will replace all previous values. This action requires &#x60;can_update&#x60; permission on the node and &#x60;can_read&#x60; permission on the document.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the documents will be replaced</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task ReplaceDocumentsOfNodeAsync (DocumentIDs body, long? nodeId);

        /// <summary>
        /// Replace the documents of a node
        /// </summary>
        /// <remarks>
        /// Replaces all documents belonging to a node. You can send a list of resources that will replace all previous values. This action requires &#x60;can_update&#x60; permission on the node and &#x60;can_read&#x60; permission on the document.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the documents will be replaced</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> ReplaceDocumentsOfNodeAsyncWithHttpInfo (DocumentIDs body, long? nodeId);
        /// <summary>
        /// Replace the instrumentations of a node
        /// </summary>
        /// <remarks>
        /// Replaces all instrumentations belonging to a node in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the node and on the instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the instrumentations will be replaced</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task ReplaceInstrumentationsOfNodeAsync (InstrumentationIDs body, long? nodeId);

        /// <summary>
        /// Replace the instrumentations of a node
        /// </summary>
        /// <remarks>
        /// Replaces all instrumentations belonging to a node in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the node and on the instrumentation.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the instrumentations will be replaced</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> ReplaceInstrumentationsOfNodeAsyncWithHttpInfo (InstrumentationIDs body, long? nodeId);
        /// <summary>
        /// Replace the recipes of a node
        /// </summary>
        /// <remarks>
        /// Replaces all recipes belonging to a node in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the node and on the recipe.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the recipes will be replaced</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task ReplaceRecipesOfNodeAsync (RecipeIDs body, long? nodeId);

        /// <summary>
        /// Replace the recipes of a node
        /// </summary>
        /// <remarks>
        /// Replaces all recipes belonging to a node in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the node and on the recipe.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the recipes will be replaced</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> ReplaceRecipesOfNodeAsyncWithHttpInfo (RecipeIDs body, long? nodeId);
        /// <summary>
        /// Replace the systems of a node
        /// </summary>
        /// <remarks>
        /// Replaces all systems belonging to a node in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the node and on the system.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the systems will be replaced</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task ReplaceSystemsOfNodeAsync (SystemIDs body, long? nodeId);

        /// <summary>
        /// Replace the systems of a node
        /// </summary>
        /// <remarks>
        /// Replaces all systems belonging to a node in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the node and on the system.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the systems will be replaced</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> ReplaceSystemsOfNodeAsyncWithHttpInfo (SystemIDs body, long? nodeId);
        /// <summary>
        /// Update a node
        /// </summary>
        /// <remarks>
        /// Update accessible parameters of the requested resource in your accessible scope. To assign a parent node the user needs &#x60;can_permit&#x60; permission on the parent and on the current node.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the node to update</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UpdateNodeAsync (NodeRequest body, long? id);

        /// <summary>
        /// Update a node
        /// </summary>
        /// <remarks>
        /// Update accessible parameters of the requested resource in your accessible scope. To assign a parent node the user needs &#x60;can_permit&#x60; permission on the parent and on the current node.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the node to update</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UpdateNodeAsyncWithHttpInfo (NodeRequest body, long? id);
        /// <summary>
        /// Update an node picture
        /// </summary>
        /// <remarks>
        /// Upload a new node picture. Check the file-storage quota. Allowed content-types are - image/gif - image/jpg - image/jpeg - image/png
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="image"></param>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>Task of PictureResponse</returns>
        System.Threading.Tasks.Task<PictureResponse> UpdateNodePictureAsync (byte[] image, long? nodeId, long? id);

        /// <summary>
        /// Update an node picture
        /// </summary>
        /// <remarks>
        /// Upload a new node picture. Check the file-storage quota. Allowed content-types are - image/gif - image/jpg - image/jpeg - image/png
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="image"></param>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>Task of ApiResponse (PictureResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<PictureResponse>> UpdateNodePictureAsyncWithHttpInfo (byte[] image, long? nodeId, long? id);
        /// <summary>
        /// Update a node picture link
        /// </summary>
        /// <remarks>
        /// Update a node picture link.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Picture link object to be updated</param>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>Task of PictureResponse</returns>
        System.Threading.Tasks.Task<PictureResponse> UpdateNodePictureLinkAsync (PictureLinkRequest body, long? nodeId, long? id);

        /// <summary>
        /// Update a node picture link
        /// </summary>
        /// <remarks>
        /// Update a node picture link.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Picture link object to be updated</param>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>Task of ApiResponse (PictureResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<PictureResponse>> UpdateNodePictureLinkAsyncWithHttpInfo (PictureLinkRequest body, long? nodeId, long? id);
        /// <summary>
        /// Update specifications of a node
        /// </summary>
        /// <remarks>
        /// Update the specification object of a node in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UpdateSpecificationsOfNodeAsync (Dictionary<string, SpecificationUIVisibleRequest> body, long? nodeId);

        /// <summary>
        /// Update specifications of a node
        /// </summary>
        /// <remarks>
        /// Update the specification object of a node in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSpecificationsOfNodeAsyncWithHttpInfo (Dictionary<string, SpecificationUIVisibleRequest> body, long? nodeId);
        /// <summary>
        /// Upload an node picture
        /// </summary>
        /// <remarks>
        /// Upload a new node picture. Checks the file-storage quota. Allowed content-types are - image/gif - image/jpg - image/jpeg - image/png
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="image"></param>
        /// <param name="id">Id of the node</param>
        /// <returns>Task of PictureResponse</returns>
        System.Threading.Tasks.Task<PictureResponse> UploadNodePictureAsync (byte[] image, long? id);

        /// <summary>
        /// Upload an node picture
        /// </summary>
        /// <remarks>
        /// Upload a new node picture. Checks the file-storage quota. Allowed content-types are - image/gif - image/jpg - image/jpeg - image/png
        /// </remarks>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="image"></param>
        /// <param name="id">Id of the node</param>
        /// <returns>Task of ApiResponse (PictureResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<PictureResponse>> UploadNodePictureAsyncWithHttpInfo (byte[] image, long? id);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
        public partial class NodeApi : INodeApi
    {
        private Netilion.Api.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="NodeApi"/> class.
        /// </summary>
        /// <returns></returns>
        public NodeApi(String basePath)
        {
            this.Configuration = new Netilion.Api.Client.Configuration { BasePath = basePath };

            ExceptionFactory = Netilion.Api.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="NodeApi"/> class
        /// </summary>
        /// <returns></returns>
        public NodeApi()
        {
            this.Configuration = Netilion.Api.Client.Configuration.Default;

            ExceptionFactory = Netilion.Api.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="NodeApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public NodeApi(Netilion.Api.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = Netilion.Api.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = Netilion.Api.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Netilion.Api.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Netilion.Api.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Add assets to a node Add one or more assets to a node. This action requires &#x60;can_permit&#x60; permission on the node and on the asset.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the assets will be added</param>
        /// <returns></returns>
        public void AddAssetsToNode (AssetIDs body, long? nodeId)
        {
             AddAssetsToNodeWithHttpInfo(body, nodeId);
        }

        /// <summary>
        /// Add assets to a node Add one or more assets to a node. This action requires &#x60;can_permit&#x60; permission on the node and on the asset.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the assets will be added</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> AddAssetsToNodeWithHttpInfo (AssetIDs body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->AddAssetsToNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->AddAssetsToNode");

            var localVarPath = "/nodes/{node_id}/assets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddAssetsToNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Add assets to a node Add one or more assets to a node. This action requires &#x60;can_permit&#x60; permission on the node and on the asset.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the assets will be added</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task AddAssetsToNodeAsync (AssetIDs body, long? nodeId)
        {
             await AddAssetsToNodeAsyncWithHttpInfo(body, nodeId);

        }

        /// <summary>
        /// Add assets to a node Add one or more assets to a node. This action requires &#x60;can_permit&#x60; permission on the node and on the asset.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the assets will be added</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> AddAssetsToNodeAsyncWithHttpInfo (AssetIDs body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->AddAssetsToNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->AddAssetsToNode");

            var localVarPath = "/nodes/{node_id}/assets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddAssetsToNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Add documents to a node Add one or more documents to a node. This action requires &#x60;can_update&#x60; permission on the node and &#x60;can_read&#x60; permission on the document.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the documents will be added</param>
        /// <returns></returns>
        public void AddDocumentsToNode (DocumentIDs body, long? nodeId)
        {
             AddDocumentsToNodeWithHttpInfo(body, nodeId);
        }

        /// <summary>
        /// Add documents to a node Add one or more documents to a node. This action requires &#x60;can_update&#x60; permission on the node and &#x60;can_read&#x60; permission on the document.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the documents will be added</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> AddDocumentsToNodeWithHttpInfo (DocumentIDs body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->AddDocumentsToNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->AddDocumentsToNode");

            var localVarPath = "/nodes/{node_id}/documents";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddDocumentsToNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Add documents to a node Add one or more documents to a node. This action requires &#x60;can_update&#x60; permission on the node and &#x60;can_read&#x60; permission on the document.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the documents will be added</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task AddDocumentsToNodeAsync (DocumentIDs body, long? nodeId)
        {
             await AddDocumentsToNodeAsyncWithHttpInfo(body, nodeId);

        }

        /// <summary>
        /// Add documents to a node Add one or more documents to a node. This action requires &#x60;can_update&#x60; permission on the node and &#x60;can_read&#x60; permission on the document.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the documents will be added</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> AddDocumentsToNodeAsyncWithHttpInfo (DocumentIDs body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->AddDocumentsToNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->AddDocumentsToNode");

            var localVarPath = "/nodes/{node_id}/documents";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddDocumentsToNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Add instrumentations to a node Add one or more instrumentations to a node. This action requires &#x60;can_permit&#x60; permission on the node and on the instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the instrumentations will be added</param>
        /// <returns></returns>
        public void AddInstrumentationsToNode (InstrumentationIDs body, long? nodeId)
        {
             AddInstrumentationsToNodeWithHttpInfo(body, nodeId);
        }

        /// <summary>
        /// Add instrumentations to a node Add one or more instrumentations to a node. This action requires &#x60;can_permit&#x60; permission on the node and on the instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the instrumentations will be added</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> AddInstrumentationsToNodeWithHttpInfo (InstrumentationIDs body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->AddInstrumentationsToNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->AddInstrumentationsToNode");

            var localVarPath = "/nodes/{node_id}/instrumentations";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddInstrumentationsToNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Add instrumentations to a node Add one or more instrumentations to a node. This action requires &#x60;can_permit&#x60; permission on the node and on the instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the instrumentations will be added</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task AddInstrumentationsToNodeAsync (InstrumentationIDs body, long? nodeId)
        {
             await AddInstrumentationsToNodeAsyncWithHttpInfo(body, nodeId);

        }

        /// <summary>
        /// Add instrumentations to a node Add one or more instrumentations to a node. This action requires &#x60;can_permit&#x60; permission on the node and on the instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the instrumentations will be added</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> AddInstrumentationsToNodeAsyncWithHttpInfo (InstrumentationIDs body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->AddInstrumentationsToNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->AddInstrumentationsToNode");

            var localVarPath = "/nodes/{node_id}/instrumentations";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddInstrumentationsToNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Add a link as node picture Add an external resource as node picture.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Picture link object to be created</param>
        /// <param name="id">Id of the node</param>
        /// <returns>PictureResponse</returns>
        public PictureResponse AddNodePictureLink (PictureLinkRequest body, long? id)
        {
             ApiResponse<PictureResponse> localVarResponse = AddNodePictureLinkWithHttpInfo(body, id);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Add a link as node picture Add an external resource as node picture.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Picture link object to be created</param>
        /// <param name="id">Id of the node</param>
        /// <returns>ApiResponse of PictureResponse</returns>
        public ApiResponse< PictureResponse > AddNodePictureLinkWithHttpInfo (PictureLinkRequest body, long? id)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->AddNodePictureLink");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling NodeApi->AddNodePictureLink");

            var localVarPath = "/nodes/{id}/pictures/links";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddNodePictureLink", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PictureResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (PictureResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(PictureResponse)));
        }

        /// <summary>
        /// Add a link as node picture Add an external resource as node picture.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Picture link object to be created</param>
        /// <param name="id">Id of the node</param>
        /// <returns>Task of PictureResponse</returns>
        public async System.Threading.Tasks.Task<PictureResponse> AddNodePictureLinkAsync (PictureLinkRequest body, long? id)
        {
             ApiResponse<PictureResponse> localVarResponse = await AddNodePictureLinkAsyncWithHttpInfo(body, id);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Add a link as node picture Add an external resource as node picture.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Picture link object to be created</param>
        /// <param name="id">Id of the node</param>
        /// <returns>Task of ApiResponse (PictureResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<PictureResponse>> AddNodePictureLinkAsyncWithHttpInfo (PictureLinkRequest body, long? id)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->AddNodePictureLink");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling NodeApi->AddNodePictureLink");

            var localVarPath = "/nodes/{id}/pictures/links";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddNodePictureLink", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PictureResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (PictureResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(PictureResponse)));
        }

        /// <summary>
        /// Add recipes to a node Add one or more recipes to a node. This action requires &#x60;can_permit&#x60; permission on the node and on the recipe.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the recipes will be added</param>
        /// <returns></returns>
        public void AddRecipesToNode (RecipeIDs body, long? nodeId)
        {
             AddRecipesToNodeWithHttpInfo(body, nodeId);
        }

        /// <summary>
        /// Add recipes to a node Add one or more recipes to a node. This action requires &#x60;can_permit&#x60; permission on the node and on the recipe.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the recipes will be added</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> AddRecipesToNodeWithHttpInfo (RecipeIDs body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->AddRecipesToNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->AddRecipesToNode");

            var localVarPath = "/nodes/{node_id}/recipes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddRecipesToNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Add recipes to a node Add one or more recipes to a node. This action requires &#x60;can_permit&#x60; permission on the node and on the recipe.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the recipes will be added</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task AddRecipesToNodeAsync (RecipeIDs body, long? nodeId)
        {
             await AddRecipesToNodeAsyncWithHttpInfo(body, nodeId);

        }

        /// <summary>
        /// Add recipes to a node Add one or more recipes to a node. This action requires &#x60;can_permit&#x60; permission on the node and on the recipe.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the recipes will be added</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> AddRecipesToNodeAsyncWithHttpInfo (RecipeIDs body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->AddRecipesToNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->AddRecipesToNode");

            var localVarPath = "/nodes/{node_id}/recipes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddRecipesToNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Add systems to a node Add one or more systems to a node. This action requires &#x60;can_permit&#x60; permission on the node and on the system.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the systems will be added</param>
        /// <returns></returns>
        public void AddSystemsToNode (SystemIDs body, long? nodeId)
        {
             AddSystemsToNodeWithHttpInfo(body, nodeId);
        }

        /// <summary>
        /// Add systems to a node Add one or more systems to a node. This action requires &#x60;can_permit&#x60; permission on the node and on the system.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the systems will be added</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> AddSystemsToNodeWithHttpInfo (SystemIDs body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->AddSystemsToNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->AddSystemsToNode");

            var localVarPath = "/nodes/{node_id}/systems";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddSystemsToNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Add systems to a node Add one or more systems to a node. This action requires &#x60;can_permit&#x60; permission on the node and on the system.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the systems will be added</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task AddSystemsToNodeAsync (SystemIDs body, long? nodeId)
        {
             await AddSystemsToNodeAsyncWithHttpInfo(body, nodeId);

        }

        /// <summary>
        /// Add systems to a node Add one or more systems to a node. This action requires &#x60;can_permit&#x60; permission on the node and on the system.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be added.</param>
        /// <param name="nodeId">Id of the node to which the systems will be added</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> AddSystemsToNodeAsyncWithHttpInfo (SystemIDs body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->AddSystemsToNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->AddSystemsToNode");

            var localVarPath = "/nodes/{node_id}/systems";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddSystemsToNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Create a new node Create a new node. The name of the given node needs to be unique within its parent. The node will not be created when this constraint is violated. To assign a parent node the user needs &#x60;can_permit&#x60; permission on the parent.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object body that will be created. Name, node status and node type are required</param>
        /// <returns>NodeResponse</returns>
        public NodeResponse CreateNodes (NodeRequest body)
        {
             ApiResponse<NodeResponse> localVarResponse = CreateNodesWithHttpInfo(body);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Create a new node Create a new node. The name of the given node needs to be unique within its parent. The node will not be created when this constraint is violated. To assign a parent node the user needs &#x60;can_permit&#x60; permission on the parent.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object body that will be created. Name, node status and node type are required</param>
        /// <returns>ApiResponse of NodeResponse</returns>
        public ApiResponse< NodeResponse > CreateNodesWithHttpInfo (NodeRequest body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->CreateNodes");

            var localVarPath = "/nodes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNodes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<NodeResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (NodeResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(NodeResponse)));
        }

        /// <summary>
        /// Create a new node Create a new node. The name of the given node needs to be unique within its parent. The node will not be created when this constraint is violated. To assign a parent node the user needs &#x60;can_permit&#x60; permission on the parent.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object body that will be created. Name, node status and node type are required</param>
        /// <returns>Task of NodeResponse</returns>
        public async System.Threading.Tasks.Task<NodeResponse> CreateNodesAsync (NodeRequest body)
        {
             ApiResponse<NodeResponse> localVarResponse = await CreateNodesAsyncWithHttpInfo(body);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Create a new node Create a new node. The name of the given node needs to be unique within its parent. The node will not be created when this constraint is violated. To assign a parent node the user needs &#x60;can_permit&#x60; permission on the parent.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Object body that will be created. Name, node status and node type are required</param>
        /// <returns>Task of ApiResponse (NodeResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<NodeResponse>> CreateNodesAsyncWithHttpInfo (NodeRequest body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->CreateNodes");

            var localVarPath = "/nodes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNodes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<NodeResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (NodeResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(NodeResponse)));
        }

        /// <summary>
        /// Delete a node Delete a specific resource in your accessible scope, identified by the id in the URL.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the node to delete</param>
        /// <returns></returns>
        public void DeleteNode (long? id)
        {
             DeleteNodeWithHttpInfo(id);
        }

        /// <summary>
        /// Delete a node Delete a specific resource in your accessible scope, identified by the id in the URL.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the node to delete</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteNodeWithHttpInfo (long? id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling NodeApi->DeleteNode");

            var localVarPath = "/nodes/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete a node Delete a specific resource in your accessible scope, identified by the id in the URL.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the node to delete</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteNodeAsync (long? id)
        {
             await DeleteNodeAsyncWithHttpInfo(id);

        }

        /// <summary>
        /// Delete a node Delete a specific resource in your accessible scope, identified by the id in the URL.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the node to delete</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> DeleteNodeAsyncWithHttpInfo (long? id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling NodeApi->DeleteNode");

            var localVarPath = "/nodes/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete an node picture Delete an node picture.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns></returns>
        public void DeleteNodePicture (long? nodeId, long? id)
        {
             DeleteNodePictureWithHttpInfo(nodeId, id);
        }

        /// <summary>
        /// Delete an node picture Delete an node picture.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteNodePictureWithHttpInfo (long? nodeId, long? id)
        {
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->DeleteNodePicture");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling NodeApi->DeleteNodePicture");

            var localVarPath = "/nodes/{node_id}/pictures/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNodePicture", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete an node picture Delete an node picture.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteNodePictureAsync (long? nodeId, long? id)
        {
             await DeleteNodePictureAsyncWithHttpInfo(nodeId, id);

        }

        /// <summary>
        /// Delete an node picture Delete an node picture.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> DeleteNodePictureAsyncWithHttpInfo (long? nodeId, long? id)
        {
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->DeleteNodePicture");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling NodeApi->DeleteNodePicture");

            var localVarPath = "/nodes/{node_id}/pictures/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNodePicture", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Download an node picture Download an node picture.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns></returns>
        public void DownloadNodePicture (long? nodeId, long? id)
        {
             DownloadNodePictureWithHttpInfo(nodeId, id);
        }

        /// <summary>
        /// Download an node picture Download an node picture.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DownloadNodePictureWithHttpInfo (long? nodeId, long? id)
        {
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->DownloadNodePicture");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling NodeApi->DownloadNodePicture");

            var localVarPath = "/nodes/{node_id}/pictures/{id}/download";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DownloadNodePicture", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Download an node picture Download an node picture.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DownloadNodePictureAsync (long? nodeId, long? id)
        {
             await DownloadNodePictureAsyncWithHttpInfo(nodeId, id);

        }

        /// <summary>
        /// Download an node picture Download an node picture.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> DownloadNodePictureAsyncWithHttpInfo (long? nodeId, long? id)
        {
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->DownloadNodePicture");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling NodeApi->DownloadNodePicture");

            var localVarPath = "/nodes/{node_id}/pictures/{id}/download";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DownloadNodePicture", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Get all assets of one node Returns a list of all assets that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;status, tenant, parent, pictures, product, product.manufacturer, product.pictures, product.status, product.categories, product.categories.parent, specifications, specifications[key1,key2], product.tenant,                             product.manufacturer.tenant, status.tenant, instrumentations &#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="serialNumber">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productCategoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="manufacturerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusCode">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productionDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="ownershipClaimed">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;serial_number&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, &#x60;last_seen_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>AssetsResponse</returns>
        public AssetsResponse GetAssetsOfNode (long? nodeId, int? page = null, int? perPage = null, string include = null, string serialNumber = null, string productId = null, string productCategoryId = null, string parentId = null, string manufacturerId = null, string statusId = null, string statusCode = null, DateTime? productionDate = null, DateTime? productionDateFrom = null, DateTime? productionDateTo = null, string specificationsKey = null, string specificationsValue = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, bool? ownershipClaimed = null, string permission = null, string orderBy = null)
        {
             ApiResponse<AssetsResponse> localVarResponse = GetAssetsOfNodeWithHttpInfo(nodeId, page, perPage, include, serialNumber, productId, productCategoryId, parentId, manufacturerId, statusId, statusCode, productionDate, productionDateFrom, productionDateTo, specificationsKey, specificationsValue, createdAt, createdAtFrom, createdAtTo, updatedAt, updatedAtFrom, updatedAtTo, ownershipClaimed, permission, orderBy);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get all assets of one node Returns a list of all assets that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;status, tenant, parent, pictures, product, product.manufacturer, product.pictures, product.status, product.categories, product.categories.parent, specifications, specifications[key1,key2], product.tenant,                             product.manufacturer.tenant, status.tenant, instrumentations &#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="serialNumber">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productCategoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="manufacturerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusCode">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productionDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="ownershipClaimed">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;serial_number&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, &#x60;last_seen_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of AssetsResponse</returns>
        public ApiResponse< AssetsResponse > GetAssetsOfNodeWithHttpInfo (long? nodeId, int? page = null, int? perPage = null, string include = null, string serialNumber = null, string productId = null, string productCategoryId = null, string parentId = null, string manufacturerId = null, string statusId = null, string statusCode = null, DateTime? productionDate = null, DateTime? productionDateFrom = null, DateTime? productionDateTo = null, string specificationsKey = null, string specificationsValue = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, bool? ownershipClaimed = null, string permission = null, string orderBy = null)
        {
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->GetAssetsOfNode");

            var localVarPath = "/nodes/{node_id}/assets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (serialNumber != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "serial_number", serialNumber)); // query parameter
            if (productId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "product_id", productId)); // query parameter
            if (productCategoryId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "product_category_id", productCategoryId)); // query parameter
            if (parentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "parent_id", parentId)); // query parameter
            if (manufacturerId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "manufacturer_id", manufacturerId)); // query parameter
            if (statusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_id", statusId)); // query parameter
            if (statusCode != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_code", statusCode)); // query parameter
            if (productionDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "production_date", productionDate)); // query parameter
            if (productionDateFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "production_date_from", productionDateFrom)); // query parameter
            if (productionDateTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "production_date_to", productionDateTo)); // query parameter
            if (specificationsKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_key", specificationsKey)); // query parameter
            if (specificationsValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_value", specificationsValue)); // query parameter
            if (createdAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "created_at", createdAt)); // query parameter
            if (createdAtFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "created_at_from", createdAtFrom)); // query parameter
            if (createdAtTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "created_at_to", createdAtTo)); // query parameter
            if (updatedAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at", updatedAt)); // query parameter
            if (updatedAtFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_from", updatedAtFrom)); // query parameter
            if (updatedAtTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_to", updatedAtTo)); // query parameter
            if (ownershipClaimed != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ownership_claimed", ownershipClaimed)); // query parameter
            if (permission != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "permission", permission)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetAssetsOfNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AssetsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (AssetsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AssetsResponse)));
        }

        /// <summary>
        /// Get all assets of one node Returns a list of all assets that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;status, tenant, parent, pictures, product, product.manufacturer, product.pictures, product.status, product.categories, product.categories.parent, specifications, specifications[key1,key2], product.tenant,                             product.manufacturer.tenant, status.tenant, instrumentations &#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="serialNumber">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productCategoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="manufacturerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusCode">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productionDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="ownershipClaimed">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;serial_number&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, &#x60;last_seen_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of AssetsResponse</returns>
        public async System.Threading.Tasks.Task<AssetsResponse> GetAssetsOfNodeAsync (long? nodeId, int? page = null, int? perPage = null, string include = null, string serialNumber = null, string productId = null, string productCategoryId = null, string parentId = null, string manufacturerId = null, string statusId = null, string statusCode = null, DateTime? productionDate = null, DateTime? productionDateFrom = null, DateTime? productionDateTo = null, string specificationsKey = null, string specificationsValue = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, bool? ownershipClaimed = null, string permission = null, string orderBy = null)
        {
             ApiResponse<AssetsResponse> localVarResponse = await GetAssetsOfNodeAsyncWithHttpInfo(nodeId, page, perPage, include, serialNumber, productId, productCategoryId, parentId, manufacturerId, statusId, statusCode, productionDate, productionDateFrom, productionDateTo, specificationsKey, specificationsValue, createdAt, createdAtFrom, createdAtTo, updatedAt, updatedAtFrom, updatedAtTo, ownershipClaimed, permission, orderBy);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get all assets of one node Returns a list of all assets that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;status, tenant, parent, pictures, product, product.manufacturer, product.pictures, product.status, product.categories, product.categories.parent, specifications, specifications[key1,key2], product.tenant,                             product.manufacturer.tenant, status.tenant, instrumentations &#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="serialNumber">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="productCategoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="manufacturerId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="statusCode">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="productionDate">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="productionDateTo">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="createdAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="createdAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="createdAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAt">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="updatedAtFrom">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="updatedAtTo">Expected date format is YYYY-MM-DDThh:mm:ss (optional)</param>
        /// <param name="ownershipClaimed">Filter accepts true or false (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;serial_number&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, &#x60;last_seen_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (AssetsResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<AssetsResponse>> GetAssetsOfNodeAsyncWithHttpInfo (long? nodeId, int? page = null, int? perPage = null, string include = null, string serialNumber = null, string productId = null, string productCategoryId = null, string parentId = null, string manufacturerId = null, string statusId = null, string statusCode = null, DateTime? productionDate = null, DateTime? productionDateFrom = null, DateTime? productionDateTo = null, string specificationsKey = null, string specificationsValue = null, DateTime? createdAt = null, string createdAtFrom = null, string createdAtTo = null, DateTime? updatedAt = null, string updatedAtFrom = null, string updatedAtTo = null, bool? ownershipClaimed = null, string permission = null, string orderBy = null)
        {
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->GetAssetsOfNode");

            var localVarPath = "/nodes/{node_id}/assets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (serialNumber != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "serial_number", serialNumber)); // query parameter
            if (productId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "product_id", productId)); // query parameter
            if (productCategoryId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "product_category_id", productCategoryId)); // query parameter
            if (parentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "parent_id", parentId)); // query parameter
            if (manufacturerId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "manufacturer_id", manufacturerId)); // query parameter
            if (statusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_id", statusId)); // query parameter
            if (statusCode != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_code", statusCode)); // query parameter
            if (productionDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "production_date", productionDate)); // query parameter
            if (productionDateFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "production_date_from", productionDateFrom)); // query parameter
            if (productionDateTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "production_date_to", productionDateTo)); // query parameter
            if (specificationsKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_key", specificationsKey)); // query parameter
            if (specificationsValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_value", specificationsValue)); // query parameter
            if (createdAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "created_at", createdAt)); // query parameter
            if (createdAtFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "created_at_from", createdAtFrom)); // query parameter
            if (createdAtTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "created_at_to", createdAtTo)); // query parameter
            if (updatedAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at", updatedAt)); // query parameter
            if (updatedAtFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_from", updatedAtFrom)); // query parameter
            if (updatedAtTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "updated_at_to", updatedAtTo)); // query parameter
            if (ownershipClaimed != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ownership_claimed", ownershipClaimed)); // query parameter
            if (permission != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "permission", permission)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetAssetsOfNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AssetsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (AssetsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AssetsResponse)));
        }

        /// <summary>
        /// Get all documents of a node Returns a list of documents. If the query has no matches, the response is an empty list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language. Possible include values: &#x60;&#x60;&#x60;status, tenant, classification, categories, categories.parent, categories.standards, attachments&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="documentVersion">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="number">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="classificationId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="categoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="validFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validUntil">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validAt">Expected date format is YYYY-MM-DD or YYYY-MM or YYYY (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>DocumentsResponse</returns>
        public DocumentsResponse GetDocumentsOfNode (long? nodeId, int? page = null, int? perPage = null, string include = null, string name = null, string documentVersion = null, string number = null, string statusId = null, string classificationId = null, string tenantId = null, string categoryId = null, DateTime? validFrom = null, DateTime? validUntil = null, DateTime? validAt = null, string acceptLanguage = null)
        {
             ApiResponse<DocumentsResponse> localVarResponse = GetDocumentsOfNodeWithHttpInfo(nodeId, page, perPage, include, name, documentVersion, number, statusId, classificationId, tenantId, categoryId, validFrom, validUntil, validAt, acceptLanguage);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get all documents of a node Returns a list of documents. If the query has no matches, the response is an empty list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language. Possible include values: &#x60;&#x60;&#x60;status, tenant, classification, categories, categories.parent, categories.standards, attachments&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="documentVersion">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="number">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="classificationId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="categoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="validFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validUntil">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validAt">Expected date format is YYYY-MM-DD or YYYY-MM or YYYY (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>ApiResponse of DocumentsResponse</returns>
        public ApiResponse< DocumentsResponse > GetDocumentsOfNodeWithHttpInfo (long? nodeId, int? page = null, int? perPage = null, string include = null, string name = null, string documentVersion = null, string number = null, string statusId = null, string classificationId = null, string tenantId = null, string categoryId = null, DateTime? validFrom = null, DateTime? validUntil = null, DateTime? validAt = null, string acceptLanguage = null)
        {
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->GetDocumentsOfNode");

            var localVarPath = "/nodes/{node_id}/documents";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (documentVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "document_version", documentVersion)); // query parameter
            if (number != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "number", number)); // query parameter
            if (statusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_id", statusId)); // query parameter
            if (classificationId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "classification_id", classificationId)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (categoryId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "category_id", categoryId)); // query parameter
            if (validFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "valid_from", validFrom)); // query parameter
            if (validUntil != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "valid_until", validUntil)); // query parameter
            if (validAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "valid_at", validAt)); // query parameter
            if (acceptLanguage != null) localVarHeaderParams.Add("Accept-Language", this.Configuration.ApiClient.ParameterToString(acceptLanguage)); // header parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetDocumentsOfNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<DocumentsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (DocumentsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(DocumentsResponse)));
        }

        /// <summary>
        /// Get all documents of a node Returns a list of documents. If the query has no matches, the response is an empty list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language. Possible include values: &#x60;&#x60;&#x60;status, tenant, classification, categories, categories.parent, categories.standards, attachments&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="documentVersion">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="number">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="classificationId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="categoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="validFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validUntil">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validAt">Expected date format is YYYY-MM-DD or YYYY-MM or YYYY (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of DocumentsResponse</returns>
        public async System.Threading.Tasks.Task<DocumentsResponse> GetDocumentsOfNodeAsync (long? nodeId, int? page = null, int? perPage = null, string include = null, string name = null, string documentVersion = null, string number = null, string statusId = null, string classificationId = null, string tenantId = null, string categoryId = null, DateTime? validFrom = null, DateTime? validUntil = null, DateTime? validAt = null, string acceptLanguage = null)
        {
             ApiResponse<DocumentsResponse> localVarResponse = await GetDocumentsOfNodeAsyncWithHttpInfo(nodeId, page, perPage, include, name, documentVersion, number, statusId, classificationId, tenantId, categoryId, validFrom, validUntil, validAt, acceptLanguage);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get all documents of a node Returns a list of documents. If the query has no matches, the response is an empty list. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language. Possible include values: &#x60;&#x60;&#x60;status, tenant, classification, categories, categories.parent, categories.standards, attachments&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="documentVersion">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="number">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="classificationId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="categoryId">One or multiple ids (comma list). By adding &#x60;+&#x60; after the id, the filter considers the given category and all its children (e.g. 3+). (optional)</param>
        /// <param name="validFrom">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validUntil">Expected date format is YYYY-MM-DD (optional)</param>
        /// <param name="validAt">Expected date format is YYYY-MM-DD or YYYY-MM or YYYY (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of ApiResponse (DocumentsResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<DocumentsResponse>> GetDocumentsOfNodeAsyncWithHttpInfo (long? nodeId, int? page = null, int? perPage = null, string include = null, string name = null, string documentVersion = null, string number = null, string statusId = null, string classificationId = null, string tenantId = null, string categoryId = null, DateTime? validFrom = null, DateTime? validUntil = null, DateTime? validAt = null, string acceptLanguage = null)
        {
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->GetDocumentsOfNode");

            var localVarPath = "/nodes/{node_id}/documents";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (documentVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "document_version", documentVersion)); // query parameter
            if (number != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "number", number)); // query parameter
            if (statusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_id", statusId)); // query parameter
            if (classificationId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "classification_id", classificationId)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (categoryId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "category_id", categoryId)); // query parameter
            if (validFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "valid_from", validFrom)); // query parameter
            if (validUntil != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "valid_until", validUntil)); // query parameter
            if (validAt != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "valid_at", validAt)); // query parameter
            if (acceptLanguage != null) localVarHeaderParams.Add("Accept-Language", this.Configuration.ApiClient.ParameterToString(acceptLanguage)); // header parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetDocumentsOfNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<DocumentsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (DocumentsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(DocumentsResponse)));
        }

        /// <summary>
        /// Get all instrumentations of one node Returns a list of all instrumentations that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;specifications, specifications[key1,key2], pictures, tenant, parent, status, worst_asset_status, type&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="tag">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="criticality">Filter accepts undefined, low, medium or high (optional)</param>
        /// <param name="accessibility">Filter accepts undefined, easy, moderate or difficult (optional)</param>
        /// <param name="assetStatusId">One or multiple ids (comma list). Expected id format is integer. This retrieves all Instrumentations where at least one of its assets has one of the given statuses. (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;tag&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>InstrumentationsResponse</returns>
        public InstrumentationsResponse GetInstrumentationsOfNode (long? nodeId, int? page = null, int? perPage = null, string include = null, string tag = null, string statusId = null, string typeId = null, string parentId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string criticality = null, string accessibility = null, string assetStatusId = null, string permission = null, string orderBy = null)
        {
             ApiResponse<InstrumentationsResponse> localVarResponse = GetInstrumentationsOfNodeWithHttpInfo(nodeId, page, perPage, include, tag, statusId, typeId, parentId, tenantId, specificationsKey, specificationsValue, criticality, accessibility, assetStatusId, permission, orderBy);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get all instrumentations of one node Returns a list of all instrumentations that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;specifications, specifications[key1,key2], pictures, tenant, parent, status, worst_asset_status, type&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="tag">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="criticality">Filter accepts undefined, low, medium or high (optional)</param>
        /// <param name="accessibility">Filter accepts undefined, easy, moderate or difficult (optional)</param>
        /// <param name="assetStatusId">One or multiple ids (comma list). Expected id format is integer. This retrieves all Instrumentations where at least one of its assets has one of the given statuses. (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;tag&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of InstrumentationsResponse</returns>
        public ApiResponse< InstrumentationsResponse > GetInstrumentationsOfNodeWithHttpInfo (long? nodeId, int? page = null, int? perPage = null, string include = null, string tag = null, string statusId = null, string typeId = null, string parentId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string criticality = null, string accessibility = null, string assetStatusId = null, string permission = null, string orderBy = null)
        {
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->GetInstrumentationsOfNode");

            var localVarPath = "/nodes/{node_id}/instrumentations";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (tag != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tag", tag)); // query parameter
            if (statusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_id", statusId)); // query parameter
            if (typeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type_id", typeId)); // query parameter
            if (parentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "parent_id", parentId)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (specificationsKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_key", specificationsKey)); // query parameter
            if (specificationsValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_value", specificationsValue)); // query parameter
            if (criticality != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "criticality", criticality)); // query parameter
            if (accessibility != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "accessibility", accessibility)); // query parameter
            if (assetStatusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asset_status_id", assetStatusId)); // query parameter
            if (permission != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "permission", permission)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetInstrumentationsOfNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InstrumentationsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InstrumentationsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InstrumentationsResponse)));
        }

        /// <summary>
        /// Get all instrumentations of one node Returns a list of all instrumentations that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;specifications, specifications[key1,key2], pictures, tenant, parent, status, worst_asset_status, type&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="tag">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="criticality">Filter accepts undefined, low, medium or high (optional)</param>
        /// <param name="accessibility">Filter accepts undefined, easy, moderate or difficult (optional)</param>
        /// <param name="assetStatusId">One or multiple ids (comma list). Expected id format is integer. This retrieves all Instrumentations where at least one of its assets has one of the given statuses. (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;tag&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of InstrumentationsResponse</returns>
        public async System.Threading.Tasks.Task<InstrumentationsResponse> GetInstrumentationsOfNodeAsync (long? nodeId, int? page = null, int? perPage = null, string include = null, string tag = null, string statusId = null, string typeId = null, string parentId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string criticality = null, string accessibility = null, string assetStatusId = null, string permission = null, string orderBy = null)
        {
             ApiResponse<InstrumentationsResponse> localVarResponse = await GetInstrumentationsOfNodeAsyncWithHttpInfo(nodeId, page, perPage, include, tag, statusId, typeId, parentId, tenantId, specificationsKey, specificationsValue, criticality, accessibility, assetStatusId, permission, orderBy);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get all instrumentations of one node Returns a list of all instrumentations that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;specifications, specifications[key1,key2], pictures, tenant, parent, status, worst_asset_status, type&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="tag">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="criticality">Filter accepts undefined, low, medium or high (optional)</param>
        /// <param name="accessibility">Filter accepts undefined, easy, moderate or difficult (optional)</param>
        /// <param name="assetStatusId">One or multiple ids (comma list). Expected id format is integer. This retrieves all Instrumentations where at least one of its assets has one of the given statuses. (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;tag&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (InstrumentationsResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InstrumentationsResponse>> GetInstrumentationsOfNodeAsyncWithHttpInfo (long? nodeId, int? page = null, int? perPage = null, string include = null, string tag = null, string statusId = null, string typeId = null, string parentId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string criticality = null, string accessibility = null, string assetStatusId = null, string permission = null, string orderBy = null)
        {
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->GetInstrumentationsOfNode");

            var localVarPath = "/nodes/{node_id}/instrumentations";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (tag != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tag", tag)); // query parameter
            if (statusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_id", statusId)); // query parameter
            if (typeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type_id", typeId)); // query parameter
            if (parentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "parent_id", parentId)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (specificationsKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_key", specificationsKey)); // query parameter
            if (specificationsValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_value", specificationsValue)); // query parameter
            if (criticality != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "criticality", criticality)); // query parameter
            if (accessibility != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "accessibility", accessibility)); // query parameter
            if (assetStatusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "asset_status_id", assetStatusId)); // query parameter
            if (permission != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "permission", permission)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetInstrumentationsOfNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InstrumentationsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InstrumentationsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InstrumentationsResponse)));
        }

        /// <summary>
        /// Get the type of the specific node Returns the type of the node. Needed if only permission on node but not on tenant. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language. Possible include values: &#x60;&#x60;&#x60;tenant&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>NodeTypeResponse</returns>
        public NodeTypeResponse GetNodeIdType (long? nodeId, string include = null, string acceptLanguage = null)
        {
             ApiResponse<NodeTypeResponse> localVarResponse = GetNodeIdTypeWithHttpInfo(nodeId, include, acceptLanguage);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get the type of the specific node Returns the type of the node. Needed if only permission on node but not on tenant. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language. Possible include values: &#x60;&#x60;&#x60;tenant&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>ApiResponse of NodeTypeResponse</returns>
        public ApiResponse< NodeTypeResponse > GetNodeIdTypeWithHttpInfo (long? nodeId, string include = null, string acceptLanguage = null)
        {
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->GetNodeIdType");

            var localVarPath = "/nodes/{node_id}/type";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (acceptLanguage != null) localVarHeaderParams.Add("Accept-Language", this.Configuration.ApiClient.ParameterToString(acceptLanguage)); // header parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetNodeIdType", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<NodeTypeResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (NodeTypeResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(NodeTypeResponse)));
        }

        /// <summary>
        /// Get the type of the specific node Returns the type of the node. Needed if only permission on node but not on tenant. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language. Possible include values: &#x60;&#x60;&#x60;tenant&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of NodeTypeResponse</returns>
        public async System.Threading.Tasks.Task<NodeTypeResponse> GetNodeIdTypeAsync (long? nodeId, string include = null, string acceptLanguage = null)
        {
             ApiResponse<NodeTypeResponse> localVarResponse = await GetNodeIdTypeAsyncWithHttpInfo(nodeId, include, acceptLanguage);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get the type of the specific node Returns the type of the node. Needed if only permission on node but not on tenant. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language. Possible include values: &#x60;&#x60;&#x60;tenant&#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of ApiResponse (NodeTypeResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<NodeTypeResponse>> GetNodeIdTypeAsyncWithHttpInfo (long? nodeId, string include = null, string acceptLanguage = null)
        {
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->GetNodeIdType");

            var localVarPath = "/nodes/{node_id}/type";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (acceptLanguage != null) localVarHeaderParams.Add("Accept-Language", this.Configuration.ApiClient.ParameterToString(acceptLanguage)); // header parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetNodeIdType", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<NodeTypeResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (NodeTypeResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(NodeTypeResponse)));
        }

        /// <summary>
        /// Get an node picture Get a single picture of an node.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>PictureResponse</returns>
        public PictureResponse GetNodePicture (long? nodeId, long? id)
        {
             ApiResponse<PictureResponse> localVarResponse = GetNodePictureWithHttpInfo(nodeId, id);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get an node picture Get a single picture of an node.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>ApiResponse of PictureResponse</returns>
        public ApiResponse< PictureResponse > GetNodePictureWithHttpInfo (long? nodeId, long? id)
        {
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->GetNodePicture");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling NodeApi->GetNodePicture");

            var localVarPath = "/nodes/{node_id}/pictures/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetNodePicture", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PictureResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (PictureResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(PictureResponse)));
        }

        /// <summary>
        /// Get an node picture Get a single picture of an node.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>Task of PictureResponse</returns>
        public async System.Threading.Tasks.Task<PictureResponse> GetNodePictureAsync (long? nodeId, long? id)
        {
             ApiResponse<PictureResponse> localVarResponse = await GetNodePictureAsyncWithHttpInfo(nodeId, id);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get an node picture Get a single picture of an node.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>Task of ApiResponse (PictureResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<PictureResponse>> GetNodePictureAsyncWithHttpInfo (long? nodeId, long? id)
        {
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->GetNodePicture");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling NodeApi->GetNodePicture");

            var localVarPath = "/nodes/{node_id}/pictures/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetNodePicture", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PictureResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (PictureResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(PictureResponse)));
        }

        /// <summary>
        /// Get node pictures Get all pictures of an node.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the node</param>
        /// <param name="width">filter by width (optional)</param>
        /// <param name="widthFrom">filter by width_from (optional)</param>
        /// <param name="widthTo">filter by width_to (optional)</param>
        /// <param name="height">filter by height (optional)</param>
        /// <param name="heightFrom">filter by height_from (optional)</param>
        /// <param name="heightTo">filter by height_to (optional)</param>
        /// <returns>PicturesResponse</returns>
        public PicturesResponse GetNodePictures (long? id, int? width = null, int? widthFrom = null, int? widthTo = null, int? height = null, int? heightFrom = null, int? heightTo = null)
        {
             ApiResponse<PicturesResponse> localVarResponse = GetNodePicturesWithHttpInfo(id, width, widthFrom, widthTo, height, heightFrom, heightTo);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get node pictures Get all pictures of an node.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the node</param>
        /// <param name="width">filter by width (optional)</param>
        /// <param name="widthFrom">filter by width_from (optional)</param>
        /// <param name="widthTo">filter by width_to (optional)</param>
        /// <param name="height">filter by height (optional)</param>
        /// <param name="heightFrom">filter by height_from (optional)</param>
        /// <param name="heightTo">filter by height_to (optional)</param>
        /// <returns>ApiResponse of PicturesResponse</returns>
        public ApiResponse< PicturesResponse > GetNodePicturesWithHttpInfo (long? id, int? width = null, int? widthFrom = null, int? widthTo = null, int? height = null, int? heightFrom = null, int? heightTo = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling NodeApi->GetNodePictures");

            var localVarPath = "/nodes/{id}/pictures";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (width != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "width", width)); // query parameter
            if (widthFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "width_from", widthFrom)); // query parameter
            if (widthTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "width_to", widthTo)); // query parameter
            if (height != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "height", height)); // query parameter
            if (heightFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "height_from", heightFrom)); // query parameter
            if (heightTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "height_to", heightTo)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetNodePictures", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PicturesResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (PicturesResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(PicturesResponse)));
        }

        /// <summary>
        /// Get node pictures Get all pictures of an node.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the node</param>
        /// <param name="width">filter by width (optional)</param>
        /// <param name="widthFrom">filter by width_from (optional)</param>
        /// <param name="widthTo">filter by width_to (optional)</param>
        /// <param name="height">filter by height (optional)</param>
        /// <param name="heightFrom">filter by height_from (optional)</param>
        /// <param name="heightTo">filter by height_to (optional)</param>
        /// <returns>Task of PicturesResponse</returns>
        public async System.Threading.Tasks.Task<PicturesResponse> GetNodePicturesAsync (long? id, int? width = null, int? widthFrom = null, int? widthTo = null, int? height = null, int? heightFrom = null, int? heightTo = null)
        {
             ApiResponse<PicturesResponse> localVarResponse = await GetNodePicturesAsyncWithHttpInfo(id, width, widthFrom, widthTo, height, heightFrom, heightTo);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get node pictures Get all pictures of an node.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the node</param>
        /// <param name="width">filter by width (optional)</param>
        /// <param name="widthFrom">filter by width_from (optional)</param>
        /// <param name="widthTo">filter by width_to (optional)</param>
        /// <param name="height">filter by height (optional)</param>
        /// <param name="heightFrom">filter by height_from (optional)</param>
        /// <param name="heightTo">filter by height_to (optional)</param>
        /// <returns>Task of ApiResponse (PicturesResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<PicturesResponse>> GetNodePicturesAsyncWithHttpInfo (long? id, int? width = null, int? widthFrom = null, int? widthTo = null, int? height = null, int? heightFrom = null, int? heightTo = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling NodeApi->GetNodePictures");

            var localVarPath = "/nodes/{id}/pictures";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (width != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "width", width)); // query parameter
            if (widthFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "width_from", widthFrom)); // query parameter
            if (widthTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "width_to", widthTo)); // query parameter
            if (height != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "height", height)); // query parameter
            if (heightFrom != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "height_from", heightFrom)); // query parameter
            if (heightTo != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "height_to", heightTo)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetNodePictures", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PicturesResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (PicturesResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(PicturesResponse)));
        }

        /// <summary>
        /// Get all possible types of the specified node Returns a list of all possible node types for the specified node. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>NodeTypes</returns>
        public NodeTypes GetNodeTypesOptions (long? nodeId, int? page = null, int? perPage = null, string tenantId = null, string name = null, string code = null, string acceptLanguage = null)
        {
             ApiResponse<NodeTypes> localVarResponse = GetNodeTypesOptionsWithHttpInfo(nodeId, page, perPage, tenantId, name, code, acceptLanguage);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get all possible types of the specified node Returns a list of all possible node types for the specified node. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>ApiResponse of NodeTypes</returns>
        public ApiResponse< NodeTypes > GetNodeTypesOptionsWithHttpInfo (long? nodeId, int? page = null, int? perPage = null, string tenantId = null, string name = null, string code = null, string acceptLanguage = null)
        {
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->GetNodeTypesOptions");

            var localVarPath = "/nodes/{node_id}/type-options";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (code != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "code", code)); // query parameter
            if (acceptLanguage != null) localVarHeaderParams.Add("Accept-Language", this.Configuration.ApiClient.ParameterToString(acceptLanguage)); // header parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetNodeTypesOptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<NodeTypes>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (NodeTypes) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(NodeTypes)));
        }

        /// <summary>
        /// Get all possible types of the specified node Returns a list of all possible node types for the specified node. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of NodeTypes</returns>
        public async System.Threading.Tasks.Task<NodeTypes> GetNodeTypesOptionsAsync (long? nodeId, int? page = null, int? perPage = null, string tenantId = null, string name = null, string code = null, string acceptLanguage = null)
        {
             ApiResponse<NodeTypes> localVarResponse = await GetNodeTypesOptionsAsyncWithHttpInfo(nodeId, page, perPage, tenantId, name, code, acceptLanguage);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get all possible types of the specified node Returns a list of all possible node types for the specified node. Parameters supporting translation: &#x60;&#x60;&#x60;name, description&#x60;&#x60;&#x60;. To get a translation set Accept-Language.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="code">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="acceptLanguage">The client&#x27;s accepted languages. One or several (e.g. fr,de,en) (optional)</param>
        /// <returns>Task of ApiResponse (NodeTypes)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<NodeTypes>> GetNodeTypesOptionsAsyncWithHttpInfo (long? nodeId, int? page = null, int? perPage = null, string tenantId = null, string name = null, string code = null, string acceptLanguage = null)
        {
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->GetNodeTypesOptions");

            var localVarPath = "/nodes/{node_id}/type-options";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (code != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "code", code)); // query parameter
            if (acceptLanguage != null) localVarHeaderParams.Add("Accept-Language", this.Configuration.ApiClient.ParameterToString(acceptLanguage)); // header parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetNodeTypesOptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<NodeTypes>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (NodeTypes) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(NodeTypes)));
        }

        /// <summary>
        /// Get a range of nodes Returns a list of nodes in your accessible scope. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;parent, tenant, type, type.parent, specifications, specifications[key1,key2], pictures, instrumentations, instrumentations.specifications, instrumentations.specifications[key1,key2], instrumentations.values, instrumentations.values.unit, instrumentations.values_in_preferred_units, instrumentations.values_in_preferred_units.unit, worst_asset_status&#x60;&#x60;&#x60; Hidden nodes are not returned by default, if the hidden nodes should be included, add \&quot;&#x60;&#x60;&#x60;hidden&#x60;&#x60;&#x60;\&quot; to the include parameter 
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>NodesResponse</returns>
        public NodesResponse GetNodes (int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string parentId = null, string tenantId = null, string permission = null, string orderBy = null)
        {
             ApiResponse<NodesResponse> localVarResponse = GetNodesWithHttpInfo(page, perPage, include, name, typeId, parentId, tenantId, permission, orderBy);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get a range of nodes Returns a list of nodes in your accessible scope. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;parent, tenant, type, type.parent, specifications, specifications[key1,key2], pictures, instrumentations, instrumentations.specifications, instrumentations.specifications[key1,key2], instrumentations.values, instrumentations.values.unit, instrumentations.values_in_preferred_units, instrumentations.values_in_preferred_units.unit, worst_asset_status&#x60;&#x60;&#x60; Hidden nodes are not returned by default, if the hidden nodes should be included, add \&quot;&#x60;&#x60;&#x60;hidden&#x60;&#x60;&#x60;\&quot; to the include parameter 
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of NodesResponse</returns>
        public ApiResponse< NodesResponse > GetNodesWithHttpInfo (int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string parentId = null, string tenantId = null, string permission = null, string orderBy = null)
        {

            var localVarPath = "/nodes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (typeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type_id", typeId)); // query parameter
            if (parentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "parent_id", parentId)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (permission != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "permission", permission)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetNodes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<NodesResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (NodesResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(NodesResponse)));
        }

        /// <summary>
        /// Get a range of nodes Returns a list of nodes in your accessible scope. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;parent, tenant, type, type.parent, specifications, specifications[key1,key2], pictures, instrumentations, instrumentations.specifications, instrumentations.specifications[key1,key2], instrumentations.values, instrumentations.values.unit, instrumentations.values_in_preferred_units, instrumentations.values_in_preferred_units.unit, worst_asset_status&#x60;&#x60;&#x60; Hidden nodes are not returned by default, if the hidden nodes should be included, add \&quot;&#x60;&#x60;&#x60;hidden&#x60;&#x60;&#x60;\&quot; to the include parameter 
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of NodesResponse</returns>
        public async System.Threading.Tasks.Task<NodesResponse> GetNodesAsync (int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string parentId = null, string tenantId = null, string permission = null, string orderBy = null)
        {
             ApiResponse<NodesResponse> localVarResponse = await GetNodesAsyncWithHttpInfo(page, perPage, include, name, typeId, parentId, tenantId, permission, orderBy);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get a range of nodes Returns a list of nodes in your accessible scope. If the query has no matches, the response is an empty list.  Possible include values: &#x60;&#x60;&#x60;parent, tenant, type, type.parent, specifications, specifications[key1,key2], pictures, instrumentations, instrumentations.specifications, instrumentations.specifications[key1,key2], instrumentations.values, instrumentations.values.unit, instrumentations.values_in_preferred_units, instrumentations.values_in_preferred_units.unit, worst_asset_status&#x60;&#x60;&#x60; Hidden nodes are not returned by default, if the hidden nodes should be included, add \&quot;&#x60;&#x60;&#x60;hidden&#x60;&#x60;&#x60;\&quot; to the include parameter 
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="parentId">One or multiple ids (comma list). \&quot;null\&quot; to retrieve all objects without parent, \&quot;!null\&quot; for all objects with parent. (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;, add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (NodesResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<NodesResponse>> GetNodesAsyncWithHttpInfo (int? page = null, int? perPage = null, string include = null, string name = null, string typeId = null, string parentId = null, string tenantId = null, string permission = null, string orderBy = null)
        {

            var localVarPath = "/nodes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (typeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type_id", typeId)); // query parameter
            if (parentId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "parent_id", parentId)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (permission != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "permission", permission)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetNodes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<NodesResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (NodesResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(NodesResponse)));
        }

        /// <summary>
        /// Get a single node Get a specific node in your accessible scope, identified by the id in the URL.  Possible include values: &#x60;&#x60;&#x60;parent, tenant, type, specifications, specifications[key1,key2], pictures, instrumentations, instrumentations.specifications, instrumentations.specifications[key1,key2], instrumentations.values, instrumentations.values.unit, instrumentations.values_in_preferred_units, instrumentations.values_in_preferred_units.unit, worst_asset_status&#x60;&#x60;&#x60; 
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the node to fetch</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <returns>NodeResponse</returns>
        public NodeResponse GetNodesById (long? id, string include = null)
        {
             ApiResponse<NodeResponse> localVarResponse = GetNodesByIdWithHttpInfo(id, include);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get a single node Get a specific node in your accessible scope, identified by the id in the URL.  Possible include values: &#x60;&#x60;&#x60;parent, tenant, type, specifications, specifications[key1,key2], pictures, instrumentations, instrumentations.specifications, instrumentations.specifications[key1,key2], instrumentations.values, instrumentations.values.unit, instrumentations.values_in_preferred_units, instrumentations.values_in_preferred_units.unit, worst_asset_status&#x60;&#x60;&#x60; 
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the node to fetch</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <returns>ApiResponse of NodeResponse</returns>
        public ApiResponse< NodeResponse > GetNodesByIdWithHttpInfo (long? id, string include = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling NodeApi->GetNodesById");

            var localVarPath = "/nodes/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetNodesById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<NodeResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (NodeResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(NodeResponse)));
        }

        /// <summary>
        /// Get a single node Get a specific node in your accessible scope, identified by the id in the URL.  Possible include values: &#x60;&#x60;&#x60;parent, tenant, type, specifications, specifications[key1,key2], pictures, instrumentations, instrumentations.specifications, instrumentations.specifications[key1,key2], instrumentations.values, instrumentations.values.unit, instrumentations.values_in_preferred_units, instrumentations.values_in_preferred_units.unit, worst_asset_status&#x60;&#x60;&#x60; 
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the node to fetch</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <returns>Task of NodeResponse</returns>
        public async System.Threading.Tasks.Task<NodeResponse> GetNodesByIdAsync (long? id, string include = null)
        {
             ApiResponse<NodeResponse> localVarResponse = await GetNodesByIdAsyncWithHttpInfo(id, include);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get a single node Get a specific node in your accessible scope, identified by the id in the URL.  Possible include values: &#x60;&#x60;&#x60;parent, tenant, type, specifications, specifications[key1,key2], pictures, instrumentations, instrumentations.specifications, instrumentations.specifications[key1,key2], instrumentations.values, instrumentations.values.unit, instrumentations.values_in_preferred_units, instrumentations.values_in_preferred_units.unit, worst_asset_status&#x60;&#x60;&#x60; 
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Id of the node to fetch</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <returns>Task of ApiResponse (NodeResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<NodeResponse>> GetNodesByIdAsyncWithHttpInfo (long? id, string include = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling NodeApi->GetNodesById");

            var localVarPath = "/nodes/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetNodesById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<NodeResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (NodeResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(NodeResponse)));
        }

        /// <summary>
        /// Get all recipes of one node Returns a list of all recipes that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;Possible include values: pictures, specifications, specifications[key1,key2], tenant, status, type, type.tenant, type.parent &#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>RecipesResponse</returns>
        public RecipesResponse GetRecipesOfNode (long? nodeId, int? page = null, int? perPage = null, string include = null, string name = null, string statusId = null, string typeId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string orderBy = null)
        {
             ApiResponse<RecipesResponse> localVarResponse = GetRecipesOfNodeWithHttpInfo(nodeId, page, perPage, include, name, statusId, typeId, tenantId, specificationsKey, specificationsValue, orderBy);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get all recipes of one node Returns a list of all recipes that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;Possible include values: pictures, specifications, specifications[key1,key2], tenant, status, type, type.tenant, type.parent &#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of RecipesResponse</returns>
        public ApiResponse< RecipesResponse > GetRecipesOfNodeWithHttpInfo (long? nodeId, int? page = null, int? perPage = null, string include = null, string name = null, string statusId = null, string typeId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string orderBy = null)
        {
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->GetRecipesOfNode");

            var localVarPath = "/nodes/{node_id}/recipes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (statusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_id", statusId)); // query parameter
            if (typeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type_id", typeId)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (specificationsKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_key", specificationsKey)); // query parameter
            if (specificationsValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_value", specificationsValue)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetRecipesOfNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<RecipesResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (RecipesResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(RecipesResponse)));
        }

        /// <summary>
        /// Get all recipes of one node Returns a list of all recipes that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;Possible include values: pictures, specifications, specifications[key1,key2], tenant, status, type, type.tenant, type.parent &#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of RecipesResponse</returns>
        public async System.Threading.Tasks.Task<RecipesResponse> GetRecipesOfNodeAsync (long? nodeId, int? page = null, int? perPage = null, string include = null, string name = null, string statusId = null, string typeId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string orderBy = null)
        {
             ApiResponse<RecipesResponse> localVarResponse = await GetRecipesOfNodeAsyncWithHttpInfo(nodeId, page, perPage, include, name, statusId, typeId, tenantId, specificationsKey, specificationsValue, orderBy);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get all recipes of one node Returns a list of all recipes that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;Possible include values: pictures, specifications, specifications[key1,key2], tenant, status, type, type.tenant, type.parent &#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (RecipesResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<RecipesResponse>> GetRecipesOfNodeAsyncWithHttpInfo (long? nodeId, int? page = null, int? perPage = null, string include = null, string name = null, string statusId = null, string typeId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string orderBy = null)
        {
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->GetRecipesOfNode");

            var localVarPath = "/nodes/{node_id}/recipes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (statusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_id", statusId)); // query parameter
            if (typeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type_id", typeId)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (specificationsKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_key", specificationsKey)); // query parameter
            if (specificationsValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_value", specificationsValue)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetRecipesOfNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<RecipesResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (RecipesResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(RecipesResponse)));
        }

        /// <summary>
        /// Get existing asset specification keys Returns the existing specification keys in all readable nodes.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>SpecificationKeys</returns>
        public SpecificationKeys GetSpecificationKeysOfNodes (string key = null, bool? uiVisible = null)
        {
             ApiResponse<SpecificationKeys> localVarResponse = GetSpecificationKeysOfNodesWithHttpInfo(key, uiVisible);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get existing asset specification keys Returns the existing specification keys in all readable nodes.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>ApiResponse of SpecificationKeys</returns>
        public ApiResponse< SpecificationKeys > GetSpecificationKeysOfNodesWithHttpInfo (string key = null, bool? uiVisible = null)
        {

            var localVarPath = "/node/specification_keys";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            if (uiVisible != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ui_visible", uiVisible)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationKeysOfNodes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationKeys>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationKeys) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationKeys)));
        }

        /// <summary>
        /// Get existing asset specification keys Returns the existing specification keys in all readable nodes.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of SpecificationKeys</returns>
        public async System.Threading.Tasks.Task<SpecificationKeys> GetSpecificationKeysOfNodesAsync (string key = null, bool? uiVisible = null)
        {
             ApiResponse<SpecificationKeys> localVarResponse = await GetSpecificationKeysOfNodesAsyncWithHttpInfo(key, uiVisible);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get existing asset specification keys Returns the existing specification keys in all readable nodes.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationKeys)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SpecificationKeys>> GetSpecificationKeysOfNodesAsyncWithHttpInfo (string key = null, bool? uiVisible = null)
        {

            var localVarPath = "/node/specification_keys";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            if (uiVisible != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ui_visible", uiVisible)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationKeysOfNodes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationKeys>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationKeys) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationKeys)));
        }

        /// <summary>
        /// Get specifications of a node Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the specified node</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>SpecificationsUIVisibleResponse</returns>
        public SpecificationsUIVisibleResponse GetSpecificationsOfNode (long? nodeId, string key = null, bool? uiVisible = null)
        {
             ApiResponse<SpecificationsUIVisibleResponse> localVarResponse = GetSpecificationsOfNodeWithHttpInfo(nodeId, key, uiVisible);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get specifications of a node Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the specified node</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>ApiResponse of SpecificationsUIVisibleResponse</returns>
        public ApiResponse< SpecificationsUIVisibleResponse > GetSpecificationsOfNodeWithHttpInfo (long? nodeId, string key = null, bool? uiVisible = null)
        {
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->GetSpecificationsOfNode");

            var localVarPath = "/nodes/{node_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            if (uiVisible != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ui_visible", uiVisible)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationsOfNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationsUIVisibleResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationsUIVisibleResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationsUIVisibleResponse)));
        }

        /// <summary>
        /// Get specifications of a node Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the specified node</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of SpecificationsUIVisibleResponse</returns>
        public async System.Threading.Tasks.Task<SpecificationsUIVisibleResponse> GetSpecificationsOfNodeAsync (long? nodeId, string key = null, bool? uiVisible = null)
        {
             ApiResponse<SpecificationsUIVisibleResponse> localVarResponse = await GetSpecificationsOfNodeAsyncWithHttpInfo(nodeId, key, uiVisible);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get specifications of a node Returns the specification of an object in your accessible scope. If no specifications are defined, this is just an empty object. Specification must have the form below.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">Id of the specified node</param>
        /// <param name="key">Filter accepts &#x27;*&#x27; as wildcard (optional)</param>
        /// <param name="uiVisible"> (optional)</param>
        /// <returns>Task of ApiResponse (SpecificationsUIVisibleResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SpecificationsUIVisibleResponse>> GetSpecificationsOfNodeAsyncWithHttpInfo (long? nodeId, string key = null, bool? uiVisible = null)
        {
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->GetSpecificationsOfNode");

            var localVarPath = "/nodes/{node_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (key != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "key", key)); // query parameter
            if (uiVisible != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ui_visible", uiVisible)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSpecificationsOfNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SpecificationsUIVisibleResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SpecificationsUIVisibleResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SpecificationsUIVisibleResponse)));
        }

        /// <summary>
        /// Get all systems of one node Returns a list of all systems that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;pictures, specifications, specifications[key1,key2], tenant, parent, status, type, type.tenant, type.parent, worst_asset_status &#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>SystemsResponse</returns>
        public SystemsResponse GetSystemsOfNode (long? nodeId, int? page = null, int? perPage = null, string include = null, string name = null, string statusId = null, string typeId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string permission = null, string orderBy = null)
        {
             ApiResponse<SystemsResponse> localVarResponse = GetSystemsOfNodeWithHttpInfo(nodeId, page, perPage, include, name, statusId, typeId, tenantId, specificationsKey, specificationsValue, permission, orderBy);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get all systems of one node Returns a list of all systems that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;pictures, specifications, specifications[key1,key2], tenant, parent, status, type, type.tenant, type.parent, worst_asset_status &#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>ApiResponse of SystemsResponse</returns>
        public ApiResponse< SystemsResponse > GetSystemsOfNodeWithHttpInfo (long? nodeId, int? page = null, int? perPage = null, string include = null, string name = null, string statusId = null, string typeId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string permission = null, string orderBy = null)
        {
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->GetSystemsOfNode");

            var localVarPath = "/nodes/{node_id}/systems";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (statusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_id", statusId)); // query parameter
            if (typeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type_id", typeId)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (specificationsKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_key", specificationsKey)); // query parameter
            if (specificationsValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_value", specificationsValue)); // query parameter
            if (permission != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "permission", permission)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSystemsOfNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SystemsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SystemsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SystemsResponse)));
        }

        /// <summary>
        /// Get all systems of one node Returns a list of all systems that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;pictures, specifications, specifications[key1,key2], tenant, parent, status, type, type.tenant, type.parent, worst_asset_status &#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of SystemsResponse</returns>
        public async System.Threading.Tasks.Task<SystemsResponse> GetSystemsOfNodeAsync (long? nodeId, int? page = null, int? perPage = null, string include = null, string name = null, string statusId = null, string typeId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string permission = null, string orderBy = null)
        {
             ApiResponse<SystemsResponse> localVarResponse = await GetSystemsOfNodeAsyncWithHttpInfo(nodeId, page, perPage, include, name, statusId, typeId, tenantId, specificationsKey, specificationsValue, permission, orderBy);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get all systems of one node Returns a list of all systems that are available in your scope. You can apply query parameters in the request to get a filtered list. If the query has no matches, the response will show an empty array.  Possible include values: &#x60;&#x60;&#x60;pictures, specifications, specifications[key1,key2], tenant, parent, status, type, type.tenant, type.parent, worst_asset_status &#x60;&#x60;&#x60;
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="nodeId">The resource defined in the URL</param>
        /// <param name="page">Page number to load (optional)</param>
        /// <param name="perPage">Number of items to load per page (optional)</param>
        /// <param name="include">Comma separated list of objects to include in response (optional)</param>
        /// <param name="name">Filter accepts &#x60;*&#x60; as wildcard (optional)</param>
        /// <param name="statusId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="typeId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="tenantId">One or multiple ids (comma list). Expected id format is integer (optional)</param>
        /// <param name="specificationsKey">Filter accepts &#x60;*&#x60; as wildcard (if used as single specifications filter), supports comma list of keys in connection with specifications_value filter (optional)</param>
        /// <param name="specificationsValue">Filter accepts &#x60;*&#x60; as wildcard, supports comma list of values in connection with specifications_key filter. Does not work for vectors (optional)</param>
        /// <param name="permission">Filter by permission of current user. Accepts &#x60;can_permit&#x60;, &#x60;can_delete&#x60;, &#x60;can_update&#x60;, &#x60;can_read&#x60; (default) (optional)</param>
        /// <param name="orderBy">Order result by attribute value, accepts &#x60;id&#x60;, &#x60;name&#x60;, &#x60;created_at&#x60; or &#x60;updated_at&#x60;. Add &#x60;-&#x60; as a prefix for descending order. Default value is &#x60;id&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (SystemsResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SystemsResponse>> GetSystemsOfNodeAsyncWithHttpInfo (long? nodeId, int? page = null, int? perPage = null, string include = null, string name = null, string statusId = null, string typeId = null, string tenantId = null, string specificationsKey = null, string specificationsValue = null, string permission = null, string orderBy = null)
        {
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->GetSystemsOfNode");

            var localVarPath = "/nodes/{node_id}/systems";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (page != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "page", page)); // query parameter
            if (perPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "per_page", perPage)); // query parameter
            if (include != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include", include)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (statusId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "status_id", statusId)); // query parameter
            if (typeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type_id", typeId)); // query parameter
            if (tenantId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tenant_id", tenantId)); // query parameter
            if (specificationsKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_key", specificationsKey)); // query parameter
            if (specificationsValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "specifications_value", specificationsValue)); // query parameter
            if (permission != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "permission", permission)); // query parameter
            if (orderBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "order_by", orderBy)); // query parameter
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSystemsOfNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SystemsResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SystemsResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SystemsResponse)));
        }

        /// <summary>
        /// Remove assets from a node Remove one or more assets from a node in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the node and on the asset.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the assets will be removed</param>
        /// <returns></returns>
        public void RemoveAssetsFromNode (AssetIDs body, long? nodeId)
        {
             RemoveAssetsFromNodeWithHttpInfo(body, nodeId);
        }

        /// <summary>
        /// Remove assets from a node Remove one or more assets from a node in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the node and on the asset.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the assets will be removed</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RemoveAssetsFromNodeWithHttpInfo (AssetIDs body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->RemoveAssetsFromNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->RemoveAssetsFromNode");

            var localVarPath = "/nodes/{node_id}/assets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveAssetsFromNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Remove assets from a node Remove one or more assets from a node in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the node and on the asset.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the assets will be removed</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveAssetsFromNodeAsync (AssetIDs body, long? nodeId)
        {
             await RemoveAssetsFromNodeAsyncWithHttpInfo(body, nodeId);

        }

        /// <summary>
        /// Remove assets from a node Remove one or more assets from a node in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the node and on the asset.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the assets will be removed</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RemoveAssetsFromNodeAsyncWithHttpInfo (AssetIDs body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->RemoveAssetsFromNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->RemoveAssetsFromNode");

            var localVarPath = "/nodes/{node_id}/assets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveAssetsFromNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Remove documents from a node Remove one or more documents from a node. This action requires &#x60;can_update&#x60; permission on the node and &#x60;can_read&#x60; permission on the document.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the documents will be removed</param>
        /// <returns></returns>
        public void RemoveDocumentsFromNode (DocumentIDs body, long? nodeId)
        {
             RemoveDocumentsFromNodeWithHttpInfo(body, nodeId);
        }

        /// <summary>
        /// Remove documents from a node Remove one or more documents from a node. This action requires &#x60;can_update&#x60; permission on the node and &#x60;can_read&#x60; permission on the document.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the documents will be removed</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RemoveDocumentsFromNodeWithHttpInfo (DocumentIDs body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->RemoveDocumentsFromNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->RemoveDocumentsFromNode");

            var localVarPath = "/nodes/{node_id}/documents";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveDocumentsFromNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Remove documents from a node Remove one or more documents from a node. This action requires &#x60;can_update&#x60; permission on the node and &#x60;can_read&#x60; permission on the document.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the documents will be removed</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveDocumentsFromNodeAsync (DocumentIDs body, long? nodeId)
        {
             await RemoveDocumentsFromNodeAsyncWithHttpInfo(body, nodeId);

        }

        /// <summary>
        /// Remove documents from a node Remove one or more documents from a node. This action requires &#x60;can_update&#x60; permission on the node and &#x60;can_read&#x60; permission on the document.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the documents will be removed</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RemoveDocumentsFromNodeAsyncWithHttpInfo (DocumentIDs body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->RemoveDocumentsFromNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->RemoveDocumentsFromNode");

            var localVarPath = "/nodes/{node_id}/documents";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveDocumentsFromNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Remove instrumentations from a node Remove one or more instrumentations from a node in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the node and on the instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the instrumentations will be removed</param>
        /// <returns></returns>
        public void RemoveInstrumentationsFromNode (InstrumentationIDs body, long? nodeId)
        {
             RemoveInstrumentationsFromNodeWithHttpInfo(body, nodeId);
        }

        /// <summary>
        /// Remove instrumentations from a node Remove one or more instrumentations from a node in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the node and on the instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the instrumentations will be removed</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RemoveInstrumentationsFromNodeWithHttpInfo (InstrumentationIDs body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->RemoveInstrumentationsFromNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->RemoveInstrumentationsFromNode");

            var localVarPath = "/nodes/{node_id}/instrumentations";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveInstrumentationsFromNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Remove instrumentations from a node Remove one or more instrumentations from a node in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the node and on the instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the instrumentations will be removed</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveInstrumentationsFromNodeAsync (InstrumentationIDs body, long? nodeId)
        {
             await RemoveInstrumentationsFromNodeAsyncWithHttpInfo(body, nodeId);

        }

        /// <summary>
        /// Remove instrumentations from a node Remove one or more instrumentations from a node in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the node and on the instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the instrumentations will be removed</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RemoveInstrumentationsFromNodeAsyncWithHttpInfo (InstrumentationIDs body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->RemoveInstrumentationsFromNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->RemoveInstrumentationsFromNode");

            var localVarPath = "/nodes/{node_id}/instrumentations";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveInstrumentationsFromNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Remove recipes from a node Remove one or more recipes from a node in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the node and on the recipe.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the recipes will be removed</param>
        /// <returns></returns>
        public void RemoveRecipesFromNode (RecipeIDs body, long? nodeId)
        {
             RemoveRecipesFromNodeWithHttpInfo(body, nodeId);
        }

        /// <summary>
        /// Remove recipes from a node Remove one or more recipes from a node in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the node and on the recipe.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the recipes will be removed</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RemoveRecipesFromNodeWithHttpInfo (RecipeIDs body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->RemoveRecipesFromNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->RemoveRecipesFromNode");

            var localVarPath = "/nodes/{node_id}/recipes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveRecipesFromNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Remove recipes from a node Remove one or more recipes from a node in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the node and on the recipe.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the recipes will be removed</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveRecipesFromNodeAsync (RecipeIDs body, long? nodeId)
        {
             await RemoveRecipesFromNodeAsyncWithHttpInfo(body, nodeId);

        }

        /// <summary>
        /// Remove recipes from a node Remove one or more recipes from a node in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the node and on the recipe.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the recipes will be removed</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RemoveRecipesFromNodeAsyncWithHttpInfo (RecipeIDs body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->RemoveRecipesFromNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->RemoveRecipesFromNode");

            var localVarPath = "/nodes/{node_id}/recipes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveRecipesFromNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete specifications of a node The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns></returns>
        public void RemoveSpecificationsFromNode (List<string> body, long? nodeId)
        {
             RemoveSpecificationsFromNodeWithHttpInfo(body, nodeId);
        }

        /// <summary>
        /// Delete specifications of a node The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RemoveSpecificationsFromNodeWithHttpInfo (List<string> body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->RemoveSpecificationsFromNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->RemoveSpecificationsFromNode");

            var localVarPath = "/nodes/{node_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveSpecificationsFromNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete specifications of a node The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveSpecificationsFromNodeAsync (List<string> body, long? nodeId)
        {
             await RemoveSpecificationsFromNodeAsyncWithHttpInfo(body, nodeId);

        }

        /// <summary>
        /// Delete specifications of a node The specification keys in the body will be removed of the object in your accessible scope. If a key does not exist it will be ignored.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Array of keys to delete from specifications</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RemoveSpecificationsFromNodeAsyncWithHttpInfo (List<string> body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->RemoveSpecificationsFromNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->RemoveSpecificationsFromNode");

            var localVarPath = "/nodes/{node_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveSpecificationsFromNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Remove systems from a node Remove one or more systems from a node in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the node and on the system.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the systems will be removed</param>
        /// <returns></returns>
        public void RemoveSystemsFromNode (SystemIDs body, long? nodeId)
        {
             RemoveSystemsFromNodeWithHttpInfo(body, nodeId);
        }

        /// <summary>
        /// Remove systems from a node Remove one or more systems from a node in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the node and on the system.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the systems will be removed</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RemoveSystemsFromNodeWithHttpInfo (SystemIDs body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->RemoveSystemsFromNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->RemoveSystemsFromNode");

            var localVarPath = "/nodes/{node_id}/systems";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveSystemsFromNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Remove systems from a node Remove one or more systems from a node in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the node and on the system.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the systems will be removed</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveSystemsFromNodeAsync (SystemIDs body, long? nodeId)
        {
             await RemoveSystemsFromNodeAsyncWithHttpInfo(body, nodeId);

        }

        /// <summary>
        /// Remove systems from a node Remove one or more systems from a node in your accessible scope. This action requires &#x60;can_permit&#x60; permission on the node and on the system.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be removed.</param>
        /// <param name="nodeId">Id of the node from which the systems will be removed</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RemoveSystemsFromNodeAsyncWithHttpInfo (SystemIDs body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->RemoveSystemsFromNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->RemoveSystemsFromNode");

            var localVarPath = "/nodes/{node_id}/systems";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveSystemsFromNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of a node in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns></returns>
        public void RenameSpecificationsOfNode (SpecificationsRename body, long? nodeId)
        {
             RenameSpecificationsOfNodeWithHttpInfo(body, nodeId);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of a node in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RenameSpecificationsOfNodeWithHttpInfo (SpecificationsRename body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->RenameSpecificationsOfNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->RenameSpecificationsOfNode");

            var localVarPath = "/nodes/{node_id}/specifications/rename";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RenameSpecificationsOfNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Rename a specification key Rename one specification key of a node in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RenameSpecificationsOfNodeAsync (SpecificationsRename body, long? nodeId)
        {
             await RenameSpecificationsOfNodeAsyncWithHttpInfo(body, nodeId);

        }

        /// <summary>
        /// Rename a specification key Rename one specification key of a node in your accessible scope. The key name allows [a-z A-Z 0-9 . - _ ] all uppercase letters will be converted to lower-case.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications object to patch.</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RenameSpecificationsOfNodeAsyncWithHttpInfo (SpecificationsRename body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->RenameSpecificationsOfNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->RenameSpecificationsOfNode");

            var localVarPath = "/nodes/{node_id}/specifications/rename";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RenameSpecificationsOfNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Replace the assets of a node Replaces all assets belonging to a node in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the node and on the asset.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the assets will be replaced</param>
        /// <returns></returns>
        public void ReplaceAssetsOfNode (AssetIDs body, long? nodeId)
        {
             ReplaceAssetsOfNodeWithHttpInfo(body, nodeId);
        }

        /// <summary>
        /// Replace the assets of a node Replaces all assets belonging to a node in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the node and on the asset.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the assets will be replaced</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReplaceAssetsOfNodeWithHttpInfo (AssetIDs body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->ReplaceAssetsOfNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->ReplaceAssetsOfNode");

            var localVarPath = "/nodes/{node_id}/assets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceAssetsOfNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Replace the assets of a node Replaces all assets belonging to a node in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the node and on the asset.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the assets will be replaced</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task ReplaceAssetsOfNodeAsync (AssetIDs body, long? nodeId)
        {
             await ReplaceAssetsOfNodeAsyncWithHttpInfo(body, nodeId);

        }

        /// <summary>
        /// Replace the assets of a node Replaces all assets belonging to a node in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the node and on the asset.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the assets will be replaced</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> ReplaceAssetsOfNodeAsyncWithHttpInfo (AssetIDs body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->ReplaceAssetsOfNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->ReplaceAssetsOfNode");

            var localVarPath = "/nodes/{node_id}/assets";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceAssetsOfNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Replace the documents of a node Replaces all documents belonging to a node. You can send a list of resources that will replace all previous values. This action requires &#x60;can_update&#x60; permission on the node and &#x60;can_read&#x60; permission on the document.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the documents will be replaced</param>
        /// <returns></returns>
        public void ReplaceDocumentsOfNode (DocumentIDs body, long? nodeId)
        {
             ReplaceDocumentsOfNodeWithHttpInfo(body, nodeId);
        }

        /// <summary>
        /// Replace the documents of a node Replaces all documents belonging to a node. You can send a list of resources that will replace all previous values. This action requires &#x60;can_update&#x60; permission on the node and &#x60;can_read&#x60; permission on the document.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the documents will be replaced</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReplaceDocumentsOfNodeWithHttpInfo (DocumentIDs body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->ReplaceDocumentsOfNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->ReplaceDocumentsOfNode");

            var localVarPath = "/nodes/{node_id}/documents";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceDocumentsOfNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Replace the documents of a node Replaces all documents belonging to a node. You can send a list of resources that will replace all previous values. This action requires &#x60;can_update&#x60; permission on the node and &#x60;can_read&#x60; permission on the document.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the documents will be replaced</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task ReplaceDocumentsOfNodeAsync (DocumentIDs body, long? nodeId)
        {
             await ReplaceDocumentsOfNodeAsyncWithHttpInfo(body, nodeId);

        }

        /// <summary>
        /// Replace the documents of a node Replaces all documents belonging to a node. You can send a list of resources that will replace all previous values. This action requires &#x60;can_update&#x60; permission on the node and &#x60;can_read&#x60; permission on the document.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the documents will be replaced</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> ReplaceDocumentsOfNodeAsyncWithHttpInfo (DocumentIDs body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->ReplaceDocumentsOfNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->ReplaceDocumentsOfNode");

            var localVarPath = "/nodes/{node_id}/documents";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceDocumentsOfNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Replace the instrumentations of a node Replaces all instrumentations belonging to a node in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the node and on the instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the instrumentations will be replaced</param>
        /// <returns></returns>
        public void ReplaceInstrumentationsOfNode (InstrumentationIDs body, long? nodeId)
        {
             ReplaceInstrumentationsOfNodeWithHttpInfo(body, nodeId);
        }

        /// <summary>
        /// Replace the instrumentations of a node Replaces all instrumentations belonging to a node in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the node and on the instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the instrumentations will be replaced</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReplaceInstrumentationsOfNodeWithHttpInfo (InstrumentationIDs body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->ReplaceInstrumentationsOfNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->ReplaceInstrumentationsOfNode");

            var localVarPath = "/nodes/{node_id}/instrumentations";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceInstrumentationsOfNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Replace the instrumentations of a node Replaces all instrumentations belonging to a node in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the node and on the instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the instrumentations will be replaced</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task ReplaceInstrumentationsOfNodeAsync (InstrumentationIDs body, long? nodeId)
        {
             await ReplaceInstrumentationsOfNodeAsyncWithHttpInfo(body, nodeId);

        }

        /// <summary>
        /// Replace the instrumentations of a node Replaces all instrumentations belonging to a node in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the node and on the instrumentation.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the instrumentations will be replaced</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> ReplaceInstrumentationsOfNodeAsyncWithHttpInfo (InstrumentationIDs body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->ReplaceInstrumentationsOfNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->ReplaceInstrumentationsOfNode");

            var localVarPath = "/nodes/{node_id}/instrumentations";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceInstrumentationsOfNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Replace the recipes of a node Replaces all recipes belonging to a node in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the node and on the recipe.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the recipes will be replaced</param>
        /// <returns></returns>
        public void ReplaceRecipesOfNode (RecipeIDs body, long? nodeId)
        {
             ReplaceRecipesOfNodeWithHttpInfo(body, nodeId);
        }

        /// <summary>
        /// Replace the recipes of a node Replaces all recipes belonging to a node in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the node and on the recipe.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the recipes will be replaced</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReplaceRecipesOfNodeWithHttpInfo (RecipeIDs body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->ReplaceRecipesOfNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->ReplaceRecipesOfNode");

            var localVarPath = "/nodes/{node_id}/recipes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceRecipesOfNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Replace the recipes of a node Replaces all recipes belonging to a node in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the node and on the recipe.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the recipes will be replaced</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task ReplaceRecipesOfNodeAsync (RecipeIDs body, long? nodeId)
        {
             await ReplaceRecipesOfNodeAsyncWithHttpInfo(body, nodeId);

        }

        /// <summary>
        /// Replace the recipes of a node Replaces all recipes belonging to a node in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the node and on the recipe.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the recipes will be replaced</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> ReplaceRecipesOfNodeAsyncWithHttpInfo (RecipeIDs body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->ReplaceRecipesOfNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->ReplaceRecipesOfNode");

            var localVarPath = "/nodes/{node_id}/recipes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceRecipesOfNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Replace the systems of a node Replaces all systems belonging to a node in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the node and on the system.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the systems will be replaced</param>
        /// <returns></returns>
        public void ReplaceSystemsOfNode (SystemIDs body, long? nodeId)
        {
             ReplaceSystemsOfNodeWithHttpInfo(body, nodeId);
        }

        /// <summary>
        /// Replace the systems of a node Replaces all systems belonging to a node in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the node and on the system.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the systems will be replaced</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReplaceSystemsOfNodeWithHttpInfo (SystemIDs body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->ReplaceSystemsOfNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->ReplaceSystemsOfNode");

            var localVarPath = "/nodes/{node_id}/systems";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceSystemsOfNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Replace the systems of a node Replaces all systems belonging to a node in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the node and on the system.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the systems will be replaced</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task ReplaceSystemsOfNodeAsync (SystemIDs body, long? nodeId)
        {
             await ReplaceSystemsOfNodeAsyncWithHttpInfo(body, nodeId);

        }

        /// <summary>
        /// Replace the systems of a node Replaces all systems belonging to a node in your accessible scope. You can send a list of resources that will replace all previous values. This action requires &#x60;can_permit&#x60; permission on the node and on the system.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Resources that shall be replaced</param>
        /// <param name="nodeId">Id of the node of which the systems will be replaced</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> ReplaceSystemsOfNodeAsyncWithHttpInfo (SystemIDs body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->ReplaceSystemsOfNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->ReplaceSystemsOfNode");

            var localVarPath = "/nodes/{node_id}/systems";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceSystemsOfNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update a node Update accessible parameters of the requested resource in your accessible scope. To assign a parent node the user needs &#x60;can_permit&#x60; permission on the parent and on the current node.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the node to update</param>
        /// <returns></returns>
        public void UpdateNode (NodeRequest body, long? id)
        {
             UpdateNodeWithHttpInfo(body, id);
        }

        /// <summary>
        /// Update a node Update accessible parameters of the requested resource in your accessible scope. To assign a parent node the user needs &#x60;can_permit&#x60; permission on the parent and on the current node.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the node to update</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateNodeWithHttpInfo (NodeRequest body, long? id)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->UpdateNode");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling NodeApi->UpdateNode");

            var localVarPath = "/nodes/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update a node Update accessible parameters of the requested resource in your accessible scope. To assign a parent node the user needs &#x60;can_permit&#x60; permission on the parent and on the current node.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the node to update</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UpdateNodeAsync (NodeRequest body, long? id)
        {
             await UpdateNodeAsyncWithHttpInfo(body, id);

        }

        /// <summary>
        /// Update a node Update accessible parameters of the requested resource in your accessible scope. To assign a parent node the user needs &#x60;can_permit&#x60; permission on the parent and on the current node.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Parameters that shall be updated.</param>
        /// <param name="id">Id of the node to update</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> UpdateNodeAsyncWithHttpInfo (NodeRequest body, long? id)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->UpdateNode");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling NodeApi->UpdateNode");

            var localVarPath = "/nodes/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update an node picture Upload a new node picture. Check the file-storage quota. Allowed content-types are - image/gif - image/jpg - image/jpeg - image/png
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="image"></param>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>PictureResponse</returns>
        public PictureResponse UpdateNodePicture (byte[] image, long? nodeId, long? id)
        {
             ApiResponse<PictureResponse> localVarResponse = UpdateNodePictureWithHttpInfo(image, nodeId, id);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Update an node picture Upload a new node picture. Check the file-storage quota. Allowed content-types are - image/gif - image/jpg - image/jpeg - image/png
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="image"></param>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>ApiResponse of PictureResponse</returns>
        public ApiResponse< PictureResponse > UpdateNodePictureWithHttpInfo (byte[] image, long? nodeId, long? id)
        {
            // verify the required parameter 'image' is set
            if (image == null)
                throw new ApiException(400, "Missing required parameter 'image' when calling NodeApi->UpdateNodePicture");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->UpdateNodePicture");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling NodeApi->UpdateNodePicture");

            var localVarPath = "/nodes/{node_id}/pictures/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "multipart/form-data"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (image != null) localVarFileParams.Add("image", this.Configuration.ApiClient.ParameterToFile("image", image));
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateNodePicture", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PictureResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (PictureResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(PictureResponse)));
        }

        /// <summary>
        /// Update an node picture Upload a new node picture. Check the file-storage quota. Allowed content-types are - image/gif - image/jpg - image/jpeg - image/png
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="image"></param>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>Task of PictureResponse</returns>
        public async System.Threading.Tasks.Task<PictureResponse> UpdateNodePictureAsync (byte[] image, long? nodeId, long? id)
        {
             ApiResponse<PictureResponse> localVarResponse = await UpdateNodePictureAsyncWithHttpInfo(image, nodeId, id);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Update an node picture Upload a new node picture. Check the file-storage quota. Allowed content-types are - image/gif - image/jpg - image/jpeg - image/png
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="image"></param>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>Task of ApiResponse (PictureResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<PictureResponse>> UpdateNodePictureAsyncWithHttpInfo (byte[] image, long? nodeId, long? id)
        {
            // verify the required parameter 'image' is set
            if (image == null)
                throw new ApiException(400, "Missing required parameter 'image' when calling NodeApi->UpdateNodePicture");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->UpdateNodePicture");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling NodeApi->UpdateNodePicture");

            var localVarPath = "/nodes/{node_id}/pictures/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "multipart/form-data"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (image != null) localVarFileParams.Add("image", this.Configuration.ApiClient.ParameterToFile("image", image));
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateNodePicture", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PictureResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (PictureResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(PictureResponse)));
        }

        /// <summary>
        /// Update a node picture link Update a node picture link.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Picture link object to be updated</param>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>PictureResponse</returns>
        public PictureResponse UpdateNodePictureLink (PictureLinkRequest body, long? nodeId, long? id)
        {
             ApiResponse<PictureResponse> localVarResponse = UpdateNodePictureLinkWithHttpInfo(body, nodeId, id);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Update a node picture link Update a node picture link.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Picture link object to be updated</param>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>ApiResponse of PictureResponse</returns>
        public ApiResponse< PictureResponse > UpdateNodePictureLinkWithHttpInfo (PictureLinkRequest body, long? nodeId, long? id)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->UpdateNodePictureLink");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->UpdateNodePictureLink");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling NodeApi->UpdateNodePictureLink");

            var localVarPath = "/nodes/{node_id}/pictures/links/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateNodePictureLink", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PictureResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (PictureResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(PictureResponse)));
        }

        /// <summary>
        /// Update a node picture link Update a node picture link.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Picture link object to be updated</param>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>Task of PictureResponse</returns>
        public async System.Threading.Tasks.Task<PictureResponse> UpdateNodePictureLinkAsync (PictureLinkRequest body, long? nodeId, long? id)
        {
             ApiResponse<PictureResponse> localVarResponse = await UpdateNodePictureLinkAsyncWithHttpInfo(body, nodeId, id);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Update a node picture link Update a node picture link.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Picture link object to be updated</param>
        /// <param name="nodeId">Id of the node</param>
        /// <param name="id">Id of the node picture</param>
        /// <returns>Task of ApiResponse (PictureResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<PictureResponse>> UpdateNodePictureLinkAsyncWithHttpInfo (PictureLinkRequest body, long? nodeId, long? id)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->UpdateNodePictureLink");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->UpdateNodePictureLink");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling NodeApi->UpdateNodePictureLink");

            var localVarPath = "/nodes/{node_id}/pictures/links/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateNodePictureLink", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PictureResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (PictureResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(PictureResponse)));
        }

        /// <summary>
        /// Update specifications of a node Update the specification object of a node in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns></returns>
        public void UpdateSpecificationsOfNode (Dictionary<string, SpecificationUIVisibleRequest> body, long? nodeId)
        {
             UpdateSpecificationsOfNodeWithHttpInfo(body, nodeId);
        }

        /// <summary>
        /// Update specifications of a node Update the specification object of a node in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateSpecificationsOfNodeWithHttpInfo (Dictionary<string, SpecificationUIVisibleRequest> body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->UpdateSpecificationsOfNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->UpdateSpecificationsOfNode");

            var localVarPath = "/nodes/{node_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSpecificationsOfNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update specifications of a node Update the specification object of a node in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UpdateSpecificationsOfNodeAsync (Dictionary<string, SpecificationUIVisibleRequest> body, long? nodeId)
        {
             await UpdateSpecificationsOfNodeAsyncWithHttpInfo(body, nodeId);

        }

        /// <summary>
        /// Update specifications of a node Update the specification object of a node in your accessible scope. To add specifications, just add the key and set the value object with value, unit and source_timestamp. To mark an existing specification to be unknown, the value could be set to null. To delete keys, use the delete method. Multiple specification objects can be sent in the same request. Keys inside a specification are unique and can only be added once. Keys can only consist of [a-z A-Z 0-9 . - _ ]. All uppercase A-Z are converted to lower-case a-z. For a key that is send multiple times in the request body, only the last key-value is saved.
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The specifications objects to patch.</param>
        /// <param name="nodeId">Id of the specified node</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSpecificationsOfNodeAsyncWithHttpInfo (Dictionary<string, SpecificationUIVisibleRequest> body, long? nodeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodeApi->UpdateSpecificationsOfNode");
            // verify the required parameter 'nodeId' is set
            if (nodeId == null)
                throw new ApiException(400, "Missing required parameter 'nodeId' when calling NodeApi->UpdateSpecificationsOfNode");

            var localVarPath = "/nodes/{node_id}/specifications";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (nodeId != null) localVarPathParams.Add("node_id", this.Configuration.ApiClient.ParameterToString(nodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSpecificationsOfNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Upload an node picture Upload a new node picture. Checks the file-storage quota. Allowed content-types are - image/gif - image/jpg - image/jpeg - image/png
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="image"></param>
        /// <param name="id">Id of the node</param>
        /// <returns>PictureResponse</returns>
        public PictureResponse UploadNodePicture (byte[] image, long? id)
        {
             ApiResponse<PictureResponse> localVarResponse = UploadNodePictureWithHttpInfo(image, id);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Upload an node picture Upload a new node picture. Checks the file-storage quota. Allowed content-types are - image/gif - image/jpg - image/jpeg - image/png
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="image"></param>
        /// <param name="id">Id of the node</param>
        /// <returns>ApiResponse of PictureResponse</returns>
        public ApiResponse< PictureResponse > UploadNodePictureWithHttpInfo (byte[] image, long? id)
        {
            // verify the required parameter 'image' is set
            if (image == null)
                throw new ApiException(400, "Missing required parameter 'image' when calling NodeApi->UploadNodePicture");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling NodeApi->UploadNodePicture");

            var localVarPath = "/nodes/{id}/pictures";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "multipart/form-data"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (image != null) localVarFileParams.Add("image", this.Configuration.ApiClient.ParameterToFile("image", image));
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UploadNodePicture", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PictureResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (PictureResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(PictureResponse)));
        }

        /// <summary>
        /// Upload an node picture Upload a new node picture. Checks the file-storage quota. Allowed content-types are - image/gif - image/jpg - image/jpeg - image/png
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="image"></param>
        /// <param name="id">Id of the node</param>
        /// <returns>Task of PictureResponse</returns>
        public async System.Threading.Tasks.Task<PictureResponse> UploadNodePictureAsync (byte[] image, long? id)
        {
             ApiResponse<PictureResponse> localVarResponse = await UploadNodePictureAsyncWithHttpInfo(image, id);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Upload an node picture Upload a new node picture. Checks the file-storage quota. Allowed content-types are - image/gif - image/jpg - image/jpeg - image/png
        /// </summary>
        /// <exception cref="Netilion.Api.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="image"></param>
        /// <param name="id">Id of the node</param>
        /// <returns>Task of ApiResponse (PictureResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<PictureResponse>> UploadNodePictureAsyncWithHttpInfo (byte[] image, long? id)
        {
            // verify the required parameter 'image' is set
            if (image == null)
                throw new ApiException(400, "Missing required parameter 'image' when calling NodeApi->UploadNodePicture");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling NodeApi->UploadNodePicture");

            var localVarPath = "/nodes/{id}/pictures";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "multipart/form-data"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (image != null) localVarFileParams.Add("image", this.Configuration.ApiClient.ParameterToFile("image", image));
            // authentication (API-Key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("API-Key")))
            {
                localVarHeaderParams["API-Key"] = this.Configuration.GetApiKeyWithPrefix("API-Key");
            }
            // authentication (Authentication) required
            // http basic authentication required
            if (!String.IsNullOrEmpty(this.Configuration.Username) || !String.IsNullOrEmpty(this.Configuration.Password))
            {
                localVarHeaderParams["Authorization"] = "Basic " + ApiClient.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password);
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UploadNodePicture", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PictureResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (PictureResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(PictureResponse)));
        }

    }
}
